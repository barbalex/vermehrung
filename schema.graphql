schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

scalar _text

# expression to compare columns of type _text. All fields are combined with logical 'AND'.
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

# columns and relationships of "ae_art"
type ae_art {
  _rev_at: numeric

  # An object relationship
  ae_art_art: art
  changed: timestamp
  id: ID!
  name: String
  name_deutsch: String
  name_latein: String
}

# aggregated selection of "ae_art"
type ae_art_aggregate {
  aggregate: ae_art_aggregate_fields
  nodes: [ae_art!]!
}

# aggregate fields of "ae_art"
type ae_art_aggregate_fields {
  avg: ae_art_avg_fields
  count(columns: [ae_art_select_column!], distinct: Boolean): Int
  max: ae_art_max_fields
  min: ae_art_min_fields
  stddev: ae_art_stddev_fields
  stddev_pop: ae_art_stddev_pop_fields
  stddev_samp: ae_art_stddev_samp_fields
  sum: ae_art_sum_fields
  var_pop: ae_art_var_pop_fields
  var_samp: ae_art_var_samp_fields
  variance: ae_art_variance_fields
}

# order by aggregate values of table "ae_art"
input ae_art_aggregate_order_by {
  avg: ae_art_avg_order_by
  count: order_by
  max: ae_art_max_order_by
  min: ae_art_min_order_by
  stddev: ae_art_stddev_order_by
  stddev_pop: ae_art_stddev_pop_order_by
  stddev_samp: ae_art_stddev_samp_order_by
  sum: ae_art_sum_order_by
  var_pop: ae_art_var_pop_order_by
  var_samp: ae_art_var_samp_order_by
  variance: ae_art_variance_order_by
}

# input type for inserting array relation for remote table "ae_art"
input ae_art_arr_rel_insert_input {
  data: [ae_art_insert_input!]!
  on_conflict: ae_art_on_conflict
}

# aggregate avg on columns
type ae_art_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "ae_art"
input ae_art_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "ae_art". All fields are combined with a logical 'AND'.
input ae_art_bool_exp {
  _and: [ae_art_bool_exp]
  _not: ae_art_bool_exp
  _or: [ae_art_bool_exp]
  _rev_at: numeric_comparison_exp
  ae_art_art: art_bool_exp
  changed: timestamp_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  name_deutsch: String_comparison_exp
  name_latein: String_comparison_exp
}

# unique or primary key constraints on table "ae_art"
enum ae_art_constraint {
  # unique or primary key constraint
  ae_art_pkey
}

# input type for incrementing integer column in table "ae_art"
input ae_art_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "ae_art"
input ae_art_insert_input {
  _rev_at: numeric
  ae_art_art: art_obj_rel_insert_input
  changed: timestamp
  id: ID
  name: String
  name_deutsch: String
  name_latein: String
}

# aggregate max on columns
type ae_art_max_fields {
  _rev_at: numeric
  changed: timestamp
  id: ID
  name: String
  name_deutsch: String
  name_latein: String
}

# order by max() on columns of table "ae_art"
input ae_art_max_order_by {
  _rev_at: order_by
  changed: order_by
  id: order_by
  name: order_by
  name_deutsch: order_by
  name_latein: order_by
}

# aggregate min on columns
type ae_art_min_fields {
  _rev_at: numeric
  changed: timestamp
  id: ID
  name: String
  name_deutsch: String
  name_latein: String
}

# order by min() on columns of table "ae_art"
input ae_art_min_order_by {
  _rev_at: order_by
  changed: order_by
  id: order_by
  name: order_by
  name_deutsch: order_by
  name_latein: order_by
}

# response of any mutation on the table "ae_art"
type ae_art_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [ae_art!]!
}

# input type for inserting object relation for remote table "ae_art"
input ae_art_obj_rel_insert_input {
  data: ae_art_insert_input!
  on_conflict: ae_art_on_conflict
}

# on conflict condition type for table "ae_art"
input ae_art_on_conflict {
  constraint: ae_art_constraint!
  update_columns: [ae_art_update_column!]!
  where: ae_art_bool_exp
}

# ordering options when selecting data from "ae_art"
input ae_art_order_by {
  _rev_at: order_by
  ae_art_art: art_order_by
  changed: order_by
  id: order_by
  name: order_by
  name_deutsch: order_by
  name_latein: order_by
}

# primary key columns input for table: "ae_art"
input ae_art_pk_columns_input {
  id: ID!
}

# select columns of table "ae_art"
enum ae_art_select_column {
  # column name
  _rev_at

  # column name
  changed

  # column name
  id

  # column name
  name

  # column name
  name_deutsch

  # column name
  name_latein
}

# input type for updating data in table "ae_art"
input ae_art_set_input {
  _rev_at: numeric
  changed: timestamp
  id: ID
  name: String
  name_deutsch: String
  name_latein: String
}

# aggregate stddev on columns
type ae_art_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "ae_art"
input ae_art_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type ae_art_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "ae_art"
input ae_art_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type ae_art_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "ae_art"
input ae_art_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type ae_art_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "ae_art"
input ae_art_sum_order_by {
  _rev_at: order_by
}

# update columns of table "ae_art"
enum ae_art_update_column {
  # column name
  _rev_at

  # column name
  changed

  # column name
  id

  # column name
  name

  # column name
  name_deutsch

  # column name
  name_latein
}

# aggregate var_pop on columns
type ae_art_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "ae_art"
input ae_art_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type ae_art_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "ae_art"
input ae_art_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type ae_art_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "ae_art"
input ae_art_variance_order_by {
  _rev_at: order_by
}

# columns and relationships of "art"
type art {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean

  # An object relationship
  art_ae_art: ae_art

  # An array relationship
  art_files(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): [art_file!]!

  # An aggregated array relationship
  art_files_aggregate(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): art_file_aggregate!

  # An array relationship
  art_qk_choosens(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): [art_qk_choosen!]!

  # An aggregated array relationship
  art_qk_choosens_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): art_qk_choosen_aggregate!

  # An array relationship
  avs(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # An aggregated array relationship
  avs_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!
  changed: timestamp
  changed_by: String
  id: ID!

  # An array relationship
  kultur_revs(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): [kultur_rev!]!

  # An aggregated array relationship
  kultur_revs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): kultur_rev_aggregate!

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!

  # An array relationship
  lieferung_revs(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # An aggregated array relationship
  lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  sammel_lieferung_revs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # An aggregated array relationship
  sammel_lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammlung_revs(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): [sammlung_rev!]!

  # An aggregated array relationship
  sammlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): sammlung_rev_aggregate!

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
}

# aggregated selection of "art"
type art_aggregate {
  aggregate: art_aggregate_fields
  nodes: [art!]!
}

# aggregate fields of "art"
type art_aggregate_fields {
  avg: art_avg_fields
  count(columns: [art_select_column!], distinct: Boolean): Int
  max: art_max_fields
  min: art_min_fields
  stddev: art_stddev_fields
  stddev_pop: art_stddev_pop_fields
  stddev_samp: art_stddev_samp_fields
  sum: art_sum_fields
  var_pop: art_var_pop_fields
  var_samp: art_var_samp_fields
  variance: art_variance_fields
}

# order by aggregate values of table "art"
input art_aggregate_order_by {
  avg: art_avg_order_by
  count: order_by
  max: art_max_order_by
  min: art_min_order_by
  stddev: art_stddev_order_by
  stddev_pop: art_stddev_pop_order_by
  stddev_samp: art_stddev_samp_order_by
  sum: art_sum_order_by
  var_pop: art_var_pop_order_by
  var_samp: art_var_samp_order_by
  variance: art_variance_order_by
}

# input type for inserting array relation for remote table "art"
input art_arr_rel_insert_input {
  data: [art_insert_input!]!
  on_conflict: art_on_conflict
}

# aggregate avg on columns
type art_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "art"
input art_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "art". All fields are combined with a logical 'AND'.
input art_bool_exp {
  _and: [art_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_bool_exp
  _or: [art_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  ae_id: uuid_comparison_exp
  set: String_comparison_exp
  apflora_av: String_comparison_exp
  apflora_ap: Boolean_comparison_exp
  art_ae_art: ae_art_bool_exp
  art_files: art_file_bool_exp
  art_qk_choosens: art_qk_choosen_bool_exp
  avs: av_bool_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  kultur_revs: kultur_rev_bool_exp
  kulturs: kultur_bool_exp
  lieferung_revs: lieferung_rev_bool_exp
  lieferungs: lieferung_bool_exp
  sammel_lieferung_revs: sammel_lieferung_rev_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlung_revs: sammlung_rev_bool_exp
  sammlungs: sammlung_bool_exp
}

# unique or primary key constraints on table "art"
enum art_constraint {
  # unique or primary key constraint
  art_pkey
}

# columns and relationships of "art_file"
type art_file {
  _rev_at: numeric

  # An object relationship
  art: art
  art_id: uuid
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID!
  name: String
}

# aggregated selection of "art_file"
type art_file_aggregate {
  aggregate: art_file_aggregate_fields
  nodes: [art_file!]!
}

# aggregate fields of "art_file"
type art_file_aggregate_fields {
  avg: art_file_avg_fields
  count(columns: [art_file_select_column!], distinct: Boolean): Int
  max: art_file_max_fields
  min: art_file_min_fields
  stddev: art_file_stddev_fields
  stddev_pop: art_file_stddev_pop_fields
  stddev_samp: art_file_stddev_samp_fields
  sum: art_file_sum_fields
  var_pop: art_file_var_pop_fields
  var_samp: art_file_var_samp_fields
  variance: art_file_variance_fields
}

# order by aggregate values of table "art_file"
input art_file_aggregate_order_by {
  avg: art_file_avg_order_by
  count: order_by
  max: art_file_max_order_by
  min: art_file_min_order_by
  stddev: art_file_stddev_order_by
  stddev_pop: art_file_stddev_pop_order_by
  stddev_samp: art_file_stddev_samp_order_by
  sum: art_file_sum_order_by
  var_pop: art_file_var_pop_order_by
  var_samp: art_file_var_samp_order_by
  variance: art_file_variance_order_by
}

# input type for inserting array relation for remote table "art_file"
input art_file_arr_rel_insert_input {
  data: [art_file_insert_input!]!
  on_conflict: art_file_on_conflict
}

# aggregate avg on columns
type art_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "art_file"
input art_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "art_file". All fields are combined with a logical 'AND'.
input art_file_bool_exp {
  _and: [art_file_bool_exp]
  _not: art_file_bool_exp
  _or: [art_file_bool_exp]
  _rev_at: numeric_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "art_file"
enum art_file_constraint {
  # unique or primary key constraint
  art_file_pkey
}

# input type for incrementing integer column in table "art_file"
input art_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "art_file"
input art_file_insert_input {
  _rev_at: numeric
  art: art_obj_rel_insert_input
  art_id: uuid
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
}

# aggregate max on columns
type art_file_max_fields {
  _rev_at: numeric
  art_id: uuid
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
}

# order by max() on columns of table "art_file"
input art_file_max_order_by {
  _rev_at: order_by
  art_id: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type art_file_min_fields {
  _rev_at: numeric
  art_id: uuid
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
}

# order by min() on columns of table "art_file"
input art_file_min_order_by {
  _rev_at: order_by
  art_id: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "art_file"
type art_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_file!]!
}

# input type for inserting object relation for remote table "art_file"
input art_file_obj_rel_insert_input {
  data: art_file_insert_input!
  on_conflict: art_file_on_conflict
}

# on conflict condition type for table "art_file"
input art_file_on_conflict {
  constraint: art_file_constraint!
  update_columns: [art_file_update_column!]!
  where: art_file_bool_exp
}

# ordering options when selecting data from "art_file"
input art_file_order_by {
  _rev_at: order_by
  art: art_order_by
  art_id: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "art_file"
input art_file_pk_columns_input {
  id: ID!
}

# select columns of table "art_file"
enum art_file_select_column {
  # column name
  _rev_at

  # column name
  art_id

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name
}

# input type for updating data in table "art_file"
input art_file_set_input {
  _rev_at: numeric
  art_id: uuid
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
}

# aggregate stddev on columns
type art_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "art_file"
input art_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type art_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "art_file"
input art_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type art_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "art_file"
input art_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type art_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "art_file"
input art_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "art_file"
enum art_file_update_column {
  # column name
  _rev_at

  # column name
  art_id

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type art_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "art_file"
input art_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type art_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "art_file"
input art_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type art_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "art_file"
input art_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "art"
input art_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "art"
input art_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  art_ae_art: ae_art_obj_rel_insert_input
  art_files: art_file_arr_rel_insert_input
  art_qk_choosens: art_qk_choosen_arr_rel_insert_input
  avs: av_arr_rel_insert_input
  changed: timestamp
  changed_by: String
  id: ID
  kultur_revs: kultur_rev_arr_rel_insert_input
  kulturs: kultur_arr_rel_insert_input
  lieferung_revs: lieferung_rev_arr_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  sammel_lieferung_revs: sammel_lieferung_rev_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlung_revs: sammlung_rev_arr_rel_insert_input
  sammlungs: sammlung_arr_rel_insert_input
}

# aggregate max on columns
type art_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  changed: timestamp
  changed_by: String
  id: ID
}

# order by max() on columns of table "art"
input art_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  apflora_ap: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# aggregate min on columns
type art_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  changed: timestamp
  changed_by: String
  id: ID
}

# order by min() on columns of table "art"
input art_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  apflora_ap: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# response of any mutation on the table "art"
type art_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art!]!
}

# input type for inserting object relation for remote table "art"
input art_obj_rel_insert_input {
  data: art_insert_input!
  on_conflict: art_on_conflict
}

# on conflict condition type for table "art"
input art_on_conflict {
  constraint: art_constraint!
  update_columns: [art_update_column!]!
  where: art_bool_exp
}

# ordering options when selecting data from "art"
input art_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  apflora_ap: order_by
  art_ae_art: ae_art_order_by
  art_files_aggregate: art_file_aggregate_order_by
  art_qk_choosens_aggregate: art_qk_choosen_aggregate_order_by
  avs_aggregate: av_aggregate_order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_revs_aggregate: kultur_rev_aggregate_order_by
  kulturs_aggregate: kultur_aggregate_order_by
  lieferung_revs_aggregate: lieferung_rev_aggregate_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  sammel_lieferung_revs_aggregate: sammel_lieferung_rev_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlung_revs_aggregate: sammlung_rev_aggregate_order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
}

# primary key columns input for table: "art"
input art_pk_columns_input {
  id: ID!
}

# columns and relationships of "art_qk"
type art_qk {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID!

  # Primärschlüssel. Wird auch in Abfragen und createMessageFunctions benutzt
  name: String!
  sort: smallint
  titel: String
}

# aggregated selection of "art_qk"
type art_qk_aggregate {
  aggregate: art_qk_aggregate_fields
  nodes: [art_qk!]!
}

# aggregate fields of "art_qk"
type art_qk_aggregate_fields {
  avg: art_qk_avg_fields
  count(columns: [art_qk_select_column!], distinct: Boolean): Int
  max: art_qk_max_fields
  min: art_qk_min_fields
  stddev: art_qk_stddev_fields
  stddev_pop: art_qk_stddev_pop_fields
  stddev_samp: art_qk_stddev_samp_fields
  sum: art_qk_sum_fields
  var_pop: art_qk_var_pop_fields
  var_samp: art_qk_var_samp_fields
  variance: art_qk_variance_fields
}

# order by aggregate values of table "art_qk"
input art_qk_aggregate_order_by {
  avg: art_qk_avg_order_by
  count: order_by
  max: art_qk_max_order_by
  min: art_qk_min_order_by
  stddev: art_qk_stddev_order_by
  stddev_pop: art_qk_stddev_pop_order_by
  stddev_samp: art_qk_stddev_samp_order_by
  sum: art_qk_sum_order_by
  var_pop: art_qk_var_pop_order_by
  var_samp: art_qk_var_samp_order_by
  variance: art_qk_variance_order_by
}

# input type for inserting array relation for remote table "art_qk"
input art_qk_arr_rel_insert_input {
  data: [art_qk_insert_input!]!
  on_conflict: art_qk_on_conflict
}

# aggregate avg on columns
type art_qk_avg_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by avg() on columns of table "art_qk"
input art_qk_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# Boolean expression to filter rows from the table "art_qk". All fields are combined with a logical 'AND'.
input art_qk_bool_exp {
  _and: [art_qk_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_qk_bool_exp
  _or: [art_qk_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort: smallint_comparison_exp
  titel: String_comparison_exp
}

# columns and relationships of "art_qk_choosen"
type art_qk_choosen {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text

  # An object relationship
  art: art!
  art_id: uuid!
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID!
  qk_id: uuid!
}

# aggregated selection of "art_qk_choosen"
type art_qk_choosen_aggregate {
  aggregate: art_qk_choosen_aggregate_fields
  nodes: [art_qk_choosen!]!
}

# aggregate fields of "art_qk_choosen"
type art_qk_choosen_aggregate_fields {
  avg: art_qk_choosen_avg_fields
  count(columns: [art_qk_choosen_select_column!], distinct: Boolean): Int
  max: art_qk_choosen_max_fields
  min: art_qk_choosen_min_fields
  stddev: art_qk_choosen_stddev_fields
  stddev_pop: art_qk_choosen_stddev_pop_fields
  stddev_samp: art_qk_choosen_stddev_samp_fields
  sum: art_qk_choosen_sum_fields
  var_pop: art_qk_choosen_var_pop_fields
  var_samp: art_qk_choosen_var_samp_fields
  variance: art_qk_choosen_variance_fields
}

# order by aggregate values of table "art_qk_choosen"
input art_qk_choosen_aggregate_order_by {
  avg: art_qk_choosen_avg_order_by
  count: order_by
  max: art_qk_choosen_max_order_by
  min: art_qk_choosen_min_order_by
  stddev: art_qk_choosen_stddev_order_by
  stddev_pop: art_qk_choosen_stddev_pop_order_by
  stddev_samp: art_qk_choosen_stddev_samp_order_by
  sum: art_qk_choosen_sum_order_by
  var_pop: art_qk_choosen_var_pop_order_by
  var_samp: art_qk_choosen_var_samp_order_by
  variance: art_qk_choosen_variance_order_by
}

# input type for inserting array relation for remote table "art_qk_choosen"
input art_qk_choosen_arr_rel_insert_input {
  data: [art_qk_choosen_insert_input!]!
  on_conflict: art_qk_choosen_on_conflict
}

# aggregate avg on columns
type art_qk_choosen_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "art_qk_choosen"
input art_qk_choosen_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "art_qk_choosen". All fields are combined with a logical 'AND'.
input art_qk_choosen_bool_exp {
  _and: [art_qk_choosen_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_qk_choosen_bool_exp
  _or: [art_qk_choosen_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  choosen: Boolean_comparison_exp
  id: uuid_comparison_exp
  qk_id: uuid_comparison_exp
}

# unique or primary key constraints on table "art_qk_choosen"
enum art_qk_choosen_constraint {
  # unique or primary key constraint
  art_qk_choosen_pkey
}

# input type for incrementing integer column in table "art_qk_choosen"
input art_qk_choosen_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "art_qk_choosen"
input art_qk_choosen_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art: art_obj_rel_insert_input
  art_id: uuid
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  qk_id: uuid
}

# aggregate max on columns
type art_qk_choosen_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  qk_id: uuid
}

# order by max() on columns of table "art_qk_choosen"
input art_qk_choosen_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  qk_id: order_by
}

# aggregate min on columns
type art_qk_choosen_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  qk_id: uuid
}

# order by min() on columns of table "art_qk_choosen"
input art_qk_choosen_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  qk_id: order_by
}

# response of any mutation on the table "art_qk_choosen"
type art_qk_choosen_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_qk_choosen!]!
}

# input type for inserting object relation for remote table "art_qk_choosen"
input art_qk_choosen_obj_rel_insert_input {
  data: art_qk_choosen_insert_input!
  on_conflict: art_qk_choosen_on_conflict
}

# on conflict condition type for table "art_qk_choosen"
input art_qk_choosen_on_conflict {
  constraint: art_qk_choosen_constraint!
  update_columns: [art_qk_choosen_update_column!]!
  where: art_qk_choosen_bool_exp
}

# ordering options when selecting data from "art_qk_choosen"
input art_qk_choosen_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  art: art_order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  choosen: order_by
  id: order_by
  qk_id: order_by
}

# primary key columns input for table: "art_qk_choosen"
input art_qk_choosen_pk_columns_input {
  id: ID!
}

# columns and relationships of "art_qk_choosen_rev"
type art_qk_choosen_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text

  # An object relationship
  art: art!
  art_id: uuid!
  art_qk_choosen_id: uuid
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID!
  qk_id: uuid
}

# aggregated selection of "art_qk_choosen_rev"
type art_qk_choosen_rev_aggregate {
  aggregate: art_qk_choosen_rev_aggregate_fields
  nodes: [art_qk_choosen_rev!]!
}

# aggregate fields of "art_qk_choosen_rev"
type art_qk_choosen_rev_aggregate_fields {
  avg: art_qk_choosen_rev_avg_fields
  count(columns: [art_qk_choosen_rev_select_column!], distinct: Boolean): Int
  max: art_qk_choosen_rev_max_fields
  min: art_qk_choosen_rev_min_fields
  stddev: art_qk_choosen_rev_stddev_fields
  stddev_pop: art_qk_choosen_rev_stddev_pop_fields
  stddev_samp: art_qk_choosen_rev_stddev_samp_fields
  sum: art_qk_choosen_rev_sum_fields
  var_pop: art_qk_choosen_rev_var_pop_fields
  var_samp: art_qk_choosen_rev_var_samp_fields
  variance: art_qk_choosen_rev_variance_fields
}

# order by aggregate values of table "art_qk_choosen_rev"
input art_qk_choosen_rev_aggregate_order_by {
  avg: art_qk_choosen_rev_avg_order_by
  count: order_by
  max: art_qk_choosen_rev_max_order_by
  min: art_qk_choosen_rev_min_order_by
  stddev: art_qk_choosen_rev_stddev_order_by
  stddev_pop: art_qk_choosen_rev_stddev_pop_order_by
  stddev_samp: art_qk_choosen_rev_stddev_samp_order_by
  sum: art_qk_choosen_rev_sum_order_by
  var_pop: art_qk_choosen_rev_var_pop_order_by
  var_samp: art_qk_choosen_rev_var_samp_order_by
  variance: art_qk_choosen_rev_variance_order_by
}

# input type for inserting array relation for remote table "art_qk_choosen_rev"
input art_qk_choosen_rev_arr_rel_insert_input {
  data: [art_qk_choosen_rev_insert_input!]!
  on_conflict: art_qk_choosen_rev_on_conflict
}

# aggregate avg on columns
type art_qk_choosen_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "art_qk_choosen_rev". All fields are combined with a logical 'AND'.
input art_qk_choosen_rev_bool_exp {
  _and: [art_qk_choosen_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_qk_choosen_rev_bool_exp
  _or: [art_qk_choosen_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  art_qk_choosen_id: uuid_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  choosen: Boolean_comparison_exp
  id: uuid_comparison_exp
  qk_id: uuid_comparison_exp
}

# unique or primary key constraints on table "art_qk_choosen_rev"
enum art_qk_choosen_rev_constraint {
  # unique or primary key constraint
  art_qk_choosen_rev_pkey
}

# input type for incrementing integer column in table "art_qk_choosen_rev"
input art_qk_choosen_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "art_qk_choosen_rev"
input art_qk_choosen_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art: art_obj_rel_insert_input
  art_id: uuid
  art_qk_choosen_id: uuid
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  qk_id: uuid
}

# aggregate max on columns
type art_qk_choosen_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  art_qk_choosen_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  qk_id: uuid
}

# order by max() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  art_qk_choosen_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  qk_id: order_by
}

# aggregate min on columns
type art_qk_choosen_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  art_qk_choosen_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  qk_id: uuid
}

# order by min() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  art_qk_choosen_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  qk_id: order_by
}

# response of any mutation on the table "art_qk_choosen_rev"
type art_qk_choosen_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_qk_choosen_rev!]!
}

# input type for inserting object relation for remote table "art_qk_choosen_rev"
input art_qk_choosen_rev_obj_rel_insert_input {
  data: art_qk_choosen_rev_insert_input!
  on_conflict: art_qk_choosen_rev_on_conflict
}

# on conflict condition type for table "art_qk_choosen_rev"
input art_qk_choosen_rev_on_conflict {
  constraint: art_qk_choosen_rev_constraint!
  update_columns: [art_qk_choosen_rev_update_column!]!
  where: art_qk_choosen_rev_bool_exp
}

# ordering options when selecting data from "art_qk_choosen_rev"
input art_qk_choosen_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  art: art_order_by
  art_id: order_by
  art_qk_choosen_id: order_by
  changed: order_by
  changed_by: order_by
  choosen: order_by
  id: order_by
  qk_id: order_by
}

# primary key columns input for table: "art_qk_choosen_rev"
input art_qk_choosen_rev_pk_columns_input {
  id: ID!
}

# select columns of table "art_qk_choosen_rev"
enum art_qk_choosen_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  art_qk_choosen_id

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  qk_id
}

# input type for updating data in table "art_qk_choosen_rev"
input art_qk_choosen_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_id: uuid
  art_qk_choosen_id: uuid
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  qk_id: uuid
}

# aggregate stddev on columns
type art_qk_choosen_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type art_qk_choosen_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type art_qk_choosen_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type art_qk_choosen_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "art_qk_choosen_rev"
enum art_qk_choosen_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  art_qk_choosen_id

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  qk_id
}

# aggregate var_pop on columns
type art_qk_choosen_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type art_qk_choosen_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type art_qk_choosen_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "art_qk_choosen_rev"
input art_qk_choosen_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "art_qk_choosen"
enum art_qk_choosen_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  qk_id
}

# input type for updating data in table "art_qk_choosen"
input art_qk_choosen_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_id: uuid
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  qk_id: uuid
}

# aggregate stddev on columns
type art_qk_choosen_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "art_qk_choosen"
input art_qk_choosen_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type art_qk_choosen_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "art_qk_choosen"
input art_qk_choosen_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type art_qk_choosen_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "art_qk_choosen"
input art_qk_choosen_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type art_qk_choosen_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "art_qk_choosen"
input art_qk_choosen_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "art_qk_choosen"
enum art_qk_choosen_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  qk_id
}

# aggregate var_pop on columns
type art_qk_choosen_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "art_qk_choosen"
input art_qk_choosen_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type art_qk_choosen_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "art_qk_choosen"
input art_qk_choosen_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type art_qk_choosen_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "art_qk_choosen"
input art_qk_choosen_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# unique or primary key constraints on table "art_qk"
enum art_qk_constraint {
  # unique or primary key constraint
  art_qk_name_key

  # unique or primary key constraint
  art_qk_pkey
}

# input type for incrementing integer column in table "art_qk"
input art_qk_inc_input {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# input type for inserting data into table "art_qk"
input art_qk_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate max on columns
type art_qk_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by max() on columns of table "art_qk"
input art_qk_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# aggregate min on columns
type art_qk_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by min() on columns of table "art_qk"
input art_qk_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# response of any mutation on the table "art_qk"
type art_qk_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_qk!]!
}

# input type for inserting object relation for remote table "art_qk"
input art_qk_obj_rel_insert_input {
  data: art_qk_insert_input!
  on_conflict: art_qk_on_conflict
}

# on conflict condition type for table "art_qk"
input art_qk_on_conflict {
  constraint: art_qk_constraint!
  update_columns: [art_qk_update_column!]!
  where: art_qk_bool_exp
}

# ordering options when selecting data from "art_qk"
input art_qk_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# primary key columns input for table: "art_qk"
input art_qk_pk_columns_input {
  id: ID!
}

# columns and relationships of "art_qk_rev"
type art_qk_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_qk_id: uuid
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID!
  name: String
  sort: smallint
  titel: String
}

# aggregated selection of "art_qk_rev"
type art_qk_rev_aggregate {
  aggregate: art_qk_rev_aggregate_fields
  nodes: [art_qk_rev!]!
}

# aggregate fields of "art_qk_rev"
type art_qk_rev_aggregate_fields {
  avg: art_qk_rev_avg_fields
  count(columns: [art_qk_rev_select_column!], distinct: Boolean): Int
  max: art_qk_rev_max_fields
  min: art_qk_rev_min_fields
  stddev: art_qk_rev_stddev_fields
  stddev_pop: art_qk_rev_stddev_pop_fields
  stddev_samp: art_qk_rev_stddev_samp_fields
  sum: art_qk_rev_sum_fields
  var_pop: art_qk_rev_var_pop_fields
  var_samp: art_qk_rev_var_samp_fields
  variance: art_qk_rev_variance_fields
}

# order by aggregate values of table "art_qk_rev"
input art_qk_rev_aggregate_order_by {
  avg: art_qk_rev_avg_order_by
  count: order_by
  max: art_qk_rev_max_order_by
  min: art_qk_rev_min_order_by
  stddev: art_qk_rev_stddev_order_by
  stddev_pop: art_qk_rev_stddev_pop_order_by
  stddev_samp: art_qk_rev_stddev_samp_order_by
  sum: art_qk_rev_sum_order_by
  var_pop: art_qk_rev_var_pop_order_by
  var_samp: art_qk_rev_var_samp_order_by
  variance: art_qk_rev_variance_order_by
}

# input type for inserting array relation for remote table "art_qk_rev"
input art_qk_rev_arr_rel_insert_input {
  data: [art_qk_rev_insert_input!]!
  on_conflict: art_qk_rev_on_conflict
}

# aggregate avg on columns
type art_qk_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by avg() on columns of table "art_qk_rev"
input art_qk_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# Boolean expression to filter rows from the table "art_qk_rev". All fields are combined with a logical 'AND'.
input art_qk_rev_bool_exp {
  _and: [art_qk_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_qk_rev_bool_exp
  _or: [art_qk_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  art_qk_id: uuid_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort: smallint_comparison_exp
  titel: String_comparison_exp
}

# unique or primary key constraints on table "art_qk_rev"
enum art_qk_rev_constraint {
  # unique or primary key constraint
  art_qk_rev_pkey
}

# input type for incrementing integer column in table "art_qk_rev"
input art_qk_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# input type for inserting data into table "art_qk_rev"
input art_qk_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_qk_id: uuid
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate max on columns
type art_qk_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_qk_id: uuid
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by max() on columns of table "art_qk_rev"
input art_qk_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_qk_id: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# aggregate min on columns
type art_qk_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_qk_id: uuid
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by min() on columns of table "art_qk_rev"
input art_qk_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_qk_id: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# response of any mutation on the table "art_qk_rev"
type art_qk_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_qk_rev!]!
}

# input type for inserting object relation for remote table "art_qk_rev"
input art_qk_rev_obj_rel_insert_input {
  data: art_qk_rev_insert_input!
  on_conflict: art_qk_rev_on_conflict
}

# on conflict condition type for table "art_qk_rev"
input art_qk_rev_on_conflict {
  constraint: art_qk_rev_constraint!
  update_columns: [art_qk_rev_update_column!]!
  where: art_qk_rev_bool_exp
}

# ordering options when selecting data from "art_qk_rev"
input art_qk_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  art_qk_id: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# primary key columns input for table: "art_qk_rev"
input art_qk_rev_pk_columns_input {
  id: ID!
}

# select columns of table "art_qk_rev"
enum art_qk_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_qk_id

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# input type for updating data in table "art_qk_rev"
input art_qk_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_qk_id: uuid
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate stddev on columns
type art_qk_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev() on columns of table "art_qk_rev"
input art_qk_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_pop on columns
type art_qk_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_pop() on columns of table "art_qk_rev"
input art_qk_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_samp on columns
type art_qk_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_samp() on columns of table "art_qk_rev"
input art_qk_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate sum on columns
type art_qk_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# order by sum() on columns of table "art_qk_rev"
input art_qk_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# update columns of table "art_qk_rev"
enum art_qk_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_qk_id

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# aggregate var_pop on columns
type art_qk_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_pop() on columns of table "art_qk_rev"
input art_qk_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate var_samp on columns
type art_qk_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_samp() on columns of table "art_qk_rev"
input art_qk_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate variance on columns
type art_qk_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by variance() on columns of table "art_qk_rev"
input art_qk_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# select columns of table "art_qk"
enum art_qk_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# input type for updating data in table "art_qk"
input art_qk_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate stddev on columns
type art_qk_stddev_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev() on columns of table "art_qk"
input art_qk_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_pop on columns
type art_qk_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_pop() on columns of table "art_qk"
input art_qk_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_samp on columns
type art_qk_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_samp() on columns of table "art_qk"
input art_qk_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate sum on columns
type art_qk_sum_fields {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# order by sum() on columns of table "art_qk"
input art_qk_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# update columns of table "art_qk"
enum art_qk_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# aggregate var_pop on columns
type art_qk_var_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_pop() on columns of table "art_qk"
input art_qk_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate var_samp on columns
type art_qk_var_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_samp() on columns of table "art_qk"
input art_qk_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate variance on columns
type art_qk_variance_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by variance() on columns of table "art_qk"
input art_qk_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# columns and relationships of "art_rev"
type art_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  art_id: uuid!

  # An object relationship
  art_rev_ae_art: ae_art

  # An array relationship
  avs(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # An aggregated array relationship
  avs_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!
  changed: timestamp
  changed_by: String
  id: ID!

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
}

# aggregated selection of "art_rev"
type art_rev_aggregate {
  aggregate: art_rev_aggregate_fields
  nodes: [art_rev!]!
}

# aggregate fields of "art_rev"
type art_rev_aggregate_fields {
  avg: art_rev_avg_fields
  count(columns: [art_rev_select_column!], distinct: Boolean): Int
  max: art_rev_max_fields
  min: art_rev_min_fields
  stddev: art_rev_stddev_fields
  stddev_pop: art_rev_stddev_pop_fields
  stddev_samp: art_rev_stddev_samp_fields
  sum: art_rev_sum_fields
  var_pop: art_rev_var_pop_fields
  var_samp: art_rev_var_samp_fields
  variance: art_rev_variance_fields
}

# order by aggregate values of table "art_rev"
input art_rev_aggregate_order_by {
  avg: art_rev_avg_order_by
  count: order_by
  max: art_rev_max_order_by
  min: art_rev_min_order_by
  stddev: art_rev_stddev_order_by
  stddev_pop: art_rev_stddev_pop_order_by
  stddev_samp: art_rev_stddev_samp_order_by
  sum: art_rev_sum_order_by
  var_pop: art_rev_var_pop_order_by
  var_samp: art_rev_var_samp_order_by
  variance: art_rev_variance_order_by
}

# input type for inserting array relation for remote table "art_rev"
input art_rev_arr_rel_insert_input {
  data: [art_rev_insert_input!]!
  on_conflict: art_rev_on_conflict
}

# aggregate avg on columns
type art_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "art_rev"
input art_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "art_rev". All fields are combined with a logical 'AND'.
input art_rev_bool_exp {
  _and: [art_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: art_rev_bool_exp
  _or: [art_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  ae_id: uuid_comparison_exp
  set: String_comparison_exp
  apflora_av: String_comparison_exp
  apflora_ap: Boolean_comparison_exp
  art_id: uuid_comparison_exp
  art_rev_ae_art: ae_art_bool_exp
  avs: av_bool_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  kulturs: kultur_bool_exp
  lieferungs: lieferung_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlungs: sammlung_bool_exp
}

# unique or primary key constraints on table "art_rev"
enum art_rev_constraint {
  # unique or primary key constraint
  art_rev_pkey
}

# input type for incrementing integer column in table "art_rev"
input art_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "art_rev"
input art_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  art_id: uuid
  art_rev_ae_art: ae_art_obj_rel_insert_input
  avs: av_arr_rel_insert_input
  changed: timestamp
  changed_by: String
  id: ID
  kulturs: kultur_arr_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlungs: sammlung_arr_rel_insert_input
}

# aggregate max on columns
type art_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  ae_id: uuid
  set: String
  apflora_av: String
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
}

# order by max() on columns of table "art_rev"
input art_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# aggregate min on columns
type art_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  ae_id: uuid
  set: String
  apflora_av: String
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
}

# order by min() on columns of table "art_rev"
input art_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# response of any mutation on the table "art_rev"
type art_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [art_rev!]!
}

# input type for inserting object relation for remote table "art_rev"
input art_rev_obj_rel_insert_input {
  data: art_rev_insert_input!
  on_conflict: art_rev_on_conflict
}

# on conflict condition type for table "art_rev"
input art_rev_on_conflict {
  constraint: art_rev_constraint!
  update_columns: [art_rev_update_column!]!
  where: art_rev_bool_exp
}

# ordering options when selecting data from "art_rev"
input art_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  ae_id: order_by
  set: order_by
  apflora_av: order_by
  apflora_ap: order_by
  art_id: order_by
  art_rev_ae_art: ae_art_order_by
  avs_aggregate: av_aggregate_order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kulturs_aggregate: kultur_aggregate_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
}

# primary key columns input for table: "art_rev"
input art_rev_pk_columns_input {
  id: ID!
}

# select columns of table "art_rev"
enum art_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ae_id

  set

  apflora_av

  apflora_ap

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id
}

# input type for updating data in table "art_rev"
input art_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
}

# aggregate stddev on columns
type art_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "art_rev"
input art_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type art_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "art_rev"
input art_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type art_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "art_rev"
input art_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type art_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "art_rev"
input art_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "art_rev"
enum art_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ae_id
  set
  apflora_av
  apflora_ap

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id
}

# aggregate var_pop on columns
type art_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "art_rev"
input art_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type art_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "art_rev"
input art_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type art_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "art_rev"
input art_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "art"
enum art_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ae_id
  set
  apflora_av
  apflora_ap

  # column name
  changed

  # column name
  changed_by

  # column name
  id
}

# input type for updating data in table "art"
input art_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ae_id: uuid
  set: String
  apflora_av: String
  apflora_ap: Boolean
  changed: timestamp
  changed_by: String
  id: ID
}

# aggregate stddev on columns
type art_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "art"
input art_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type art_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "art"
input art_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type art_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "art"
input art_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type art_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "art"
input art_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "art"
enum art_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ae_id
  set
  apflora_av
  apflora_ap

  # column name
  changed

  # column name
  changed_by

  # column name
  id
}

# aggregate var_pop on columns
type art_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "art"
input art_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type art_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "art"
input art_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type art_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "art"
input art_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# columns and relationships of "av"
type av {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text

  # An object relationship
  art: art!
  art_id: uuid!
  changed: timestamp
  changed_by: String
  id: ID!

  # An object relationship
  person: person!
  person_id: uuid!
}

# aggregated selection of "av"
type av_aggregate {
  aggregate: av_aggregate_fields
  nodes: [av!]!
}

# aggregate fields of "av"
type av_aggregate_fields {
  avg: av_avg_fields
  count(columns: [av_select_column!], distinct: Boolean): Int
  max: av_max_fields
  min: av_min_fields
  stddev: av_stddev_fields
  stddev_pop: av_stddev_pop_fields
  stddev_samp: av_stddev_samp_fields
  sum: av_sum_fields
  var_pop: av_var_pop_fields
  var_samp: av_var_samp_fields
  variance: av_variance_fields
}

# order by aggregate values of table "av"
input av_aggregate_order_by {
  avg: av_avg_order_by
  count: order_by
  max: av_max_order_by
  min: av_min_order_by
  stddev: av_stddev_order_by
  stddev_pop: av_stddev_pop_order_by
  stddev_samp: av_stddev_samp_order_by
  sum: av_sum_order_by
  var_pop: av_var_pop_order_by
  var_samp: av_var_samp_order_by
  variance: av_variance_order_by
}

# input type for inserting array relation for remote table "av"
input av_arr_rel_insert_input {
  data: [av_insert_input!]!
  on_conflict: av_on_conflict
}

# aggregate avg on columns
type av_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "av"
input av_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "av". All fields are combined with a logical 'AND'.
input av_bool_exp {
  _and: [av_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: av_bool_exp
  _or: [av_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
}

# unique or primary key constraints on table "av"
enum av_constraint {
  # unique or primary key constraint
  av_person_id_art_id_key

  # unique or primary key constraint
  av_pkey
}

# input type for incrementing integer column in table "av"
input av_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "av"
input av_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art: art_obj_rel_insert_input
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person: person_obj_rel_insert_input
  person_id: uuid
}

# aggregate max on columns
type av_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by max() on columns of table "av"
input av_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# aggregate min on columns
type av_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by min() on columns of table "av"
input av_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# response of any mutation on the table "av"
type av_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [av!]!
}

# input type for inserting object relation for remote table "av"
input av_obj_rel_insert_input {
  data: av_insert_input!
  on_conflict: av_on_conflict
}

# on conflict condition type for table "av"
input av_on_conflict {
  constraint: av_constraint!
  update_columns: [av_update_column!]!
  where: av_bool_exp
}

# ordering options when selecting data from "av"
input av_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  art: art_order_by
  art_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person: person_order_by
  person_id: order_by
}

# primary key columns input for table: "av"
input av_pk_columns_input {
  id: ID!
}

# columns and relationships of "av_rev"
type av_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text

  # An object relationship
  art: art
  art_id: uuid
  av_id: uuid
  changed: timestamp
  changed_by: String
  id: ID!

  # An object relationship
  person: person
  person_id: uuid
}

# aggregated selection of "av_rev"
type av_rev_aggregate {
  aggregate: av_rev_aggregate_fields
  nodes: [av_rev!]!
}

# aggregate fields of "av_rev"
type av_rev_aggregate_fields {
  avg: av_rev_avg_fields
  count(columns: [av_rev_select_column!], distinct: Boolean): Int
  max: av_rev_max_fields
  min: av_rev_min_fields
  stddev: av_rev_stddev_fields
  stddev_pop: av_rev_stddev_pop_fields
  stddev_samp: av_rev_stddev_samp_fields
  sum: av_rev_sum_fields
  var_pop: av_rev_var_pop_fields
  var_samp: av_rev_var_samp_fields
  variance: av_rev_variance_fields
}

# order by aggregate values of table "av_rev"
input av_rev_aggregate_order_by {
  avg: av_rev_avg_order_by
  count: order_by
  max: av_rev_max_order_by
  min: av_rev_min_order_by
  stddev: av_rev_stddev_order_by
  stddev_pop: av_rev_stddev_pop_order_by
  stddev_samp: av_rev_stddev_samp_order_by
  sum: av_rev_sum_order_by
  var_pop: av_rev_var_pop_order_by
  var_samp: av_rev_var_samp_order_by
  variance: av_rev_variance_order_by
}

# input type for inserting array relation for remote table "av_rev"
input av_rev_arr_rel_insert_input {
  data: [av_rev_insert_input!]!
  on_conflict: av_rev_on_conflict
}

# aggregate avg on columns
type av_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "av_rev"
input av_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "av_rev". All fields are combined with a logical 'AND'.
input av_rev_bool_exp {
  _and: [av_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: av_rev_bool_exp
  _or: [av_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  av_id: uuid_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
}

# unique or primary key constraints on table "av_rev"
enum av_rev_constraint {
  # unique or primary key constraint
  av_rev_pkey
}

# input type for incrementing integer column in table "av_rev"
input av_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "av_rev"
input av_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art: art_obj_rel_insert_input
  art_id: uuid
  av_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person: person_obj_rel_insert_input
  person_id: uuid
}

# aggregate max on columns
type av_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  av_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by max() on columns of table "av_rev"
input av_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  av_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# aggregate min on columns
type av_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  av_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by min() on columns of table "av_rev"
input av_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  av_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# response of any mutation on the table "av_rev"
type av_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [av_rev!]!
}

# input type for inserting object relation for remote table "av_rev"
input av_rev_obj_rel_insert_input {
  data: av_rev_insert_input!
  on_conflict: av_rev_on_conflict
}

# on conflict condition type for table "av_rev"
input av_rev_on_conflict {
  constraint: av_rev_constraint!
  update_columns: [av_rev_update_column!]!
  where: av_rev_bool_exp
}

# ordering options when selecting data from "av_rev"
input av_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  art: art_order_by
  art_id: order_by
  av_id: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person: person_order_by
  person_id: order_by
}

# primary key columns input for table: "av_rev"
input av_rev_pk_columns_input {
  id: ID!
}

# select columns of table "av_rev"
enum av_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  av_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  person_id
}

# input type for updating data in table "av_rev"
input av_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_id: uuid
  av_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# aggregate stddev on columns
type av_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "av_rev"
input av_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type av_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "av_rev"
input av_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type av_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "av_rev"
input av_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type av_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "av_rev"
input av_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "av_rev"
enum av_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  av_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  person_id
}

# aggregate var_pop on columns
type av_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "av_rev"
input av_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type av_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "av_rev"
input av_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type av_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "av_rev"
input av_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "av"
enum av_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  person_id
}

# input type for updating data in table "av"
input av_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  art_id: uuid
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# aggregate stddev on columns
type av_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "av"
input av_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type av_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "av"
input av_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type av_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "av"
input av_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type av_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "av"
input av_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "av"
enum av_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  art_id

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  person_id
}

# aggregate var_pop on columns
type av_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "av"
input av_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type av_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "av"
input av_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type av_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "av"
input av_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# columns and relationships of "event"
type event {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid

  # An object relationship
  teilkultur: teilkultur
  teilkultur_id: uuid
}

# aggregated selection of "event"
type event_aggregate {
  aggregate: event_aggregate_fields
  nodes: [event!]!
}

# aggregate fields of "event"
type event_aggregate_fields {
  avg: event_avg_fields
  count(columns: [event_select_column!], distinct: Boolean): Int
  max: event_max_fields
  min: event_min_fields
  stddev: event_stddev_fields
  stddev_pop: event_stddev_pop_fields
  stddev_samp: event_stddev_samp_fields
  sum: event_sum_fields
  var_pop: event_var_pop_fields
  var_samp: event_var_samp_fields
  variance: event_variance_fields
}

# order by aggregate values of table "event"
input event_aggregate_order_by {
  avg: event_avg_order_by
  count: order_by
  max: event_max_order_by
  min: event_min_order_by
  stddev: event_stddev_order_by
  stddev_pop: event_stddev_pop_order_by
  stddev_samp: event_stddev_samp_order_by
  sum: event_sum_order_by
  var_pop: event_var_pop_order_by
  var_samp: event_var_samp_order_by
  variance: event_variance_order_by
}

# input type for inserting array relation for remote table "event"
input event_arr_rel_insert_input {
  data: [event_insert_input!]!
  on_conflict: event_on_conflict
}

# aggregate avg on columns
type event_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "event"
input event_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input event_bool_exp {
  _and: [event_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: event_bool_exp
  _or: [event_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geplant: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  teilkultur: teilkultur_bool_exp
  teilkultur_id: uuid_comparison_exp
}

# unique or primary key constraints on table "event"
enum event_constraint {
  # unique or primary key constraint
  event_pkey
}

# input type for incrementing integer column in table "event"
input event_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "event"
input event_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  teilkultur: teilkultur_obj_rel_insert_input
  teilkultur_id: uuid
}

# aggregate max on columns
type event_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# order by max() on columns of table "event"
input event_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
  person_id: order_by
  teilkultur_id: order_by
}

# aggregate min on columns
type event_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# order by min() on columns of table "event"
input event_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
  person_id: order_by
  teilkultur_id: order_by
}

# response of any mutation on the table "event"
type event_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [event!]!
}

# input type for inserting object relation for remote table "event"
input event_obj_rel_insert_input {
  data: event_insert_input!
  on_conflict: event_on_conflict
}

# on conflict condition type for table "event"
input event_on_conflict {
  constraint: event_constraint!
  update_columns: [event_update_column!]!
  where: event_bool_exp
}

# ordering options when selecting data from "event"
input event_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geplant: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  person: person_order_by
  person_id: order_by
  teilkultur: teilkultur_order_by
  teilkultur_id: order_by
}

# primary key columns input for table: "event"
input event_pk_columns_input {
  id: ID!
}

# columns and relationships of "event_rev"
type event_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  event_id: uuid!
  geplant: Boolean
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid

  # An object relationship
  teilkultur: teilkultur
  teilkultur_id: uuid
}

# aggregated selection of "event_rev"
type event_rev_aggregate {
  aggregate: event_rev_aggregate_fields
  nodes: [event_rev!]!
}

# aggregate fields of "event_rev"
type event_rev_aggregate_fields {
  avg: event_rev_avg_fields
  count(columns: [event_rev_select_column!], distinct: Boolean): Int
  max: event_rev_max_fields
  min: event_rev_min_fields
  stddev: event_rev_stddev_fields
  stddev_pop: event_rev_stddev_pop_fields
  stddev_samp: event_rev_stddev_samp_fields
  sum: event_rev_sum_fields
  var_pop: event_rev_var_pop_fields
  var_samp: event_rev_var_samp_fields
  variance: event_rev_variance_fields
}

# order by aggregate values of table "event_rev"
input event_rev_aggregate_order_by {
  avg: event_rev_avg_order_by
  count: order_by
  max: event_rev_max_order_by
  min: event_rev_min_order_by
  stddev: event_rev_stddev_order_by
  stddev_pop: event_rev_stddev_pop_order_by
  stddev_samp: event_rev_stddev_samp_order_by
  sum: event_rev_sum_order_by
  var_pop: event_rev_var_pop_order_by
  var_samp: event_rev_var_samp_order_by
  variance: event_rev_variance_order_by
}

# input type for inserting array relation for remote table "event_rev"
input event_rev_arr_rel_insert_input {
  data: [event_rev_insert_input!]!
  on_conflict: event_rev_on_conflict
}

# aggregate avg on columns
type event_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "event_rev"
input event_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "event_rev". All fields are combined with a logical 'AND'.
input event_rev_bool_exp {
  _and: [event_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: event_rev_bool_exp
  _or: [event_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  event_id: uuid_comparison_exp
  geplant: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  teilkultur: teilkultur_bool_exp
  teilkultur_id: uuid_comparison_exp
}

# unique or primary key constraints on table "event_rev"
enum event_rev_constraint {
  # unique or primary key constraint
  event_rev_pkey
}

# input type for incrementing integer column in table "event_rev"
input event_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "event_rev"
input event_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  event_id: uuid
  geplant: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  teilkultur: teilkultur_obj_rel_insert_input
  teilkultur_id: uuid
}

# aggregate max on columns
type event_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  event_id: uuid
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# order by max() on columns of table "event_rev"
input event_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  event_id: order_by
  id: order_by
  kultur_id: order_by
  person_id: order_by
  teilkultur_id: order_by
}

# aggregate min on columns
type event_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  event_id: uuid
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# order by min() on columns of table "event_rev"
input event_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  event_id: order_by
  id: order_by
  kultur_id: order_by
  person_id: order_by
  teilkultur_id: order_by
}

# response of any mutation on the table "event_rev"
type event_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [event_rev!]!
}

# input type for inserting object relation for remote table "event_rev"
input event_rev_obj_rel_insert_input {
  data: event_rev_insert_input!
  on_conflict: event_rev_on_conflict
}

# on conflict condition type for table "event_rev"
input event_rev_on_conflict {
  constraint: event_rev_constraint!
  update_columns: [event_rev_update_column!]!
  where: event_rev_bool_exp
}

# ordering options when selecting data from "event_rev"
input event_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  event_id: order_by
  geplant: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  person: person_order_by
  person_id: order_by
  teilkultur: teilkultur_order_by
  teilkultur_id: order_by
}

# primary key columns input for table: "event_rev"
input event_rev_pk_columns_input {
  id: ID!
}

# select columns of table "event_rev"
enum event_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  event_id

  # column name
  geplant

  # column name
  id

  # column name
  kultur_id

  # column name
  person_id

  # column name
  teilkultur_id
}

# input type for updating data in table "event_rev"
input event_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  event_id: uuid
  geplant: Boolean
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# aggregate stddev on columns
type event_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "event_rev"
input event_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type event_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "event_rev"
input event_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type event_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "event_rev"
input event_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type event_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "event_rev"
input event_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "event_rev"
enum event_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  event_id

  # column name
  geplant

  # column name
  id

  # column name
  kultur_id

  # column name
  person_id

  # column name
  teilkultur_id
}

# aggregate var_pop on columns
type event_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "event_rev"
input event_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type event_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "event_rev"
input event_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type event_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "event_rev"
input event_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "event"
enum event_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  id

  # column name
  kultur_id

  # column name
  person_id

  # column name
  teilkultur_id
}

# input type for updating data in table "event"
input event_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  id: ID
  kultur_id: uuid
  person_id: uuid
  teilkultur_id: uuid
}

# aggregate stddev on columns
type event_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "event"
input event_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type event_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "event"
input event_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type event_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "event"
input event_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type event_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "event"
input event_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "event"
enum event_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  id

  # column name
  kultur_id

  # column name
  person_id

  # column name
  teilkultur_id
}

# aggregate var_pop on columns
type event_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "event"
input event_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type event_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "event"
input event_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type event_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "event"
input event_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# columns and relationships of "garten"
type garten {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String

  # An array relationship
  garten_files(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): [garten_file!]!

  # An aggregated array relationship
  garten_files_aggregate(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): garten_file_aggregate!
  geom_point: geometry

  # An array relationship
  gvs(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): [gv!]!

  # An aggregated array relationship
  gvs_aggregate(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): gv_aggregate!
  id: ID!

  # An array relationship
  kultur_revs(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): [kultur_rev!]!

  # An aggregated array relationship
  kultur_revs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): kultur_rev_aggregate!

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!
  lv95_x: numeric
  lv95_y: numeric
  name: String
  ort: String

  # An object relationship
  person: person
  person_id: uuid
  plz: Int
  strasse: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregated selection of "garten"
type garten_aggregate {
  aggregate: garten_aggregate_fields
  nodes: [garten!]!
}

# aggregate fields of "garten"
type garten_aggregate_fields {
  avg: garten_avg_fields
  count(columns: [garten_select_column!], distinct: Boolean): Int
  max: garten_max_fields
  min: garten_min_fields
  stddev: garten_stddev_fields
  stddev_pop: garten_stddev_pop_fields
  stddev_samp: garten_stddev_samp_fields
  sum: garten_sum_fields
  var_pop: garten_var_pop_fields
  var_samp: garten_var_samp_fields
  variance: garten_variance_fields
}

# order by aggregate values of table "garten"
input garten_aggregate_order_by {
  avg: garten_avg_order_by
  count: order_by
  max: garten_max_order_by
  min: garten_min_order_by
  stddev: garten_stddev_order_by
  stddev_pop: garten_stddev_pop_order_by
  stddev_samp: garten_stddev_samp_order_by
  sum: garten_sum_order_by
  var_pop: garten_var_pop_order_by
  var_samp: garten_var_samp_order_by
  variance: garten_variance_order_by
}

# input type for inserting array relation for remote table "garten"
input garten_arr_rel_insert_input {
  data: [garten_insert_input!]!
  on_conflict: garten_on_conflict
}

# aggregate avg on columns
type garten_avg_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by avg() on columns of table "garten"
input garten_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# Boolean expression to filter rows from the table "garten". All fields are combined with a logical 'AND'.
input garten_bool_exp {
  _and: [garten_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: garten_bool_exp
  _or: [garten_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  aktiv: Boolean_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  garten_files: garten_file_bool_exp
  geom_point: geometry_comparison_exp
  gvs: gv_bool_exp
  id: uuid_comparison_exp
  kultur_revs: kultur_rev_bool_exp
  kulturs: kultur_bool_exp
  lv95_x: numeric_comparison_exp
  lv95_y: numeric_comparison_exp
  name: String_comparison_exp
  ort: String_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  plz: Int_comparison_exp
  strasse: String_comparison_exp
  wgs84_lat: numeric_comparison_exp
  wgs84_long: numeric_comparison_exp
}

# unique or primary key constraints on table "garten"
enum garten_constraint {
  # unique or primary key constraint
  garten_pkey
}

# columns and relationships of "garten_file"
type garten_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String

  # An object relationship
  garten: garten
  garten_id: uuid
  id: ID!
  name: String
}

# aggregated selection of "garten_file"
type garten_file_aggregate {
  aggregate: garten_file_aggregate_fields
  nodes: [garten_file!]!
}

# aggregate fields of "garten_file"
type garten_file_aggregate_fields {
  avg: garten_file_avg_fields
  count(columns: [garten_file_select_column!], distinct: Boolean): Int
  max: garten_file_max_fields
  min: garten_file_min_fields
  stddev: garten_file_stddev_fields
  stddev_pop: garten_file_stddev_pop_fields
  stddev_samp: garten_file_stddev_samp_fields
  sum: garten_file_sum_fields
  var_pop: garten_file_var_pop_fields
  var_samp: garten_file_var_samp_fields
  variance: garten_file_variance_fields
}

# order by aggregate values of table "garten_file"
input garten_file_aggregate_order_by {
  avg: garten_file_avg_order_by
  count: order_by
  max: garten_file_max_order_by
  min: garten_file_min_order_by
  stddev: garten_file_stddev_order_by
  stddev_pop: garten_file_stddev_pop_order_by
  stddev_samp: garten_file_stddev_samp_order_by
  sum: garten_file_sum_order_by
  var_pop: garten_file_var_pop_order_by
  var_samp: garten_file_var_samp_order_by
  variance: garten_file_variance_order_by
}

# input type for inserting array relation for remote table "garten_file"
input garten_file_arr_rel_insert_input {
  data: [garten_file_insert_input!]!
  on_conflict: garten_file_on_conflict
}

# aggregate avg on columns
type garten_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "garten_file"
input garten_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "garten_file". All fields are combined with a logical 'AND'.
input garten_file_bool_exp {
  _and: [garten_file_bool_exp]
  _not: garten_file_bool_exp
  _or: [garten_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  garten: garten_bool_exp
  garten_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "garten_file"
enum garten_file_constraint {
  # unique or primary key constraint
  garten_file_pkey
}

# input type for incrementing integer column in table "garten_file"
input garten_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "garten_file"
input garten_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  garten: garten_obj_rel_insert_input
  garten_id: uuid
  id: ID
  name: String
}

# aggregate max on columns
type garten_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  garten_id: uuid
  id: ID
  name: String
}

# order by max() on columns of table "garten_file"
input garten_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  garten_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type garten_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  garten_id: uuid
  id: ID
  name: String
}

# order by min() on columns of table "garten_file"
input garten_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  garten_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "garten_file"
type garten_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [garten_file!]!
}

# input type for inserting object relation for remote table "garten_file"
input garten_file_obj_rel_insert_input {
  data: garten_file_insert_input!
  on_conflict: garten_file_on_conflict
}

# on conflict condition type for table "garten_file"
input garten_file_on_conflict {
  constraint: garten_file_constraint!
  update_columns: [garten_file_update_column!]!
  where: garten_file_bool_exp
}

# ordering options when selecting data from "garten_file"
input garten_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  garten: garten_order_by
  garten_id: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "garten_file"
input garten_file_pk_columns_input {
  id: ID!
}

# select columns of table "garten_file"
enum garten_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  garten_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "garten_file"
input garten_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  garten_id: uuid
  id: ID
  name: String
}

# aggregate stddev on columns
type garten_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "garten_file"
input garten_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type garten_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "garten_file"
input garten_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type garten_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "garten_file"
input garten_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type garten_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "garten_file"
input garten_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "garten_file"
enum garten_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  garten_id

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type garten_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "garten_file"
input garten_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type garten_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "garten_file"
input garten_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type garten_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "garten_file"
input garten_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "garten"
input garten_inc_input {
  _depth: Int
  _rev_at: numeric
  lv95_x: numeric
  lv95_y: numeric
  plz: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# input type for inserting data into table "garten"
input garten_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_files: garten_file_arr_rel_insert_input
  geom_point: geometry
  gvs: gv_arr_rel_insert_input
  id: ID
  kultur_revs: kultur_rev_arr_rel_insert_input
  kulturs: kultur_arr_rel_insert_input
  lv95_x: numeric
  lv95_y: numeric
  name: String
  ort: String
  person: person_obj_rel_insert_input
  person_id: uuid
  plz: Int
  strasse: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate max on columns
type garten_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by max() on columns of table "garten"
input garten_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  lv95_x: order_by
  lv95_y: order_by
  name: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate min on columns
type garten_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by min() on columns of table "garten"
input garten_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  lv95_x: order_by
  lv95_y: order_by
  name: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# response of any mutation on the table "garten"
type garten_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [garten!]!
}

# input type for inserting object relation for remote table "garten"
input garten_obj_rel_insert_input {
  data: garten_insert_input!
  on_conflict: garten_on_conflict
}

# on conflict condition type for table "garten"
input garten_on_conflict {
  constraint: garten_constraint!
  update_columns: [garten_update_column!]!
  where: garten_bool_exp
}

# ordering options when selecting data from "garten"
input garten_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  aktiv: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_files_aggregate: garten_file_aggregate_order_by
  geom_point: order_by
  gvs_aggregate: gv_aggregate_order_by
  id: order_by
  kultur_revs_aggregate: kultur_rev_aggregate_order_by
  kulturs_aggregate: kultur_aggregate_order_by
  lv95_x: order_by
  lv95_y: order_by
  name: order_by
  ort: order_by
  person: person_order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# primary key columns input for table: "garten"
input garten_pk_columns_input {
  id: ID!
}

# columns and relationships of "garten_rev"
type garten_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid!
  geom_point: geometry
  id: ID!

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!
  name: String
  ort: String

  # An object relationship
  person: person
  person_id: uuid
  plz: Int
  strasse: String
}

# aggregated selection of "garten_rev"
type garten_rev_aggregate {
  aggregate: garten_rev_aggregate_fields
  nodes: [garten_rev!]!
}

# aggregate fields of "garten_rev"
type garten_rev_aggregate_fields {
  avg: garten_rev_avg_fields
  count(columns: [garten_rev_select_column!], distinct: Boolean): Int
  max: garten_rev_max_fields
  min: garten_rev_min_fields
  stddev: garten_rev_stddev_fields
  stddev_pop: garten_rev_stddev_pop_fields
  stddev_samp: garten_rev_stddev_samp_fields
  sum: garten_rev_sum_fields
  var_pop: garten_rev_var_pop_fields
  var_samp: garten_rev_var_samp_fields
  variance: garten_rev_variance_fields
}

# order by aggregate values of table "garten_rev"
input garten_rev_aggregate_order_by {
  avg: garten_rev_avg_order_by
  count: order_by
  max: garten_rev_max_order_by
  min: garten_rev_min_order_by
  stddev: garten_rev_stddev_order_by
  stddev_pop: garten_rev_stddev_pop_order_by
  stddev_samp: garten_rev_stddev_samp_order_by
  sum: garten_rev_sum_order_by
  var_pop: garten_rev_var_pop_order_by
  var_samp: garten_rev_var_samp_order_by
  variance: garten_rev_variance_order_by
}

# input type for inserting array relation for remote table "garten_rev"
input garten_rev_arr_rel_insert_input {
  data: [garten_rev_insert_input!]!
  on_conflict: garten_rev_on_conflict
}

# aggregate avg on columns
type garten_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by avg() on columns of table "garten_rev"
input garten_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# Boolean expression to filter rows from the table "garten_rev". All fields are combined with a logical 'AND'.
input garten_rev_bool_exp {
  _and: [garten_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: garten_rev_bool_exp
  _or: [garten_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  aktiv: Boolean_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  garten_id: uuid_comparison_exp
  geom_point: geometry_comparison_exp
  id: uuid_comparison_exp
  kulturs: kultur_bool_exp
  name: String_comparison_exp
  ort: String_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  plz: Int_comparison_exp
  strasse: String_comparison_exp
}

# unique or primary key constraints on table "garten_rev"
enum garten_rev_constraint {
  # unique or primary key constraint
  garten_rev_pkey
}

# input type for incrementing integer column in table "garten_rev"
input garten_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# input type for inserting data into table "garten_rev"
input garten_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  geom_point: geometry
  id: ID
  kulturs: kultur_arr_rel_insert_input
  name: String
  ort: String
  person: person_obj_rel_insert_input
  person_id: uuid
  plz: Int
  strasse: String
}

# aggregate max on columns
type garten_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  id: ID
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
}

# order by max() on columns of table "garten_rev"
input garten_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  id: order_by
  name: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
}

# aggregate min on columns
type garten_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  id: ID
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
}

# order by min() on columns of table "garten_rev"
input garten_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  id: order_by
  name: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
}

# response of any mutation on the table "garten_rev"
type garten_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [garten_rev!]!
}

# input type for inserting object relation for remote table "garten_rev"
input garten_rev_obj_rel_insert_input {
  data: garten_rev_insert_input!
  on_conflict: garten_rev_on_conflict
}

# on conflict condition type for table "garten_rev"
input garten_rev_on_conflict {
  constraint: garten_rev_constraint!
  update_columns: [garten_rev_update_column!]!
  where: garten_rev_bool_exp
}

# ordering options when selecting data from "garten_rev"
input garten_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  aktiv: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  geom_point: order_by
  id: order_by
  kulturs_aggregate: kultur_aggregate_order_by
  name: order_by
  ort: order_by
  person: person_order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
}

# primary key columns input for table: "garten_rev"
input garten_rev_pk_columns_input {
  id: ID!
}

# select columns of table "garten_rev"
enum garten_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  geom_point

  # column name
  id

  # column name
  name

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse
}

# input type for updating data in table "garten_rev"
input garten_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  geom_point: geometry
  id: ID
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
}

# aggregate stddev on columns
type garten_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev() on columns of table "garten_rev"
input garten_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_pop on columns
type garten_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_pop() on columns of table "garten_rev"
input garten_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_samp on columns
type garten_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_samp() on columns of table "garten_rev"
input garten_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate sum on columns
type garten_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# order by sum() on columns of table "garten_rev"
input garten_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# update columns of table "garten_rev"
enum garten_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  geom_point

  # column name
  id

  # column name
  name

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse
}

# aggregate var_pop on columns
type garten_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_pop() on columns of table "garten_rev"
input garten_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate var_samp on columns
type garten_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_samp() on columns of table "garten_rev"
input garten_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate variance on columns
type garten_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by variance() on columns of table "garten_rev"
input garten_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# select columns of table "garten"
enum garten_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  geom_point

  # column name
  id

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  name

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# input type for updating data in table "garten"
input garten_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  geom_point: geometry
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  name: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate stddev on columns
type garten_stddev_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev() on columns of table "garten"
input garten_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_pop on columns
type garten_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_pop() on columns of table "garten"
input garten_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_samp on columns
type garten_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_samp() on columns of table "garten"
input garten_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate sum on columns
type garten_sum_fields {
  _depth: Int
  _rev_at: numeric
  lv95_x: numeric
  lv95_y: numeric
  plz: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by sum() on columns of table "garten"
input garten_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# update columns of table "garten"
enum garten_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  geom_point

  # column name
  id

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  name

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# aggregate var_pop on columns
type garten_var_pop_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_pop() on columns of table "garten"
input garten_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate var_samp on columns
type garten_var_samp_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_samp() on columns of table "garten"
input garten_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate variance on columns
type garten_variance_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  plz: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by variance() on columns of table "garten"
input garten_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  plz: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

scalar geography

# Expression to compare the result of casting a column of type geography. Multiple
# cast targets are combined with logical 'AND'.
input geography_cast_exp {
  geometry: geometry_comparison_exp
}

# expression to compare columns of type geography. All fields are combined with logical 'AND'.
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  # is the column within a distance from a geography value
  _st_d_within: st_d_within_geography_input

  # does the column spatially intersect the given geography value
  _st_intersects: geography
}

scalar geometry

# Expression to compare the result of casting a column of type geometry. Multiple
# cast targets are combined with logical 'AND'.
input geometry_cast_exp {
  geography: geography_comparison_exp
}

# expression to compare columns of type geometry. All fields are combined with logical 'AND'.
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  # does the column contain the given geometry value
  _st_contains: geometry

  # does the column crosses the given geometry value
  _st_crosses: geometry

  # is the column within a distance from a geometry value
  _st_d_within: st_d_within_input

  # is the column equal to given geometry value. Directionality is ignored
  _st_equals: geometry

  # does the column spatially intersect the given geometry value
  _st_intersects: geometry

  # does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  _st_overlaps: geometry

  # does the column have atleast one point in common with the given geometry value
  _st_touches: geometry

  # is the column contained in the given geometry value
  _st_within: geometry
}

# columns and relationships of "gv"
type gv {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String

  # An object relationship
  garten: garten
  garten_id: uuid
  id: ID!

  # An object relationship
  person: person
  person_id: uuid
}

# aggregated selection of "gv"
type gv_aggregate {
  aggregate: gv_aggregate_fields
  nodes: [gv!]!
}

# aggregate fields of "gv"
type gv_aggregate_fields {
  avg: gv_avg_fields
  count(columns: [gv_select_column!], distinct: Boolean): Int
  max: gv_max_fields
  min: gv_min_fields
  stddev: gv_stddev_fields
  stddev_pop: gv_stddev_pop_fields
  stddev_samp: gv_stddev_samp_fields
  sum: gv_sum_fields
  var_pop: gv_var_pop_fields
  var_samp: gv_var_samp_fields
  variance: gv_variance_fields
}

# order by aggregate values of table "gv"
input gv_aggregate_order_by {
  avg: gv_avg_order_by
  count: order_by
  max: gv_max_order_by
  min: gv_min_order_by
  stddev: gv_stddev_order_by
  stddev_pop: gv_stddev_pop_order_by
  stddev_samp: gv_stddev_samp_order_by
  sum: gv_sum_order_by
  var_pop: gv_var_pop_order_by
  var_samp: gv_var_samp_order_by
  variance: gv_variance_order_by
}

# input type for inserting array relation for remote table "gv"
input gv_arr_rel_insert_input {
  data: [gv_insert_input!]!
  on_conflict: gv_on_conflict
}

# aggregate avg on columns
type gv_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "gv"
input gv_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "gv". All fields are combined with a logical 'AND'.
input gv_bool_exp {
  _and: [gv_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: gv_bool_exp
  _or: [gv_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  garten: garten_bool_exp
  garten_id: uuid_comparison_exp
  id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
}

# unique or primary key constraints on table "gv"
enum gv_constraint {
  # unique or primary key constraint
  gv_person_id_garten_id_key

  # unique or primary key constraint
  gv_pkey
}

# input type for incrementing integer column in table "gv"
input gv_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "gv"
input gv_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  garten: garten_obj_rel_insert_input
  garten_id: uuid
  id: ID
  person: person_obj_rel_insert_input
  person_id: uuid
}

# aggregate max on columns
type gv_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  garten_id: uuid
  id: ID
  person_id: uuid
}

# order by max() on columns of table "gv"
input gv_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  id: order_by
  person_id: order_by
}

# aggregate min on columns
type gv_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  garten_id: uuid
  id: ID
  person_id: uuid
}

# order by min() on columns of table "gv"
input gv_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  id: order_by
  person_id: order_by
}

# response of any mutation on the table "gv"
type gv_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [gv!]!
}

# input type for inserting object relation for remote table "gv"
input gv_obj_rel_insert_input {
  data: gv_insert_input!
  on_conflict: gv_on_conflict
}

# on conflict condition type for table "gv"
input gv_on_conflict {
  constraint: gv_constraint!
  update_columns: [gv_update_column!]!
  where: gv_bool_exp
}

# ordering options when selecting data from "gv"
input gv_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  garten: garten_order_by
  garten_id: order_by
  id: order_by
  person: person_order_by
  person_id: order_by
}

# primary key columns input for table: "gv"
input gv_pk_columns_input {
  id: ID!
}

# columns and relationships of "gv_rev"
type gv_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String

  # An object relationship
  garten: garten
  garten_id: uuid
  gv_id: uuid
  id: ID!

  # An object relationship
  person: person
  person_id: uuid
}

# aggregated selection of "gv_rev"
type gv_rev_aggregate {
  aggregate: gv_rev_aggregate_fields
  nodes: [gv_rev!]!
}

# aggregate fields of "gv_rev"
type gv_rev_aggregate_fields {
  avg: gv_rev_avg_fields
  count(columns: [gv_rev_select_column!], distinct: Boolean): Int
  max: gv_rev_max_fields
  min: gv_rev_min_fields
  stddev: gv_rev_stddev_fields
  stddev_pop: gv_rev_stddev_pop_fields
  stddev_samp: gv_rev_stddev_samp_fields
  sum: gv_rev_sum_fields
  var_pop: gv_rev_var_pop_fields
  var_samp: gv_rev_var_samp_fields
  variance: gv_rev_variance_fields
}

# order by aggregate values of table "gv_rev"
input gv_rev_aggregate_order_by {
  avg: gv_rev_avg_order_by
  count: order_by
  max: gv_rev_max_order_by
  min: gv_rev_min_order_by
  stddev: gv_rev_stddev_order_by
  stddev_pop: gv_rev_stddev_pop_order_by
  stddev_samp: gv_rev_stddev_samp_order_by
  sum: gv_rev_sum_order_by
  var_pop: gv_rev_var_pop_order_by
  var_samp: gv_rev_var_samp_order_by
  variance: gv_rev_variance_order_by
}

# input type for inserting array relation for remote table "gv_rev"
input gv_rev_arr_rel_insert_input {
  data: [gv_rev_insert_input!]!
  on_conflict: gv_rev_on_conflict
}

# aggregate avg on columns
type gv_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "gv_rev"
input gv_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "gv_rev". All fields are combined with a logical 'AND'.
input gv_rev_bool_exp {
  _and: [gv_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: gv_rev_bool_exp
  _or: [gv_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  garten: garten_bool_exp
  garten_id: uuid_comparison_exp
  gv_id: uuid_comparison_exp
  id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
}

# unique or primary key constraints on table "gv_rev"
enum gv_rev_constraint {
  # unique or primary key constraint
  gv_rev_pkey
}

# input type for incrementing integer column in table "gv_rev"
input gv_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "gv_rev"
input gv_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  garten: garten_obj_rel_insert_input
  garten_id: uuid
  gv_id: uuid
  id: ID
  person: person_obj_rel_insert_input
  person_id: uuid
}

# aggregate max on columns
type gv_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  garten_id: uuid
  gv_id: uuid
  id: ID
  person_id: uuid
}

# order by max() on columns of table "gv_rev"
input gv_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  gv_id: order_by
  id: order_by
  person_id: order_by
}

# aggregate min on columns
type gv_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  garten_id: uuid
  gv_id: uuid
  id: ID
  person_id: uuid
}

# order by min() on columns of table "gv_rev"
input gv_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  gv_id: order_by
  id: order_by
  person_id: order_by
}

# response of any mutation on the table "gv_rev"
type gv_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [gv_rev!]!
}

# input type for inserting object relation for remote table "gv_rev"
input gv_rev_obj_rel_insert_input {
  data: gv_rev_insert_input!
  on_conflict: gv_rev_on_conflict
}

# on conflict condition type for table "gv_rev"
input gv_rev_on_conflict {
  constraint: gv_rev_constraint!
  update_columns: [gv_rev_update_column!]!
  where: gv_rev_bool_exp
}

# ordering options when selecting data from "gv_rev"
input gv_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  garten: garten_order_by
  garten_id: order_by
  gv_id: order_by
  id: order_by
  person: person_order_by
  person_id: order_by
}

# primary key columns input for table: "gv_rev"
input gv_rev_pk_columns_input {
  id: ID!
}

# select columns of table "gv_rev"
enum gv_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  gv_id

  # column name
  id

  # column name
  person_id
}

# input type for updating data in table "gv_rev"
input gv_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  garten_id: uuid
  gv_id: uuid
  id: ID
  person_id: uuid
}

# aggregate stddev on columns
type gv_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "gv_rev"
input gv_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type gv_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "gv_rev"
input gv_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type gv_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "gv_rev"
input gv_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type gv_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "gv_rev"
input gv_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "gv_rev"
enum gv_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  gv_id

  # column name
  id

  # column name
  person_id
}

# aggregate var_pop on columns
type gv_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "gv_rev"
input gv_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type gv_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "gv_rev"
input gv_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type gv_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "gv_rev"
input gv_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "gv"
enum gv_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  id

  # column name
  person_id
}

# input type for updating data in table "gv"
input gv_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  garten_id: uuid
  id: ID
  person_id: uuid
}

# aggregate stddev on columns
type gv_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "gv"
input gv_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type gv_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "gv"
input gv_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type gv_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "gv"
input gv_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type gv_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "gv"
input gv_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "gv"
enum gv_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  garten_id

  # column name
  id

  # column name
  person_id
}

# aggregate var_pop on columns
type gv_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "gv"
input gv_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type gv_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "gv"
input gv_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type gv_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "gv"
input gv_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# columns and relationships of "herkunft"
type herkunft {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry

  # An array relationship
  herkunft_files(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): [herkunft_file!]!

  # An aggregated array relationship
  herkunft_files_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): herkunft_file_aggregate!
  id: ID!
  kanton: String

  # An array relationship
  kultur_revs(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): [kultur_rev!]!

  # An aggregated array relationship
  kultur_revs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): kultur_rev_aggregate!

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!
  land: String
  lokalname: String
  lv95_x: numeric
  lv95_y: numeric
  nr: String

  # An array relationship
  sammlung_revs(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): [sammlung_rev!]!

  # An aggregated array relationship
  sammlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): sammlung_rev_aggregate!

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregated selection of "herkunft"
type herkunft_aggregate {
  aggregate: herkunft_aggregate_fields
  nodes: [herkunft!]!
}

# aggregate fields of "herkunft"
type herkunft_aggregate_fields {
  avg: herkunft_avg_fields
  count(columns: [herkunft_select_column!], distinct: Boolean): Int
  max: herkunft_max_fields
  min: herkunft_min_fields
  stddev: herkunft_stddev_fields
  stddev_pop: herkunft_stddev_pop_fields
  stddev_samp: herkunft_stddev_samp_fields
  sum: herkunft_sum_fields
  var_pop: herkunft_var_pop_fields
  var_samp: herkunft_var_samp_fields
  variance: herkunft_variance_fields
}

# order by aggregate values of table "herkunft"
input herkunft_aggregate_order_by {
  avg: herkunft_avg_order_by
  count: order_by
  max: herkunft_max_order_by
  min: herkunft_min_order_by
  stddev: herkunft_stddev_order_by
  stddev_pop: herkunft_stddev_pop_order_by
  stddev_samp: herkunft_stddev_samp_order_by
  sum: herkunft_sum_order_by
  var_pop: herkunft_var_pop_order_by
  var_samp: herkunft_var_samp_order_by
  variance: herkunft_variance_order_by
}

# input type for inserting array relation for remote table "herkunft"
input herkunft_arr_rel_insert_input {
  data: [herkunft_insert_input!]!
  on_conflict: herkunft_on_conflict
}

# aggregate avg on columns
type herkunft_avg_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by avg() on columns of table "herkunft"
input herkunft_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# Boolean expression to filter rows from the table "herkunft". All fields are combined with a logical 'AND'.
input herkunft_bool_exp {
  _and: [herkunft_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: herkunft_bool_exp
  _or: [herkunft_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  gemeinde: String_comparison_exp
  geom_point: geometry_comparison_exp
  herkunft_files: herkunft_file_bool_exp
  id: uuid_comparison_exp
  kanton: String_comparison_exp
  kultur_revs: kultur_rev_bool_exp
  kulturs: kultur_bool_exp
  land: String_comparison_exp
  lokalname: String_comparison_exp
  lv95_x: numeric_comparison_exp
  lv95_y: numeric_comparison_exp
  nr: String_comparison_exp
  sammlung_revs: sammlung_rev_bool_exp
  sammlungs: sammlung_bool_exp
  wgs84_lat: numeric_comparison_exp
  wgs84_long: numeric_comparison_exp
}

# unique or primary key constraints on table "herkunft"
enum herkunft_constraint {
  # unique or primary key constraint
  herkunft_pkey
}

# columns and relationships of "herkunft_file"
type herkunft_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String

  # An object relationship
  herkunft: herkunft
  herkunft_id: uuid
  id: ID!
  name: String
}

# aggregated selection of "herkunft_file"
type herkunft_file_aggregate {
  aggregate: herkunft_file_aggregate_fields
  nodes: [herkunft_file!]!
}

# aggregate fields of "herkunft_file"
type herkunft_file_aggregate_fields {
  avg: herkunft_file_avg_fields
  count(columns: [herkunft_file_select_column!], distinct: Boolean): Int
  max: herkunft_file_max_fields
  min: herkunft_file_min_fields
  stddev: herkunft_file_stddev_fields
  stddev_pop: herkunft_file_stddev_pop_fields
  stddev_samp: herkunft_file_stddev_samp_fields
  sum: herkunft_file_sum_fields
  var_pop: herkunft_file_var_pop_fields
  var_samp: herkunft_file_var_samp_fields
  variance: herkunft_file_variance_fields
}

# order by aggregate values of table "herkunft_file"
input herkunft_file_aggregate_order_by {
  avg: herkunft_file_avg_order_by
  count: order_by
  max: herkunft_file_max_order_by
  min: herkunft_file_min_order_by
  stddev: herkunft_file_stddev_order_by
  stddev_pop: herkunft_file_stddev_pop_order_by
  stddev_samp: herkunft_file_stddev_samp_order_by
  sum: herkunft_file_sum_order_by
  var_pop: herkunft_file_var_pop_order_by
  var_samp: herkunft_file_var_samp_order_by
  variance: herkunft_file_variance_order_by
}

# input type for inserting array relation for remote table "herkunft_file"
input herkunft_file_arr_rel_insert_input {
  data: [herkunft_file_insert_input!]!
  on_conflict: herkunft_file_on_conflict
}

# aggregate avg on columns
type herkunft_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "herkunft_file"
input herkunft_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "herkunft_file". All fields are combined with a logical 'AND'.
input herkunft_file_bool_exp {
  _and: [herkunft_file_bool_exp]
  _not: herkunft_file_bool_exp
  _or: [herkunft_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  herkunft: herkunft_bool_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "herkunft_file"
enum herkunft_file_constraint {
  # unique or primary key constraint
  herkunft_file_pkey
}

# input type for incrementing integer column in table "herkunft_file"
input herkunft_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "herkunft_file"
input herkunft_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  herkunft: herkunft_obj_rel_insert_input
  herkunft_id: uuid
  id: ID
  name: String
}

# aggregate max on columns
type herkunft_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  herkunft_id: uuid
  id: ID
  name: String
}

# order by max() on columns of table "herkunft_file"
input herkunft_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  herkunft_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type herkunft_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  herkunft_id: uuid
  id: ID
  name: String
}

# order by min() on columns of table "herkunft_file"
input herkunft_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  herkunft_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "herkunft_file"
type herkunft_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [herkunft_file!]!
}

# input type for inserting object relation for remote table "herkunft_file"
input herkunft_file_obj_rel_insert_input {
  data: herkunft_file_insert_input!
  on_conflict: herkunft_file_on_conflict
}

# on conflict condition type for table "herkunft_file"
input herkunft_file_on_conflict {
  constraint: herkunft_file_constraint!
  update_columns: [herkunft_file_update_column!]!
  where: herkunft_file_bool_exp
}

# ordering options when selecting data from "herkunft_file"
input herkunft_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  herkunft: herkunft_order_by
  herkunft_id: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "herkunft_file"
input herkunft_file_pk_columns_input {
  id: ID!
}

# select columns of table "herkunft_file"
enum herkunft_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  herkunft_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "herkunft_file"
input herkunft_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  herkunft_id: uuid
  id: ID
  name: String
}

# aggregate stddev on columns
type herkunft_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "herkunft_file"
input herkunft_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type herkunft_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "herkunft_file"
input herkunft_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type herkunft_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "herkunft_file"
input herkunft_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type herkunft_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "herkunft_file"
input herkunft_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "herkunft_file"
enum herkunft_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  herkunft_id

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type herkunft_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "herkunft_file"
input herkunft_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type herkunft_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "herkunft_file"
input herkunft_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type herkunft_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "herkunft_file"
input herkunft_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "herkunft"
input herkunft_inc_input {
  _depth: Int
  _rev_at: numeric
  lv95_x: numeric
  lv95_y: numeric
  wgs84_lat: numeric
  wgs84_long: numeric
}

# input type for inserting data into table "herkunft"
input herkunft_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry
  herkunft_files: herkunft_file_arr_rel_insert_input
  id: ID
  kanton: String
  kultur_revs: kultur_rev_arr_rel_insert_input
  kulturs: kultur_arr_rel_insert_input
  land: String
  lokalname: String
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  sammlung_revs: sammlung_rev_arr_rel_insert_input
  sammlungs: sammlung_arr_rel_insert_input
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate max on columns
type herkunft_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  id: ID
  kanton: String
  land: String
  lokalname: String
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by max() on columns of table "herkunft"
input herkunft_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  id: order_by
  kanton: order_by
  land: order_by
  lokalname: order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate min on columns
type herkunft_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  id: ID
  kanton: String
  land: String
  lokalname: String
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by min() on columns of table "herkunft"
input herkunft_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  id: order_by
  kanton: order_by
  land: order_by
  lokalname: order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# response of any mutation on the table "herkunft"
type herkunft_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [herkunft!]!
}

# input type for inserting object relation for remote table "herkunft"
input herkunft_obj_rel_insert_input {
  data: herkunft_insert_input!
  on_conflict: herkunft_on_conflict
}

# on conflict condition type for table "herkunft"
input herkunft_on_conflict {
  constraint: herkunft_constraint!
  update_columns: [herkunft_update_column!]!
  where: herkunft_bool_exp
}

# ordering options when selecting data from "herkunft"
input herkunft_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  geom_point: order_by
  herkunft_files_aggregate: herkunft_file_aggregate_order_by
  id: order_by
  kanton: order_by
  kultur_revs_aggregate: kultur_rev_aggregate_order_by
  kulturs_aggregate: kultur_aggregate_order_by
  land: order_by
  lokalname: order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  sammlung_revs_aggregate: sammlung_rev_aggregate_order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# primary key columns input for table: "herkunft"
input herkunft_pk_columns_input {
  id: ID!
}

# columns and relationships of "herkunft_rev"
type herkunft_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry
  herkunft_id: uuid!
  id: ID!
  kanton: String

  # An array relationship
  kulturs(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # An aggregated array relationship
  kulturs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!
  land: String
  lokalname: String
  nr: String

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
}

# aggregated selection of "herkunft_rev"
type herkunft_rev_aggregate {
  aggregate: herkunft_rev_aggregate_fields
  nodes: [herkunft_rev!]!
}

# aggregate fields of "herkunft_rev"
type herkunft_rev_aggregate_fields {
  avg: herkunft_rev_avg_fields
  count(columns: [herkunft_rev_select_column!], distinct: Boolean): Int
  max: herkunft_rev_max_fields
  min: herkunft_rev_min_fields
  stddev: herkunft_rev_stddev_fields
  stddev_pop: herkunft_rev_stddev_pop_fields
  stddev_samp: herkunft_rev_stddev_samp_fields
  sum: herkunft_rev_sum_fields
  var_pop: herkunft_rev_var_pop_fields
  var_samp: herkunft_rev_var_samp_fields
  variance: herkunft_rev_variance_fields
}

# order by aggregate values of table "herkunft_rev"
input herkunft_rev_aggregate_order_by {
  avg: herkunft_rev_avg_order_by
  count: order_by
  max: herkunft_rev_max_order_by
  min: herkunft_rev_min_order_by
  stddev: herkunft_rev_stddev_order_by
  stddev_pop: herkunft_rev_stddev_pop_order_by
  stddev_samp: herkunft_rev_stddev_samp_order_by
  sum: herkunft_rev_sum_order_by
  var_pop: herkunft_rev_var_pop_order_by
  var_samp: herkunft_rev_var_samp_order_by
  variance: herkunft_rev_variance_order_by
}

# input type for inserting array relation for remote table "herkunft_rev"
input herkunft_rev_arr_rel_insert_input {
  data: [herkunft_rev_insert_input!]!
  on_conflict: herkunft_rev_on_conflict
}

# aggregate avg on columns
type herkunft_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "herkunft_rev"
input herkunft_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "herkunft_rev". All fields are combined with a logical 'AND'.
input herkunft_rev_bool_exp {
  _and: [herkunft_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: herkunft_rev_bool_exp
  _or: [herkunft_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  gemeinde: String_comparison_exp
  geom_point: geometry_comparison_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  kanton: String_comparison_exp
  kulturs: kultur_bool_exp
  land: String_comparison_exp
  lokalname: String_comparison_exp
  nr: String_comparison_exp
  sammlungs: sammlung_bool_exp
}

# unique or primary key constraints on table "herkunft_rev"
enum herkunft_rev_constraint {
  # unique or primary key constraint
  herkunft_rev_pkey
}

# input type for incrementing integer column in table "herkunft_rev"
input herkunft_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "herkunft_rev"
input herkunft_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry
  herkunft_id: uuid
  id: ID
  kanton: String
  kulturs: kultur_arr_rel_insert_input
  land: String
  lokalname: String
  nr: String
  sammlungs: sammlung_arr_rel_insert_input
}

# aggregate max on columns
type herkunft_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  herkunft_id: uuid
  id: ID
  kanton: String
  land: String
  lokalname: String
  nr: String
}

# order by max() on columns of table "herkunft_rev"
input herkunft_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  herkunft_id: order_by
  id: order_by
  kanton: order_by
  land: order_by
  lokalname: order_by
  nr: order_by
}

# aggregate min on columns
type herkunft_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  herkunft_id: uuid
  id: ID
  kanton: String
  land: String
  lokalname: String
  nr: String
}

# order by min() on columns of table "herkunft_rev"
input herkunft_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  herkunft_id: order_by
  id: order_by
  kanton: order_by
  land: order_by
  lokalname: order_by
  nr: order_by
}

# response of any mutation on the table "herkunft_rev"
type herkunft_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [herkunft_rev!]!
}

# input type for inserting object relation for remote table "herkunft_rev"
input herkunft_rev_obj_rel_insert_input {
  data: herkunft_rev_insert_input!
  on_conflict: herkunft_rev_on_conflict
}

# on conflict condition type for table "herkunft_rev"
input herkunft_rev_on_conflict {
  constraint: herkunft_rev_constraint!
  update_columns: [herkunft_rev_update_column!]!
  where: herkunft_rev_bool_exp
}

# ordering options when selecting data from "herkunft_rev"
input herkunft_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  gemeinde: order_by
  geom_point: order_by
  herkunft_id: order_by
  id: order_by
  kanton: order_by
  kulturs_aggregate: kultur_aggregate_order_by
  land: order_by
  lokalname: order_by
  nr: order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
}

# primary key columns input for table: "herkunft_rev"
input herkunft_rev_pk_columns_input {
  id: ID!
}

# select columns of table "herkunft_rev"
enum herkunft_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  gemeinde

  # column name
  geom_point

  # column name
  herkunft_id

  # column name
  id

  # column name
  kanton

  # column name
  land

  # column name
  lokalname

  # column name
  nr
}

# input type for updating data in table "herkunft_rev"
input herkunft_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry
  herkunft_id: uuid
  id: ID
  kanton: String
  land: String
  lokalname: String
  nr: String
}

# aggregate stddev on columns
type herkunft_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "herkunft_rev"
input herkunft_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type herkunft_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "herkunft_rev"
input herkunft_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type herkunft_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "herkunft_rev"
input herkunft_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type herkunft_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "herkunft_rev"
input herkunft_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "herkunft_rev"
enum herkunft_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  gemeinde

  # column name
  geom_point

  # column name
  herkunft_id

  # column name
  id

  # column name
  kanton

  # column name
  land

  # column name
  lokalname

  # column name
  nr
}

# aggregate var_pop on columns
type herkunft_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "herkunft_rev"
input herkunft_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type herkunft_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "herkunft_rev"
input herkunft_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type herkunft_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "herkunft_rev"
input herkunft_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "herkunft"
enum herkunft_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  gemeinde

  # column name
  geom_point

  # column name
  id

  # column name
  kanton

  # column name
  land

  # column name
  lokalname

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  nr

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# input type for updating data in table "herkunft"
input herkunft_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  gemeinde: String
  geom_point: geometry
  id: ID
  kanton: String
  land: String
  lokalname: String
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate stddev on columns
type herkunft_stddev_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev() on columns of table "herkunft"
input herkunft_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_pop on columns
type herkunft_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_pop() on columns of table "herkunft"
input herkunft_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_samp on columns
type herkunft_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_samp() on columns of table "herkunft"
input herkunft_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate sum on columns
type herkunft_sum_fields {
  _depth: Int
  _rev_at: numeric
  lv95_x: numeric
  lv95_y: numeric
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by sum() on columns of table "herkunft"
input herkunft_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# update columns of table "herkunft"
enum herkunft_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  gemeinde

  # column name
  geom_point

  # column name
  id

  # column name
  kanton

  # column name
  land

  # column name
  lokalname

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  nr

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# aggregate var_pop on columns
type herkunft_var_pop_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_pop() on columns of table "herkunft"
input herkunft_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate var_samp on columns
type herkunft_var_samp_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_samp() on columns of table "herkunft"
input herkunft_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate variance on columns
type herkunft_variance_fields {
  _depth: Float
  _rev_at: Float
  lv95_x: Float
  lv95_y: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by variance() on columns of table "herkunft"
input herkunft_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  lv95_x: order_by
  lv95_y: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "kultur"
type kultur {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean

  # An array relationship
  event_revs(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): [event_rev!]!

  # An aggregated array relationship
  event_revs_aggregate(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): event_rev_aggregate!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # An object relationship
  garten: garten
  garten_id: uuid

  # An object relationship
  herkunft: herkunft
  herkunft_id: uuid
  id: ID!

  # An array relationship
  kultur_files(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): [kultur_file!]!

  # An aggregated array relationship
  kultur_files_aggregate(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): kultur_file_aggregate!

  # An object relationship
  kultur_option: kultur_option

  # An array relationship
  kultur_option_revs(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): [kultur_option_rev!]!

  # An aggregated array relationship
  kultur_option_revs_aggregate(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): kultur_option_rev_aggregate!

  # An array relationship
  kultur_qk_choosens(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): [kultur_qk_choosen!]!

  # An aggregated array relationship
  kultur_qk_choosens_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): kultur_qk_choosen_aggregate!

  # An array relationship
  lieferungRevsByNachKulturId(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # An aggregated array relationship
  lieferungRevsByNachKulturId_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # An array relationship
  lieferung_revs(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # An aggregated array relationship
  lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # An array relationship
  lieferungsByNachKulturId(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungsByNachKulturId_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  lieferungsByVonKulturId(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungsByVonKulturId_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  sammelLieferungRevsByVonKulturId(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # An aggregated array relationship
  sammelLieferungRevsByVonKulturId_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # An array relationship
  sammelLieferungsByNachKulturId(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammelLieferungsByNachKulturId_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammel_lieferung_revs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # An aggregated array relationship
  sammel_lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  teilkultur_revs(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): [teilkultur_rev!]!

  # An aggregated array relationship
  teilkultur_revs_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): teilkultur_rev_aggregate!

  # An array relationship
  teilkulturs(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): [teilkultur!]!

  # An aggregated array relationship
  teilkulturs_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): teilkultur_aggregate!
  von_anzahl_individuen: Int

  # An array relationship
  zaehlung_revs(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): [zaehlung_rev!]!

  # An aggregated array relationship
  zaehlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): zaehlung_rev_aggregate!

  # An array relationship
  zaehlungs(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): [zaehlung!]!

  # An aggregated array relationship
  zaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): zaehlung_aggregate!
  zwischenlager: Boolean
}

# aggregated selection of "kultur"
type kultur_aggregate {
  aggregate: kultur_aggregate_fields
  nodes: [kultur!]!
}

# aggregate fields of "kultur"
type kultur_aggregate_fields {
  avg: kultur_avg_fields
  count(columns: [kultur_select_column!], distinct: Boolean): Int
  max: kultur_max_fields
  min: kultur_min_fields
  stddev: kultur_stddev_fields
  stddev_pop: kultur_stddev_pop_fields
  stddev_samp: kultur_stddev_samp_fields
  sum: kultur_sum_fields
  var_pop: kultur_var_pop_fields
  var_samp: kultur_var_samp_fields
  variance: kultur_variance_fields
}

# order by aggregate values of table "kultur"
input kultur_aggregate_order_by {
  avg: kultur_avg_order_by
  count: order_by
  max: kultur_max_order_by
  min: kultur_min_order_by
  stddev: kultur_stddev_order_by
  stddev_pop: kultur_stddev_pop_order_by
  stddev_samp: kultur_stddev_samp_order_by
  sum: kultur_sum_order_by
  var_pop: kultur_var_pop_order_by
  var_samp: kultur_var_samp_order_by
  variance: kultur_variance_order_by
}

# input type for inserting array relation for remote table "kultur"
input kultur_arr_rel_insert_input {
  data: [kultur_insert_input!]!
  on_conflict: kultur_on_conflict
}

# aggregate avg on columns
type kultur_avg_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "kultur"
input kultur_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "kultur". All fields are combined with a logical 'AND'.
input kultur_bool_exp {
  _and: [kultur_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_bool_exp
  _or: [kultur_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  aktiv: Boolean_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  erhaltungskultur: Boolean_comparison_exp
  event_revs: event_rev_bool_exp
  events: event_bool_exp
  garten: garten_bool_exp
  garten_id: uuid_comparison_exp
  herkunft: herkunft_bool_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  kultur_files: kultur_file_bool_exp
  kultur_option: kultur_option_bool_exp
  kultur_option_revs: kultur_option_rev_bool_exp
  kultur_qk_choosens: kultur_qk_choosen_bool_exp
  lieferungRevsByNachKulturId: lieferung_rev_bool_exp
  lieferung_revs: lieferung_rev_bool_exp
  lieferungsByNachKulturId: lieferung_bool_exp
  lieferungsByVonKulturId: lieferung_bool_exp
  sammelLieferungRevsByVonKulturId: sammel_lieferung_rev_bool_exp
  sammelLieferungsByNachKulturId: sammel_lieferung_bool_exp
  sammel_lieferung_revs: sammel_lieferung_rev_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  teilkultur_revs: teilkultur_rev_bool_exp
  teilkulturs: teilkultur_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  zaehlung_revs: zaehlung_rev_bool_exp
  zaehlungs: zaehlung_bool_exp
  zwischenlager: Boolean_comparison_exp
}

# unique or primary key constraints on table "kultur"
enum kultur_constraint {
  # unique or primary key constraint
  kultur_pkey

  # unique or primary key constraint
  single_art_herkunft_garden_active_idx

  # unique or primary key constraint
  single_art_herkunft_garden_zwischenlager_active_idx
}

# columns and relationships of "kultur_file"
type kultur_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid
  name: String
}

# aggregated selection of "kultur_file"
type kultur_file_aggregate {
  aggregate: kultur_file_aggregate_fields
  nodes: [kultur_file!]!
}

# aggregate fields of "kultur_file"
type kultur_file_aggregate_fields {
  avg: kultur_file_avg_fields
  count(columns: [kultur_file_select_column!], distinct: Boolean): Int
  max: kultur_file_max_fields
  min: kultur_file_min_fields
  stddev: kultur_file_stddev_fields
  stddev_pop: kultur_file_stddev_pop_fields
  stddev_samp: kultur_file_stddev_samp_fields
  sum: kultur_file_sum_fields
  var_pop: kultur_file_var_pop_fields
  var_samp: kultur_file_var_samp_fields
  variance: kultur_file_variance_fields
}

# order by aggregate values of table "kultur_file"
input kultur_file_aggregate_order_by {
  avg: kultur_file_avg_order_by
  count: order_by
  max: kultur_file_max_order_by
  min: kultur_file_min_order_by
  stddev: kultur_file_stddev_order_by
  stddev_pop: kultur_file_stddev_pop_order_by
  stddev_samp: kultur_file_stddev_samp_order_by
  sum: kultur_file_sum_order_by
  var_pop: kultur_file_var_pop_order_by
  var_samp: kultur_file_var_samp_order_by
  variance: kultur_file_variance_order_by
}

# input type for inserting array relation for remote table "kultur_file"
input kultur_file_arr_rel_insert_input {
  data: [kultur_file_insert_input!]!
  on_conflict: kultur_file_on_conflict
}

# aggregate avg on columns
type kultur_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "kultur_file"
input kultur_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "kultur_file". All fields are combined with a logical 'AND'.
input kultur_file_bool_exp {
  _and: [kultur_file_bool_exp]
  _not: kultur_file_bool_exp
  _or: [kultur_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "kultur_file"
enum kultur_file_constraint {
  # unique or primary key constraint
  kultur_file_pkey
}

# input type for incrementing integer column in table "kultur_file"
input kultur_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "kultur_file"
input kultur_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  name: String
}

# aggregate max on columns
type kultur_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  kultur_id: uuid
  name: String
}

# order by max() on columns of table "kultur_file"
input kultur_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
}

# aggregate min on columns
type kultur_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  kultur_id: uuid
  name: String
}

# order by min() on columns of table "kultur_file"
input kultur_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
}

# response of any mutation on the table "kultur_file"
type kultur_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_file!]!
}

# input type for inserting object relation for remote table "kultur_file"
input kultur_file_obj_rel_insert_input {
  data: kultur_file_insert_input!
  on_conflict: kultur_file_on_conflict
}

# on conflict condition type for table "kultur_file"
input kultur_file_on_conflict {
  constraint: kultur_file_constraint!
  update_columns: [kultur_file_update_column!]!
  where: kultur_file_bool_exp
}

# ordering options when selecting data from "kultur_file"
input kultur_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  name: order_by
}

# primary key columns input for table: "kultur_file"
input kultur_file_pk_columns_input {
  id: ID!
}

# select columns of table "kultur_file"
enum kultur_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  kultur_id

  # column name
  name
}

# input type for updating data in table "kultur_file"
input kultur_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  kultur_id: uuid
  name: String
}

# aggregate stddev on columns
type kultur_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "kultur_file"
input kultur_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type kultur_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "kultur_file"
input kultur_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type kultur_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "kultur_file"
input kultur_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type kultur_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "kultur_file"
input kultur_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "kultur_file"
enum kultur_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  kultur_id

  # column name
  name
}

# aggregate var_pop on columns
type kultur_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "kultur_file"
input kultur_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type kultur_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "kultur_file"
input kultur_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type kultur_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "kultur_file"
input kultur_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "kultur"
input kultur_inc_input {
  _depth: Int
  _rev_at: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "kultur"
input kultur_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean
  event_revs: event_rev_arr_rel_insert_input
  events: event_arr_rel_insert_input
  garten: garten_obj_rel_insert_input
  garten_id: uuid
  herkunft: herkunft_obj_rel_insert_input
  herkunft_id: uuid
  id: ID
  kultur_files: kultur_file_arr_rel_insert_input
  kultur_option: kultur_option_obj_rel_insert_input
  kultur_option_revs: kultur_option_rev_arr_rel_insert_input
  kultur_qk_choosens: kultur_qk_choosen_arr_rel_insert_input
  lieferungRevsByNachKulturId: lieferung_rev_arr_rel_insert_input
  lieferung_revs: lieferung_rev_arr_rel_insert_input
  lieferungsByNachKulturId: lieferung_arr_rel_insert_input
  lieferungsByVonKulturId: lieferung_arr_rel_insert_input
  sammelLieferungRevsByVonKulturId: sammel_lieferung_rev_arr_rel_insert_input
  sammelLieferungsByNachKulturId: sammel_lieferung_arr_rel_insert_input
  sammel_lieferung_revs: sammel_lieferung_rev_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  teilkultur_revs: teilkultur_rev_arr_rel_insert_input
  teilkulturs: teilkultur_arr_rel_insert_input
  von_anzahl_individuen: Int
  zaehlung_revs: zaehlung_rev_arr_rel_insert_input
  zaehlungs: zaehlung_arr_rel_insert_input
  zwischenlager: Boolean
}

# aggregate max on columns
type kultur_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  von_anzahl_individuen: Int
}

# order by max() on columns of table "kultur"
input kultur_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  herkunft_id: order_by
  id: order_by
  von_anzahl_individuen: order_by
}

# aggregate min on columns
type kultur_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  von_anzahl_individuen: Int
}

# order by min() on columns of table "kultur"
input kultur_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  herkunft_id: order_by
  id: order_by
  von_anzahl_individuen: order_by
}

# response of any mutation on the table "kultur"
type kultur_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur!]!
}

# input type for inserting object relation for remote table "kultur"
input kultur_obj_rel_insert_input {
  data: kultur_insert_input!
  on_conflict: kultur_on_conflict
}

# on conflict condition type for table "kultur"
input kultur_on_conflict {
  constraint: kultur_constraint!
  update_columns: [kultur_update_column!]!
  where: kultur_bool_exp
}

# columns and relationships of "kultur_option"
type kultur_option {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID!

  # An object relationship
  kultur: kultur!

  # opt-in Option für Teilkulturen
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregated selection of "kultur_option"
type kultur_option_aggregate {
  aggregate: kultur_option_aggregate_fields
  nodes: [kultur_option!]!
}

# aggregate fields of "kultur_option"
type kultur_option_aggregate_fields {
  avg: kultur_option_avg_fields
  count(columns: [kultur_option_select_column!], distinct: Boolean): Int
  max: kultur_option_max_fields
  min: kultur_option_min_fields
  stddev: kultur_option_stddev_fields
  stddev_pop: kultur_option_stddev_pop_fields
  stddev_samp: kultur_option_stddev_samp_fields
  sum: kultur_option_sum_fields
  var_pop: kultur_option_var_pop_fields
  var_samp: kultur_option_var_samp_fields
  variance: kultur_option_variance_fields
}

# order by aggregate values of table "kultur_option"
input kultur_option_aggregate_order_by {
  avg: kultur_option_avg_order_by
  count: order_by
  max: kultur_option_max_order_by
  min: kultur_option_min_order_by
  stddev: kultur_option_stddev_order_by
  stddev_pop: kultur_option_stddev_pop_order_by
  stddev_samp: kultur_option_stddev_samp_order_by
  sum: kultur_option_sum_order_by
  var_pop: kultur_option_var_pop_order_by
  var_samp: kultur_option_var_samp_order_by
  variance: kultur_option_variance_order_by
}

# input type for inserting array relation for remote table "kultur_option"
input kultur_option_arr_rel_insert_input {
  data: [kultur_option_insert_input!]!
  on_conflict: kultur_option_on_conflict
}

# aggregate avg on columns
type kultur_option_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "kultur_option"
input kultur_option_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "kultur_option". All fields are combined with a logical 'AND'.
input kultur_option_bool_exp {
  _and: [kultur_option_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_option_bool_exp
  _or: [kultur_option_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  ev_datum: Boolean_comparison_exp
  ev_geplant: Boolean_comparison_exp
  ev_person_id: Boolean_comparison_exp
  ev_teilkultur_id: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  tk: Boolean_comparison_exp
  tk_bemerkungen: Boolean_comparison_exp
  tz_andere_menge: Boolean_comparison_exp
  tz_anzahl_mutterpflanzen: Boolean_comparison_exp
  tz_auspflanzbereit_beschreibung: Boolean_comparison_exp
  tz_bemerkungen: Boolean_comparison_exp
  tz_teilkultur_id: Boolean_comparison_exp
  z_bemerkungen: Boolean_comparison_exp
}

# unique or primary key constraints on table "kultur_option"
enum kultur_option_constraint {
  # unique or primary key constraint
  kultur_option_kultur_id_key
}

# input type for incrementing integer column in table "kultur_option"
input kultur_option_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "kultur_option"
input kultur_option_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregate max on columns
type kultur_option_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
}

# order by max() on columns of table "kultur_option"
input kultur_option_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# aggregate min on columns
type kultur_option_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
}

# order by min() on columns of table "kultur_option"
input kultur_option_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# response of any mutation on the table "kultur_option"
type kultur_option_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_option!]!
}

# input type for inserting object relation for remote table "kultur_option"
input kultur_option_obj_rel_insert_input {
  data: kultur_option_insert_input!
  on_conflict: kultur_option_on_conflict
}

# on conflict condition type for table "kultur_option"
input kultur_option_on_conflict {
  constraint: kultur_option_constraint!
  update_columns: [kultur_option_update_column!]!
  where: kultur_option_bool_exp
}

# ordering options when selecting data from "kultur_option"
input kultur_option_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  ev_datum: order_by
  ev_geplant: order_by
  ev_person_id: order_by
  ev_teilkultur_id: order_by
  id: order_by
  kultur: kultur_order_by
  tk: order_by
  tk_bemerkungen: order_by
  tz_andere_menge: order_by
  tz_anzahl_mutterpflanzen: order_by
  tz_auspflanzbereit_beschreibung: order_by
  tz_bemerkungen: order_by
  tz_teilkultur_id: order_by
  z_bemerkungen: order_by
}

# columns and relationships of "kultur_option_rev"
type kultur_option_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID!

  # An object relationship
  kultur: kultur!
  kultur_id: uuid!
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregated selection of "kultur_option_rev"
type kultur_option_rev_aggregate {
  aggregate: kultur_option_rev_aggregate_fields
  nodes: [kultur_option_rev!]!
}

# aggregate fields of "kultur_option_rev"
type kultur_option_rev_aggregate_fields {
  avg: kultur_option_rev_avg_fields
  count(columns: [kultur_option_rev_select_column!], distinct: Boolean): Int
  max: kultur_option_rev_max_fields
  min: kultur_option_rev_min_fields
  stddev: kultur_option_rev_stddev_fields
  stddev_pop: kultur_option_rev_stddev_pop_fields
  stddev_samp: kultur_option_rev_stddev_samp_fields
  sum: kultur_option_rev_sum_fields
  var_pop: kultur_option_rev_var_pop_fields
  var_samp: kultur_option_rev_var_samp_fields
  variance: kultur_option_rev_variance_fields
}

# order by aggregate values of table "kultur_option_rev"
input kultur_option_rev_aggregate_order_by {
  avg: kultur_option_rev_avg_order_by
  count: order_by
  max: kultur_option_rev_max_order_by
  min: kultur_option_rev_min_order_by
  stddev: kultur_option_rev_stddev_order_by
  stddev_pop: kultur_option_rev_stddev_pop_order_by
  stddev_samp: kultur_option_rev_stddev_samp_order_by
  sum: kultur_option_rev_sum_order_by
  var_pop: kultur_option_rev_var_pop_order_by
  var_samp: kultur_option_rev_var_samp_order_by
  variance: kultur_option_rev_variance_order_by
}

# input type for inserting array relation for remote table "kultur_option_rev"
input kultur_option_rev_arr_rel_insert_input {
  data: [kultur_option_rev_insert_input!]!
  on_conflict: kultur_option_rev_on_conflict
}

# aggregate avg on columns
type kultur_option_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "kultur_option_rev"
input kultur_option_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "kultur_option_rev". All fields are combined with a logical 'AND'.
input kultur_option_rev_bool_exp {
  _and: [kultur_option_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_option_rev_bool_exp
  _or: [kultur_option_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  ev_datum: Boolean_comparison_exp
  ev_geplant: Boolean_comparison_exp
  ev_person_id: Boolean_comparison_exp
  ev_teilkultur_id: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  tk: Boolean_comparison_exp
  tk_bemerkungen: Boolean_comparison_exp
  tz_andere_menge: Boolean_comparison_exp
  tz_anzahl_mutterpflanzen: Boolean_comparison_exp
  tz_auspflanzbereit_beschreibung: Boolean_comparison_exp
  tz_bemerkungen: Boolean_comparison_exp
  tz_teilkultur_id: Boolean_comparison_exp
  z_bemerkungen: Boolean_comparison_exp
}

# unique or primary key constraints on table "kultur_option_rev"
enum kultur_option_rev_constraint {
  # unique or primary key constraint
  kultur_option_rev_pkey
}

# input type for incrementing integer column in table "kultur_option_rev"
input kultur_option_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "kultur_option_rev"
input kultur_option_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregate max on columns
type kultur_option_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
}

# order by max() on columns of table "kultur_option_rev"
input kultur_option_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
}

# aggregate min on columns
type kultur_option_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
}

# order by min() on columns of table "kultur_option_rev"
input kultur_option_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
}

# response of any mutation on the table "kultur_option_rev"
type kultur_option_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_option_rev!]!
}

# input type for inserting object relation for remote table "kultur_option_rev"
input kultur_option_rev_obj_rel_insert_input {
  data: kultur_option_rev_insert_input!
  on_conflict: kultur_option_rev_on_conflict
}

# on conflict condition type for table "kultur_option_rev"
input kultur_option_rev_on_conflict {
  constraint: kultur_option_rev_constraint!
  update_columns: [kultur_option_rev_update_column!]!
  where: kultur_option_rev_bool_exp
}

# ordering options when selecting data from "kultur_option_rev"
input kultur_option_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  ev_datum: order_by
  ev_geplant: order_by
  ev_person_id: order_by
  ev_teilkultur_id: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  tk: order_by
  tk_bemerkungen: order_by
  tz_andere_menge: order_by
  tz_anzahl_mutterpflanzen: order_by
  tz_auspflanzbereit_beschreibung: order_by
  tz_bemerkungen: order_by
  tz_teilkultur_id: order_by
  z_bemerkungen: order_by
}

# primary key columns input for table: "kultur_option_rev"
input kultur_option_rev_pk_columns_input {
  id: ID!
}

# select columns of table "kultur_option_rev"
enum kultur_option_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  ev_datum

  # column name
  ev_geplant

  # column name
  ev_person_id

  # column name
  ev_teilkultur_id

  # column name
  id

  # column name
  kultur_id

  # column name
  tk

  # column name
  tk_bemerkungen

  # column name
  tz_andere_menge

  # column name
  tz_anzahl_mutterpflanzen

  # column name
  tz_auspflanzbereit_beschreibung

  # column name
  tz_bemerkungen

  # column name
  tz_teilkultur_id

  # column name
  z_bemerkungen
}

# input type for updating data in table "kultur_option_rev"
input kultur_option_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID
  kultur_id: uuid
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregate stddev on columns
type kultur_option_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "kultur_option_rev"
input kultur_option_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type kultur_option_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "kultur_option_rev"
input kultur_option_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type kultur_option_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "kultur_option_rev"
input kultur_option_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type kultur_option_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "kultur_option_rev"
input kultur_option_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "kultur_option_rev"
enum kultur_option_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  ev_datum

  # column name
  ev_geplant

  # column name
  ev_person_id

  # column name
  ev_teilkultur_id

  # column name
  id

  # column name
  kultur_id

  # column name
  tk

  # column name
  tk_bemerkungen

  # column name
  tz_andere_menge

  # column name
  tz_anzahl_mutterpflanzen

  # column name
  tz_auspflanzbereit_beschreibung

  # column name
  tz_bemerkungen

  # column name
  tz_teilkultur_id

  # column name
  z_bemerkungen
}

# aggregate var_pop on columns
type kultur_option_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "kultur_option_rev"
input kultur_option_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type kultur_option_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "kultur_option_rev"
input kultur_option_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type kultur_option_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "kultur_option_rev"
input kultur_option_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "kultur_option"
enum kultur_option_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  ev_datum

  # column name
  ev_geplant

  # column name
  ev_person_id

  # column name
  ev_teilkultur_id

  # column name
  id

  # column name
  tk

  # column name
  tk_bemerkungen

  # column name
  tz_andere_menge

  # column name
  tz_anzahl_mutterpflanzen

  # column name
  tz_auspflanzbereit_beschreibung

  # column name
  tz_bemerkungen

  # column name
  tz_teilkultur_id

  # column name
  z_bemerkungen
}

# input type for updating data in table "kultur_option"
input kultur_option_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  ev_datum: Boolean
  ev_geplant: Boolean
  ev_person_id: Boolean
  ev_teilkultur_id: Boolean
  id: ID
  tk: Boolean
  tk_bemerkungen: Boolean
  tz_andere_menge: Boolean
  tz_anzahl_mutterpflanzen: Boolean
  tz_auspflanzbereit_beschreibung: Boolean
  tz_bemerkungen: Boolean
  tz_teilkultur_id: Boolean
  z_bemerkungen: Boolean
}

# aggregate stddev on columns
type kultur_option_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "kultur_option"
input kultur_option_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type kultur_option_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "kultur_option"
input kultur_option_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type kultur_option_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "kultur_option"
input kultur_option_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type kultur_option_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "kultur_option"
input kultur_option_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "kultur_option"
enum kultur_option_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  ev_datum

  # column name
  ev_geplant

  # column name
  ev_person_id

  # column name
  ev_teilkultur_id

  # column name
  id

  # column name
  tk

  # column name
  tk_bemerkungen

  # column name
  tz_andere_menge

  # column name
  tz_anzahl_mutterpflanzen

  # column name
  tz_auspflanzbereit_beschreibung

  # column name
  tz_bemerkungen

  # column name
  tz_teilkultur_id

  # column name
  z_bemerkungen
}

# aggregate var_pop on columns
type kultur_option_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "kultur_option"
input kultur_option_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type kultur_option_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "kultur_option"
input kultur_option_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type kultur_option_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "kultur_option"
input kultur_option_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# ordering options when selecting data from "kultur"
input kultur_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  aktiv: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  erhaltungskultur: order_by
  event_revs_aggregate: event_rev_aggregate_order_by
  events_aggregate: event_aggregate_order_by
  garten: garten_order_by
  garten_id: order_by
  herkunft: herkunft_order_by
  herkunft_id: order_by
  id: order_by
  kultur_files_aggregate: kultur_file_aggregate_order_by
  kultur_option: kultur_option_order_by
  kultur_option_revs_aggregate: kultur_option_rev_aggregate_order_by
  kultur_qk_choosens_aggregate: kultur_qk_choosen_aggregate_order_by
  lieferungRevsByNachKulturId_aggregate: lieferung_rev_aggregate_order_by
  lieferung_revs_aggregate: lieferung_rev_aggregate_order_by
  lieferungsByNachKulturId_aggregate: lieferung_aggregate_order_by
  lieferungsByVonKulturId_aggregate: lieferung_aggregate_order_by
  sammelLieferungRevsByVonKulturId_aggregate: sammel_lieferung_rev_aggregate_order_by
  sammelLieferungsByNachKulturId_aggregate: sammel_lieferung_aggregate_order_by
  sammel_lieferung_revs_aggregate: sammel_lieferung_rev_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  teilkultur_revs_aggregate: teilkultur_rev_aggregate_order_by
  teilkulturs_aggregate: teilkultur_aggregate_order_by
  von_anzahl_individuen: order_by
  zaehlung_revs_aggregate: zaehlung_rev_aggregate_order_by
  zaehlungs_aggregate: zaehlung_aggregate_order_by
  zwischenlager: order_by
}

# primary key columns input for table: "kultur"
input kultur_pk_columns_input {
  id: ID!
}

# columns and relationships of "kultur_qk"
type kultur_qk {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID!

  # Primärschlüssel. Wird auch in Abfragen und createMessageFunctions benutzt
  name: String!
  sort: smallint
  titel: String
}

# aggregated selection of "kultur_qk"
type kultur_qk_aggregate {
  aggregate: kultur_qk_aggregate_fields
  nodes: [kultur_qk!]!
}

# aggregate fields of "kultur_qk"
type kultur_qk_aggregate_fields {
  avg: kultur_qk_avg_fields
  count(columns: [kultur_qk_select_column!], distinct: Boolean): Int
  max: kultur_qk_max_fields
  min: kultur_qk_min_fields
  stddev: kultur_qk_stddev_fields
  stddev_pop: kultur_qk_stddev_pop_fields
  stddev_samp: kultur_qk_stddev_samp_fields
  sum: kultur_qk_sum_fields
  var_pop: kultur_qk_var_pop_fields
  var_samp: kultur_qk_var_samp_fields
  variance: kultur_qk_variance_fields
}

# order by aggregate values of table "kultur_qk"
input kultur_qk_aggregate_order_by {
  avg: kultur_qk_avg_order_by
  count: order_by
  max: kultur_qk_max_order_by
  min: kultur_qk_min_order_by
  stddev: kultur_qk_stddev_order_by
  stddev_pop: kultur_qk_stddev_pop_order_by
  stddev_samp: kultur_qk_stddev_samp_order_by
  sum: kultur_qk_sum_order_by
  var_pop: kultur_qk_var_pop_order_by
  var_samp: kultur_qk_var_samp_order_by
  variance: kultur_qk_variance_order_by
}

# input type for inserting array relation for remote table "kultur_qk"
input kultur_qk_arr_rel_insert_input {
  data: [kultur_qk_insert_input!]!
  on_conflict: kultur_qk_on_conflict
}

# aggregate avg on columns
type kultur_qk_avg_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by avg() on columns of table "kultur_qk"
input kultur_qk_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# Boolean expression to filter rows from the table "kultur_qk". All fields are combined with a logical 'AND'.
input kultur_qk_bool_exp {
  _and: [kultur_qk_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_qk_bool_exp
  _or: [kultur_qk_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sort: smallint_comparison_exp
  titel: String_comparison_exp
}

# columns and relationships of "kultur_qk_choosen"
type kultur_qk_choosen {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID!

  # An object relationship
  kultur: kultur!
  kultur_id: uuid!
  qk_id: uuid!
}

# aggregated selection of "kultur_qk_choosen"
type kultur_qk_choosen_aggregate {
  aggregate: kultur_qk_choosen_aggregate_fields
  nodes: [kultur_qk_choosen!]!
}

# aggregate fields of "kultur_qk_choosen"
type kultur_qk_choosen_aggregate_fields {
  avg: kultur_qk_choosen_avg_fields
  count(columns: [kultur_qk_choosen_select_column!], distinct: Boolean): Int
  max: kultur_qk_choosen_max_fields
  min: kultur_qk_choosen_min_fields
  stddev: kultur_qk_choosen_stddev_fields
  stddev_pop: kultur_qk_choosen_stddev_pop_fields
  stddev_samp: kultur_qk_choosen_stddev_samp_fields
  sum: kultur_qk_choosen_sum_fields
  var_pop: kultur_qk_choosen_var_pop_fields
  var_samp: kultur_qk_choosen_var_samp_fields
  variance: kultur_qk_choosen_variance_fields
}

# order by aggregate values of table "kultur_qk_choosen"
input kultur_qk_choosen_aggregate_order_by {
  avg: kultur_qk_choosen_avg_order_by
  count: order_by
  max: kultur_qk_choosen_max_order_by
  min: kultur_qk_choosen_min_order_by
  stddev: kultur_qk_choosen_stddev_order_by
  stddev_pop: kultur_qk_choosen_stddev_pop_order_by
  stddev_samp: kultur_qk_choosen_stddev_samp_order_by
  sum: kultur_qk_choosen_sum_order_by
  var_pop: kultur_qk_choosen_var_pop_order_by
  var_samp: kultur_qk_choosen_var_samp_order_by
  variance: kultur_qk_choosen_variance_order_by
}

# input type for inserting array relation for remote table "kultur_qk_choosen"
input kultur_qk_choosen_arr_rel_insert_input {
  data: [kultur_qk_choosen_insert_input!]!
  on_conflict: kultur_qk_choosen_on_conflict
}

# aggregate avg on columns
type kultur_qk_choosen_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "kultur_qk_choosen". All fields are combined with a logical 'AND'.
input kultur_qk_choosen_bool_exp {
  _and: [kultur_qk_choosen_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_qk_choosen_bool_exp
  _or: [kultur_qk_choosen_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  choosen: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  qk_id: uuid_comparison_exp
}

# unique or primary key constraints on table "kultur_qk_choosen"
enum kultur_qk_choosen_constraint {
  # unique or primary key constraint
  kultur_qk_choosen_pkey
}

# input type for incrementing integer column in table "kultur_qk_choosen"
input kultur_qk_choosen_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "kultur_qk_choosen"
input kultur_qk_choosen_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  qk_id: uuid
}

# aggregate max on columns
type kultur_qk_choosen_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  qk_id: uuid
}

# order by max() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  qk_id: order_by
}

# aggregate min on columns
type kultur_qk_choosen_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  qk_id: uuid
}

# order by min() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  qk_id: order_by
}

# response of any mutation on the table "kultur_qk_choosen"
type kultur_qk_choosen_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_qk_choosen!]!
}

# input type for inserting object relation for remote table "kultur_qk_choosen"
input kultur_qk_choosen_obj_rel_insert_input {
  data: kultur_qk_choosen_insert_input!
  on_conflict: kultur_qk_choosen_on_conflict
}

# on conflict condition type for table "kultur_qk_choosen"
input kultur_qk_choosen_on_conflict {
  constraint: kultur_qk_choosen_constraint!
  update_columns: [kultur_qk_choosen_update_column!]!
  where: kultur_qk_choosen_bool_exp
}

# ordering options when selecting data from "kultur_qk_choosen"
input kultur_qk_choosen_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  choosen: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  qk_id: order_by
}

# primary key columns input for table: "kultur_qk_choosen"
input kultur_qk_choosen_pk_columns_input {
  id: ID!
}

# columns and relationships of "kultur_qk_choosen_rev"
type kultur_qk_choosen_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID!

  # An object relationship
  kultur: kultur!
  kultur_id: uuid!
  kultur_qk_choosen_id: uuid
  qk_id: uuid
}

# aggregated selection of "kultur_qk_choosen_rev"
type kultur_qk_choosen_rev_aggregate {
  aggregate: kultur_qk_choosen_rev_aggregate_fields
  nodes: [kultur_qk_choosen_rev!]!
}

# aggregate fields of "kultur_qk_choosen_rev"
type kultur_qk_choosen_rev_aggregate_fields {
  avg: kultur_qk_choosen_rev_avg_fields
  count(columns: [kultur_qk_choosen_rev_select_column!], distinct: Boolean): Int
  max: kultur_qk_choosen_rev_max_fields
  min: kultur_qk_choosen_rev_min_fields
  stddev: kultur_qk_choosen_rev_stddev_fields
  stddev_pop: kultur_qk_choosen_rev_stddev_pop_fields
  stddev_samp: kultur_qk_choosen_rev_stddev_samp_fields
  sum: kultur_qk_choosen_rev_sum_fields
  var_pop: kultur_qk_choosen_rev_var_pop_fields
  var_samp: kultur_qk_choosen_rev_var_samp_fields
  variance: kultur_qk_choosen_rev_variance_fields
}

# order by aggregate values of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_aggregate_order_by {
  avg: kultur_qk_choosen_rev_avg_order_by
  count: order_by
  max: kultur_qk_choosen_rev_max_order_by
  min: kultur_qk_choosen_rev_min_order_by
  stddev: kultur_qk_choosen_rev_stddev_order_by
  stddev_pop: kultur_qk_choosen_rev_stddev_pop_order_by
  stddev_samp: kultur_qk_choosen_rev_stddev_samp_order_by
  sum: kultur_qk_choosen_rev_sum_order_by
  var_pop: kultur_qk_choosen_rev_var_pop_order_by
  var_samp: kultur_qk_choosen_rev_var_samp_order_by
  variance: kultur_qk_choosen_rev_variance_order_by
}

# input type for inserting array relation for remote table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_arr_rel_insert_input {
  data: [kultur_qk_choosen_rev_insert_input!]!
  on_conflict: kultur_qk_choosen_rev_on_conflict
}

# aggregate avg on columns
type kultur_qk_choosen_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "kultur_qk_choosen_rev". All fields are combined with a logical 'AND'.
input kultur_qk_choosen_rev_bool_exp {
  _and: [kultur_qk_choosen_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_qk_choosen_rev_bool_exp
  _or: [kultur_qk_choosen_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  choosen: Boolean_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  kultur_qk_choosen_id: uuid_comparison_exp
  qk_id: uuid_comparison_exp
}

# unique or primary key constraints on table "kultur_qk_choosen_rev"
enum kultur_qk_choosen_rev_constraint {
  # unique or primary key constraint
  kultur_qk_choosen_rev_pkey
}

# input type for incrementing integer column in table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  kultur_qk_choosen_id: uuid
  qk_id: uuid
}

# aggregate max on columns
type kultur_qk_choosen_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  kultur_qk_choosen_id: uuid
  qk_id: uuid
}

# order by max() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  kultur_qk_choosen_id: order_by
  qk_id: order_by
}

# aggregate min on columns
type kultur_qk_choosen_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  kultur_qk_choosen_id: uuid
  qk_id: uuid
}

# order by min() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  kultur_qk_choosen_id: order_by
  qk_id: order_by
}

# response of any mutation on the table "kultur_qk_choosen_rev"
type kultur_qk_choosen_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_qk_choosen_rev!]!
}

# input type for inserting object relation for remote table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_obj_rel_insert_input {
  data: kultur_qk_choosen_rev_insert_input!
  on_conflict: kultur_qk_choosen_rev_on_conflict
}

# on conflict condition type for table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_on_conflict {
  constraint: kultur_qk_choosen_rev_constraint!
  update_columns: [kultur_qk_choosen_rev_update_column!]!
  where: kultur_qk_choosen_rev_bool_exp
}

# ordering options when selecting data from "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  changed: order_by
  changed_by: order_by
  choosen: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  kultur_qk_choosen_id: order_by
  qk_id: order_by
}

# primary key columns input for table: "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_pk_columns_input {
  id: ID!
}

# select columns of table "kultur_qk_choosen_rev"
enum kultur_qk_choosen_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  kultur_id

  # column name
  kultur_qk_choosen_id

  # column name
  qk_id
}

# input type for updating data in table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  kultur_id: uuid
  kultur_qk_choosen_id: uuid
  qk_id: uuid
}

# aggregate stddev on columns
type kultur_qk_choosen_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type kultur_qk_choosen_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type kultur_qk_choosen_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type kultur_qk_choosen_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "kultur_qk_choosen_rev"
enum kultur_qk_choosen_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  kultur_id

  # column name
  kultur_qk_choosen_id

  # column name
  qk_id
}

# aggregate var_pop on columns
type kultur_qk_choosen_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type kultur_qk_choosen_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type kultur_qk_choosen_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "kultur_qk_choosen_rev"
input kultur_qk_choosen_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "kultur_qk_choosen"
enum kultur_qk_choosen_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  kultur_id

  # column name
  qk_id
}

# input type for updating data in table "kultur_qk_choosen"
input kultur_qk_choosen_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  changed: timestamp
  changed_by: String
  choosen: Boolean
  id: ID
  kultur_id: uuid
  qk_id: uuid
}

# aggregate stddev on columns
type kultur_qk_choosen_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type kultur_qk_choosen_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type kultur_qk_choosen_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type kultur_qk_choosen_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "kultur_qk_choosen"
enum kultur_qk_choosen_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  changed

  # column name
  changed_by

  # column name
  choosen

  # column name
  id

  # column name
  kultur_id

  # column name
  qk_id
}

# aggregate var_pop on columns
type kultur_qk_choosen_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type kultur_qk_choosen_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type kultur_qk_choosen_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "kultur_qk_choosen"
input kultur_qk_choosen_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# unique or primary key constraints on table "kultur_qk"
enum kultur_qk_constraint {
  # unique or primary key constraint
  kultur_qk_name_key

  # unique or primary key constraint
  kultur_qk_pkey
}

# input type for incrementing integer column in table "kultur_qk"
input kultur_qk_inc_input {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# input type for inserting data into table "kultur_qk"
input kultur_qk_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate max on columns
type kultur_qk_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by max() on columns of table "kultur_qk"
input kultur_qk_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# aggregate min on columns
type kultur_qk_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# order by min() on columns of table "kultur_qk"
input kultur_qk_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# response of any mutation on the table "kultur_qk"
type kultur_qk_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_qk!]!
}

# input type for inserting object relation for remote table "kultur_qk"
input kultur_qk_obj_rel_insert_input {
  data: kultur_qk_insert_input!
  on_conflict: kultur_qk_on_conflict
}

# on conflict condition type for table "kultur_qk"
input kultur_qk_on_conflict {
  constraint: kultur_qk_constraint!
  update_columns: [kultur_qk_update_column!]!
  where: kultur_qk_bool_exp
}

# ordering options when selecting data from "kultur_qk"
input kultur_qk_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# primary key columns input for table: "kultur_qk"
input kultur_qk_pk_columns_input {
  id: ID!
}

# columns and relationships of "kultur_qk_rev"
type kultur_qk_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_qk_id: uuid
  name: String!
  sort: smallint
  titel: String
}

# aggregated selection of "kultur_qk_rev"
type kultur_qk_rev_aggregate {
  aggregate: kultur_qk_rev_aggregate_fields
  nodes: [kultur_qk_rev!]!
}

# aggregate fields of "kultur_qk_rev"
type kultur_qk_rev_aggregate_fields {
  avg: kultur_qk_rev_avg_fields
  count(columns: [kultur_qk_rev_select_column!], distinct: Boolean): Int
  max: kultur_qk_rev_max_fields
  min: kultur_qk_rev_min_fields
  stddev: kultur_qk_rev_stddev_fields
  stddev_pop: kultur_qk_rev_stddev_pop_fields
  stddev_samp: kultur_qk_rev_stddev_samp_fields
  sum: kultur_qk_rev_sum_fields
  var_pop: kultur_qk_rev_var_pop_fields
  var_samp: kultur_qk_rev_var_samp_fields
  variance: kultur_qk_rev_variance_fields
}

# order by aggregate values of table "kultur_qk_rev"
input kultur_qk_rev_aggregate_order_by {
  avg: kultur_qk_rev_avg_order_by
  count: order_by
  max: kultur_qk_rev_max_order_by
  min: kultur_qk_rev_min_order_by
  stddev: kultur_qk_rev_stddev_order_by
  stddev_pop: kultur_qk_rev_stddev_pop_order_by
  stddev_samp: kultur_qk_rev_stddev_samp_order_by
  sum: kultur_qk_rev_sum_order_by
  var_pop: kultur_qk_rev_var_pop_order_by
  var_samp: kultur_qk_rev_var_samp_order_by
  variance: kultur_qk_rev_variance_order_by
}

# input type for inserting array relation for remote table "kultur_qk_rev"
input kultur_qk_rev_arr_rel_insert_input {
  data: [kultur_qk_rev_insert_input!]!
  on_conflict: kultur_qk_rev_on_conflict
}

# aggregate avg on columns
type kultur_qk_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by avg() on columns of table "kultur_qk_rev"
input kultur_qk_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# Boolean expression to filter rows from the table "kultur_qk_rev". All fields are combined with a logical 'AND'.
input kultur_qk_rev_bool_exp {
  _and: [kultur_qk_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_qk_rev_bool_exp
  _or: [kultur_qk_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  kultur_qk_id: uuid_comparison_exp
  name: String_comparison_exp
  sort: smallint_comparison_exp
  titel: String_comparison_exp
}

# unique or primary key constraints on table "kultur_qk_rev"
enum kultur_qk_rev_constraint {
  # unique or primary key constraint
  kultur_qk_rev_pkey
}

# input type for incrementing integer column in table "kultur_qk_rev"
input kultur_qk_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# input type for inserting data into table "kultur_qk_rev"
input kultur_qk_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_qk_id: uuid
  name: String
  sort: smallint
  titel: String
}

# aggregate max on columns
type kultur_qk_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_qk_id: uuid
  name: String
  sort: smallint
  titel: String
}

# order by max() on columns of table "kultur_qk_rev"
input kultur_qk_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_qk_id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# aggregate min on columns
type kultur_qk_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_qk_id: uuid
  name: String
  sort: smallint
  titel: String
}

# order by min() on columns of table "kultur_qk_rev"
input kultur_qk_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_qk_id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# response of any mutation on the table "kultur_qk_rev"
type kultur_qk_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_qk_rev!]!
}

# input type for inserting object relation for remote table "kultur_qk_rev"
input kultur_qk_rev_obj_rel_insert_input {
  data: kultur_qk_rev_insert_input!
  on_conflict: kultur_qk_rev_on_conflict
}

# on conflict condition type for table "kultur_qk_rev"
input kultur_qk_rev_on_conflict {
  constraint: kultur_qk_rev_constraint!
  update_columns: [kultur_qk_rev_update_column!]!
  where: kultur_qk_rev_bool_exp
}

# ordering options when selecting data from "kultur_qk_rev"
input kultur_qk_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  beschreibung: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_qk_id: order_by
  name: order_by
  sort: order_by
  titel: order_by
}

# primary key columns input for table: "kultur_qk_rev"
input kultur_qk_rev_pk_columns_input {
  name: String!
}

# select columns of table "kultur_qk_rev"
enum kultur_qk_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_qk_id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# input type for updating data in table "kultur_qk_rev"
input kultur_qk_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_qk_id: uuid
  name: String
  sort: smallint
  titel: String
}

# aggregate stddev on columns
type kultur_qk_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev() on columns of table "kultur_qk_rev"
input kultur_qk_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_pop on columns
type kultur_qk_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_pop() on columns of table "kultur_qk_rev"
input kultur_qk_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_samp on columns
type kultur_qk_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_samp() on columns of table "kultur_qk_rev"
input kultur_qk_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate sum on columns
type kultur_qk_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# order by sum() on columns of table "kultur_qk_rev"
input kultur_qk_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# update columns of table "kultur_qk_rev"
enum kultur_qk_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_qk_id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# aggregate var_pop on columns
type kultur_qk_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_pop() on columns of table "kultur_qk_rev"
input kultur_qk_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate var_samp on columns
type kultur_qk_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_samp() on columns of table "kultur_qk_rev"
input kultur_qk_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate variance on columns
type kultur_qk_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by variance() on columns of table "kultur_qk_rev"
input kultur_qk_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# select columns of table "kultur_qk"
enum kultur_qk_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# input type for updating data in table "kultur_qk"
input kultur_qk_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  beschreibung: String
  changed: timestamp
  changed_by: String
  id: ID
  name: String
  sort: smallint
  titel: String
}

# aggregate stddev on columns
type kultur_qk_stddev_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev() on columns of table "kultur_qk"
input kultur_qk_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_pop on columns
type kultur_qk_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_pop() on columns of table "kultur_qk"
input kultur_qk_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_samp on columns
type kultur_qk_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by stddev_samp() on columns of table "kultur_qk"
input kultur_qk_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate sum on columns
type kultur_qk_sum_fields {
  _depth: Int
  _rev_at: numeric
  sort: smallint
}

# order by sum() on columns of table "kultur_qk"
input kultur_qk_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# update columns of table "kultur_qk"
enum kultur_qk_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  beschreibung

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  name

  # column name
  sort

  # column name
  titel
}

# aggregate var_pop on columns
type kultur_qk_var_pop_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_pop() on columns of table "kultur_qk"
input kultur_qk_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate var_samp on columns
type kultur_qk_var_samp_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by var_samp() on columns of table "kultur_qk"
input kultur_qk_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# aggregate variance on columns
type kultur_qk_variance_fields {
  _depth: Float
  _rev_at: Float
  sort: Float
}

# order by variance() on columns of table "kultur_qk"
input kultur_qk_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  sort: order_by
}

# columns and relationships of "kultur_rev"
type kultur_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # An object relationship
  garten: garten
  garten_id: uuid

  # An object relationship
  herkunft: herkunft
  herkunft_id: uuid
  id: ID!
  kultur_id: uuid!

  # An array relationship
  lieferungsByNachKulturId(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungsByNachKulturId_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  lieferungsByVonKulturId(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungsByVonKulturId_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # An array relationship
  sammelLieferungsByNachKulturId(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammelLieferungsByNachKulturId_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  teilkulturs(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): [teilkultur!]!

  # An aggregated array relationship
  teilkulturs_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): teilkultur_aggregate!
  von_anzahl_individuen: Int

  # An array relationship
  zaehlungs(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): [zaehlung!]!

  # An aggregated array relationship
  zaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): zaehlung_aggregate!
  zwischenlager: Boolean
}

# aggregated selection of "kultur_rev"
type kultur_rev_aggregate {
  aggregate: kultur_rev_aggregate_fields
  nodes: [kultur_rev!]!
}

# aggregate fields of "kultur_rev"
type kultur_rev_aggregate_fields {
  avg: kultur_rev_avg_fields
  count(columns: [kultur_rev_select_column!], distinct: Boolean): Int
  max: kultur_rev_max_fields
  min: kultur_rev_min_fields
  stddev: kultur_rev_stddev_fields
  stddev_pop: kultur_rev_stddev_pop_fields
  stddev_samp: kultur_rev_stddev_samp_fields
  sum: kultur_rev_sum_fields
  var_pop: kultur_rev_var_pop_fields
  var_samp: kultur_rev_var_samp_fields
  variance: kultur_rev_variance_fields
}

# order by aggregate values of table "kultur_rev"
input kultur_rev_aggregate_order_by {
  avg: kultur_rev_avg_order_by
  count: order_by
  max: kultur_rev_max_order_by
  min: kultur_rev_min_order_by
  stddev: kultur_rev_stddev_order_by
  stddev_pop: kultur_rev_stddev_pop_order_by
  stddev_samp: kultur_rev_stddev_samp_order_by
  sum: kultur_rev_sum_order_by
  var_pop: kultur_rev_var_pop_order_by
  var_samp: kultur_rev_var_samp_order_by
  variance: kultur_rev_variance_order_by
}

# input type for inserting array relation for remote table "kultur_rev"
input kultur_rev_arr_rel_insert_input {
  data: [kultur_rev_insert_input!]!
  on_conflict: kultur_rev_on_conflict
}

# aggregate avg on columns
type kultur_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "kultur_rev"
input kultur_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "kultur_rev". All fields are combined with a logical 'AND'.
input kultur_rev_bool_exp {
  _and: [kultur_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: kultur_rev_bool_exp
  _or: [kultur_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  aktiv: Boolean_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  erhaltungskultur: Boolean_comparison_exp
  events: event_bool_exp
  garten: garten_bool_exp
  garten_id: uuid_comparison_exp
  herkunft: herkunft_bool_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  kultur_id: uuid_comparison_exp
  lieferungsByNachKulturId: lieferung_bool_exp
  lieferungsByVonKulturId: lieferung_bool_exp
  sammelLieferungsByNachKulturId: sammel_lieferung_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  teilkulturs: teilkultur_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  zaehlungs: zaehlung_bool_exp
  zwischenlager: Boolean_comparison_exp
}

# unique or primary key constraints on table "kultur_rev"
enum kultur_rev_constraint {
  # unique or primary key constraint
  kultur_rev_pkey
}

# input type for incrementing integer column in table "kultur_rev"
input kultur_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "kultur_rev"
input kultur_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean
  events: event_arr_rel_insert_input
  garten: garten_obj_rel_insert_input
  garten_id: uuid
  herkunft: herkunft_obj_rel_insert_input
  herkunft_id: uuid
  id: ID
  kultur_id: uuid
  lieferungsByNachKulturId: lieferung_arr_rel_insert_input
  lieferungsByVonKulturId: lieferung_arr_rel_insert_input
  sammelLieferungsByNachKulturId: sammel_lieferung_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  teilkulturs: teilkultur_arr_rel_insert_input
  von_anzahl_individuen: Int
  zaehlungs: zaehlung_arr_rel_insert_input
  zwischenlager: Boolean
}

# aggregate max on columns
type kultur_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  kultur_id: uuid
  von_anzahl_individuen: Int
}

# order by max() on columns of table "kultur_rev"
input kultur_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  herkunft_id: order_by
  id: order_by
  kultur_id: order_by
  von_anzahl_individuen: order_by
}

# aggregate min on columns
type kultur_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  kultur_id: uuid
  von_anzahl_individuen: Int
}

# order by min() on columns of table "kultur_rev"
input kultur_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  garten_id: order_by
  herkunft_id: order_by
  id: order_by
  kultur_id: order_by
  von_anzahl_individuen: order_by
}

# response of any mutation on the table "kultur_rev"
type kultur_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kultur_rev!]!
}

# input type for inserting object relation for remote table "kultur_rev"
input kultur_rev_obj_rel_insert_input {
  data: kultur_rev_insert_input!
  on_conflict: kultur_rev_on_conflict
}

# on conflict condition type for table "kultur_rev"
input kultur_rev_on_conflict {
  constraint: kultur_rev_constraint!
  update_columns: [kultur_rev_update_column!]!
  where: kultur_rev_bool_exp
}

# ordering options when selecting data from "kultur_rev"
input kultur_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  aktiv: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  erhaltungskultur: order_by
  events_aggregate: event_aggregate_order_by
  garten: garten_order_by
  garten_id: order_by
  herkunft: herkunft_order_by
  herkunft_id: order_by
  id: order_by
  kultur_id: order_by
  lieferungsByNachKulturId_aggregate: lieferung_aggregate_order_by
  lieferungsByVonKulturId_aggregate: lieferung_aggregate_order_by
  sammelLieferungsByNachKulturId_aggregate: sammel_lieferung_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  teilkulturs_aggregate: teilkultur_aggregate_order_by
  von_anzahl_individuen: order_by
  zaehlungs_aggregate: zaehlung_aggregate_order_by
  zwischenlager: order_by
}

# primary key columns input for table: "kultur_rev"
input kultur_rev_pk_columns_input {
  id: ID!
}

# select columns of table "kultur_rev"
enum kultur_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  erhaltungskultur

  # column name
  garten_id

  # column name
  herkunft_id

  # column name
  id

  # column name
  kultur_id

  # column name
  von_anzahl_individuen

  # column name
  zwischenlager
}

# input type for updating data in table "kultur_rev"
input kultur_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  kultur_id: uuid
  von_anzahl_individuen: Int
  zwischenlager: Boolean
}

# aggregate stddev on columns
type kultur_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "kultur_rev"
input kultur_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type kultur_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "kultur_rev"
input kultur_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type kultur_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "kultur_rev"
input kultur_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type kultur_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "kultur_rev"
input kultur_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "kultur_rev"
enum kultur_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  erhaltungskultur

  # column name
  garten_id

  # column name
  herkunft_id

  # column name
  id

  # column name
  kultur_id

  # column name
  von_anzahl_individuen

  # column name
  zwischenlager
}

# aggregate var_pop on columns
type kultur_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "kultur_rev"
input kultur_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type kultur_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "kultur_rev"
input kultur_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type kultur_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "kultur_rev"
input kultur_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# select columns of table "kultur"
enum kultur_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  erhaltungskultur

  # column name
  garten_id

  # column name
  herkunft_id

  # column name
  id

  # column name
  von_anzahl_individuen

  # column name
  zwischenlager
}

# input type for updating data in table "kultur"
input kultur_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  aktiv: Boolean
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  erhaltungskultur: Boolean
  garten_id: uuid
  herkunft_id: uuid
  id: ID
  von_anzahl_individuen: Int
  zwischenlager: Boolean
}

# aggregate stddev on columns
type kultur_stddev_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "kultur"
input kultur_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type kultur_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "kultur"
input kultur_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type kultur_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "kultur"
input kultur_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type kultur_sum_fields {
  _depth: Int
  _rev_at: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "kultur"
input kultur_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "kultur"
enum kultur_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  aktiv

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  erhaltungskultur

  # column name
  garten_id

  # column name
  herkunft_id

  # column name
  id

  # column name
  von_anzahl_individuen

  # column name
  zwischenlager
}

# aggregate var_pop on columns
type kultur_var_pop_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "kultur"
input kultur_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type kultur_var_samp_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "kultur"
input kultur_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type kultur_variance_fields {
  _depth: Float
  _rev_at: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "kultur"
input kultur_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  von_anzahl_individuen: order_by
}

# columns and relationships of "lieferung"
type lieferung {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID!

  # An object relationship
  kulturByNachKulturId: kultur

  # An object relationship
  kulturByVonKulturId: kultur

  # An array relationship
  lieferung_files(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): [lieferung_file!]!

  # An aggregated array relationship
  lieferung_files_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): lieferung_file_aggregate!
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid

  # An object relationship
  sammel_lieferung: sammel_lieferung
  sammel_lieferung_id: uuid

  # An object relationship
  sammlung: sammlung
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregated selection of "lieferung"
type lieferung_aggregate {
  aggregate: lieferung_aggregate_fields
  nodes: [lieferung!]!
}

# aggregate fields of "lieferung"
type lieferung_aggregate_fields {
  avg: lieferung_avg_fields
  count(columns: [lieferung_select_column!], distinct: Boolean): Int
  max: lieferung_max_fields
  min: lieferung_min_fields
  stddev: lieferung_stddev_fields
  stddev_pop: lieferung_stddev_pop_fields
  stddev_samp: lieferung_stddev_samp_fields
  sum: lieferung_sum_fields
  var_pop: lieferung_var_pop_fields
  var_samp: lieferung_var_samp_fields
  variance: lieferung_variance_fields
}

# order by aggregate values of table "lieferung"
input lieferung_aggregate_order_by {
  avg: lieferung_avg_order_by
  count: order_by
  max: lieferung_max_order_by
  min: lieferung_min_order_by
  stddev: lieferung_stddev_order_by
  stddev_pop: lieferung_stddev_pop_order_by
  stddev_samp: lieferung_stddev_samp_order_by
  sum: lieferung_sum_order_by
  var_pop: lieferung_var_pop_order_by
  var_samp: lieferung_var_samp_order_by
  variance: lieferung_variance_order_by
}

# input type for inserting array relation for remote table "lieferung"
input lieferung_arr_rel_insert_input {
  data: [lieferung_insert_input!]!
  on_conflict: lieferung_on_conflict
}

# aggregate avg on columns
type lieferung_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "lieferung"
input lieferung_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "lieferung". All fields are combined with a logical 'AND'.
input lieferung_bool_exp {
  _and: [lieferung_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: lieferung_bool_exp
  _or: [lieferung_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  id: uuid_comparison_exp
  kulturByNachKulturId: kultur_bool_exp
  kulturByVonKulturId: kultur_bool_exp
  lieferung_files: lieferung_file_bool_exp
  nach_ausgepflanzt: Boolean_comparison_exp
  nach_kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammel_lieferung: sammel_lieferung_bool_exp
  sammel_lieferung_id: uuid_comparison_exp
  sammlung: sammlung_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  von_kultur_id: uuid_comparison_exp
  von_sammlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "lieferung"
enum lieferung_constraint {
  # unique or primary key constraint
  lieferung_pkey
}

# columns and relationships of "lieferung_file"
type lieferung_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID!

  # An object relationship
  lieferung: lieferung
  lieferung_id: uuid
  name: String
}

# aggregated selection of "lieferung_file"
type lieferung_file_aggregate {
  aggregate: lieferung_file_aggregate_fields
  nodes: [lieferung_file!]!
}

# aggregate fields of "lieferung_file"
type lieferung_file_aggregate_fields {
  avg: lieferung_file_avg_fields
  count(columns: [lieferung_file_select_column!], distinct: Boolean): Int
  max: lieferung_file_max_fields
  min: lieferung_file_min_fields
  stddev: lieferung_file_stddev_fields
  stddev_pop: lieferung_file_stddev_pop_fields
  stddev_samp: lieferung_file_stddev_samp_fields
  sum: lieferung_file_sum_fields
  var_pop: lieferung_file_var_pop_fields
  var_samp: lieferung_file_var_samp_fields
  variance: lieferung_file_variance_fields
}

# order by aggregate values of table "lieferung_file"
input lieferung_file_aggregate_order_by {
  avg: lieferung_file_avg_order_by
  count: order_by
  max: lieferung_file_max_order_by
  min: lieferung_file_min_order_by
  stddev: lieferung_file_stddev_order_by
  stddev_pop: lieferung_file_stddev_pop_order_by
  stddev_samp: lieferung_file_stddev_samp_order_by
  sum: lieferung_file_sum_order_by
  var_pop: lieferung_file_var_pop_order_by
  var_samp: lieferung_file_var_samp_order_by
  variance: lieferung_file_variance_order_by
}

# input type for inserting array relation for remote table "lieferung_file"
input lieferung_file_arr_rel_insert_input {
  data: [lieferung_file_insert_input!]!
  on_conflict: lieferung_file_on_conflict
}

# aggregate avg on columns
type lieferung_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "lieferung_file"
input lieferung_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "lieferung_file". All fields are combined with a logical 'AND'.
input lieferung_file_bool_exp {
  _and: [lieferung_file_bool_exp]
  _not: lieferung_file_bool_exp
  _or: [lieferung_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  id: uuid_comparison_exp
  lieferung: lieferung_bool_exp
  lieferung_id: uuid_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "lieferung_file"
enum lieferung_file_constraint {
  # unique or primary key constraint
  lieferung_file_pkey
}

# input type for incrementing integer column in table "lieferung_file"
input lieferung_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "lieferung_file"
input lieferung_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  lieferung: lieferung_obj_rel_insert_input
  lieferung_id: uuid
  name: String
}

# aggregate max on columns
type lieferung_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  lieferung_id: uuid
  name: String
}

# order by max() on columns of table "lieferung_file"
input lieferung_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  lieferung_id: order_by
  name: order_by
}

# aggregate min on columns
type lieferung_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  lieferung_id: uuid
  name: String
}

# order by min() on columns of table "lieferung_file"
input lieferung_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  lieferung_id: order_by
  name: order_by
}

# response of any mutation on the table "lieferung_file"
type lieferung_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [lieferung_file!]!
}

# input type for inserting object relation for remote table "lieferung_file"
input lieferung_file_obj_rel_insert_input {
  data: lieferung_file_insert_input!
  on_conflict: lieferung_file_on_conflict
}

# on conflict condition type for table "lieferung_file"
input lieferung_file_on_conflict {
  constraint: lieferung_file_constraint!
  update_columns: [lieferung_file_update_column!]!
  where: lieferung_file_bool_exp
}

# ordering options when selecting data from "lieferung_file"
input lieferung_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  lieferung: lieferung_order_by
  lieferung_id: order_by
  name: order_by
}

# primary key columns input for table: "lieferung_file"
input lieferung_file_pk_columns_input {
  id: ID!
}

# select columns of table "lieferung_file"
enum lieferung_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  lieferung_id

  # column name
  name
}

# input type for updating data in table "lieferung_file"
input lieferung_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  lieferung_id: uuid
  name: String
}

# aggregate stddev on columns
type lieferung_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "lieferung_file"
input lieferung_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type lieferung_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "lieferung_file"
input lieferung_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type lieferung_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "lieferung_file"
input lieferung_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type lieferung_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "lieferung_file"
input lieferung_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "lieferung_file"
enum lieferung_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  lieferung_id

  # column name
  name
}

# aggregate var_pop on columns
type lieferung_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "lieferung_file"
input lieferung_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type lieferung_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "lieferung_file"
input lieferung_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type lieferung_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "lieferung_file"
input lieferung_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "lieferung"
input lieferung_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "lieferung"
input lieferung_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  kulturByNachKulturId: kultur_obj_rel_insert_input
  kulturByVonKulturId: kultur_obj_rel_insert_input
  lieferung_files: lieferung_file_arr_rel_insert_input
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  sammel_lieferung: sammel_lieferung_obj_rel_insert_input
  sammel_lieferung_id: uuid
  sammlung: sammlung_obj_rel_insert_input
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate max on columns
type lieferung_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by max() on columns of table "lieferung"
input lieferung_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# aggregate min on columns
type lieferung_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by min() on columns of table "lieferung"
input lieferung_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# response of any mutation on the table "lieferung"
type lieferung_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [lieferung!]!
}

# input type for inserting object relation for remote table "lieferung"
input lieferung_obj_rel_insert_input {
  data: lieferung_insert_input!
  on_conflict: lieferung_on_conflict
}

# on conflict condition type for table "lieferung"
input lieferung_on_conflict {
  constraint: lieferung_constraint!
  update_columns: [lieferung_update_column!]!
  where: lieferung_bool_exp
}

# ordering options when selecting data from "lieferung"
input lieferung_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geplant: order_by
  gramm_samen: order_by
  id: order_by
  kulturByNachKulturId: kultur_order_by
  kulturByVonKulturId: kultur_order_by
  lieferung_files_aggregate: lieferung_file_aggregate_order_by
  nach_ausgepflanzt: order_by
  nach_kultur_id: order_by
  person: person_order_by
  person_id: order_by
  sammel_lieferung: sammel_lieferung_order_by
  sammel_lieferung_id: order_by
  sammlung: sammlung_order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# primary key columns input for table: "lieferung"
input lieferung_pk_columns_input {
  id: ID!
}

# columns and relationships of "lieferung_rev"
type lieferung_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID!

  # An object relationship
  kulturByNachKulturId: kultur

  # An object relationship
  kulturByVonKulturId: kultur
  lieferung_id: uuid!
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid

  # An object relationship
  sammel_lieferung: sammel_lieferung
  sammel_lieferung_id: uuid

  # An object relationship
  sammlung: sammlung
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregated selection of "lieferung_rev"
type lieferung_rev_aggregate {
  aggregate: lieferung_rev_aggregate_fields
  nodes: [lieferung_rev!]!
}

# aggregate fields of "lieferung_rev"
type lieferung_rev_aggregate_fields {
  avg: lieferung_rev_avg_fields
  count(columns: [lieferung_rev_select_column!], distinct: Boolean): Int
  max: lieferung_rev_max_fields
  min: lieferung_rev_min_fields
  stddev: lieferung_rev_stddev_fields
  stddev_pop: lieferung_rev_stddev_pop_fields
  stddev_samp: lieferung_rev_stddev_samp_fields
  sum: lieferung_rev_sum_fields
  var_pop: lieferung_rev_var_pop_fields
  var_samp: lieferung_rev_var_samp_fields
  variance: lieferung_rev_variance_fields
}

# order by aggregate values of table "lieferung_rev"
input lieferung_rev_aggregate_order_by {
  avg: lieferung_rev_avg_order_by
  count: order_by
  max: lieferung_rev_max_order_by
  min: lieferung_rev_min_order_by
  stddev: lieferung_rev_stddev_order_by
  stddev_pop: lieferung_rev_stddev_pop_order_by
  stddev_samp: lieferung_rev_stddev_samp_order_by
  sum: lieferung_rev_sum_order_by
  var_pop: lieferung_rev_var_pop_order_by
  var_samp: lieferung_rev_var_samp_order_by
  variance: lieferung_rev_variance_order_by
}

# input type for inserting array relation for remote table "lieferung_rev"
input lieferung_rev_arr_rel_insert_input {
  data: [lieferung_rev_insert_input!]!
  on_conflict: lieferung_rev_on_conflict
}

# aggregate avg on columns
type lieferung_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "lieferung_rev"
input lieferung_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "lieferung_rev". All fields are combined with a logical 'AND'.
input lieferung_rev_bool_exp {
  _and: [lieferung_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: lieferung_rev_bool_exp
  _or: [lieferung_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  id: uuid_comparison_exp
  kulturByNachKulturId: kultur_bool_exp
  kulturByVonKulturId: kultur_bool_exp
  lieferung_id: uuid_comparison_exp
  nach_ausgepflanzt: Boolean_comparison_exp
  nach_kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammel_lieferung: sammel_lieferung_bool_exp
  sammel_lieferung_id: uuid_comparison_exp
  sammlung: sammlung_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  von_kultur_id: uuid_comparison_exp
  von_sammlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "lieferung_rev"
enum lieferung_rev_constraint {
  # unique or primary key constraint
  lieferung_rev_pkey
}

# input type for incrementing integer column in table "lieferung_rev"
input lieferung_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "lieferung_rev"
input lieferung_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  kulturByNachKulturId: kultur_obj_rel_insert_input
  kulturByVonKulturId: kultur_obj_rel_insert_input
  lieferung_id: uuid
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  sammel_lieferung: sammel_lieferung_obj_rel_insert_input
  sammel_lieferung_id: uuid
  sammlung: sammlung_obj_rel_insert_input
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate max on columns
type lieferung_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  lieferung_id: uuid
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by max() on columns of table "lieferung_rev"
input lieferung_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  lieferung_id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# aggregate min on columns
type lieferung_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  lieferung_id: uuid
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by min() on columns of table "lieferung_rev"
input lieferung_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  lieferung_id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# response of any mutation on the table "lieferung_rev"
type lieferung_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [lieferung_rev!]!
}

# input type for inserting object relation for remote table "lieferung_rev"
input lieferung_rev_obj_rel_insert_input {
  data: lieferung_rev_insert_input!
  on_conflict: lieferung_rev_on_conflict
}

# on conflict condition type for table "lieferung_rev"
input lieferung_rev_on_conflict {
  constraint: lieferung_rev_constraint!
  update_columns: [lieferung_rev_update_column!]!
  where: lieferung_rev_bool_exp
}

# ordering options when selecting data from "lieferung_rev"
input lieferung_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geplant: order_by
  gramm_samen: order_by
  id: order_by
  kulturByNachKulturId: kultur_order_by
  kulturByVonKulturId: kultur_order_by
  lieferung_id: order_by
  nach_ausgepflanzt: order_by
  nach_kultur_id: order_by
  person: person_order_by
  person_id: order_by
  sammel_lieferung: sammel_lieferung_order_by
  sammel_lieferung_id: order_by
  sammlung: sammlung_order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# primary key columns input for table: "lieferung_rev"
input lieferung_rev_pk_columns_input {
  id: ID!
}

# select columns of table "lieferung_rev"
enum lieferung_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  lieferung_id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# input type for updating data in table "lieferung_rev"
input lieferung_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  lieferung_id: uuid
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate stddev on columns
type lieferung_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "lieferung_rev"
input lieferung_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type lieferung_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "lieferung_rev"
input lieferung_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type lieferung_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "lieferung_rev"
input lieferung_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type lieferung_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "lieferung_rev"
input lieferung_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "lieferung_rev"
enum lieferung_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  lieferung_id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# aggregate var_pop on columns
type lieferung_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "lieferung_rev"
input lieferung_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type lieferung_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "lieferung_rev"
input lieferung_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type lieferung_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "lieferung_rev"
input lieferung_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# select columns of table "lieferung"
enum lieferung_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# input type for updating data in table "lieferung"
input lieferung_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate stddev on columns
type lieferung_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "lieferung"
input lieferung_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type lieferung_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "lieferung"
input lieferung_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type lieferung_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "lieferung"
input lieferung_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type lieferung_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "lieferung"
input lieferung_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "lieferung"
enum lieferung_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# aggregate var_pop on columns
type lieferung_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "lieferung"
input lieferung_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type lieferung_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "lieferung"
input lieferung_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type lieferung_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "lieferung"
input lieferung_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "ae_art"
  delete_ae_art(
    # filter the rows which have to be deleted
    where: ae_art_bool_exp!
  ): ae_art_mutation_response

  # delete single row from the table: "ae_art"
  delete_ae_art_by_pk(id: ID!): ae_art

  # delete data from the table: "art"
  delete_art(
    # filter the rows which have to be deleted
    where: art_bool_exp!
  ): art_mutation_response

  # delete single row from the table: "art"
  delete_art_by_pk(id: ID!): art

  # delete data from the table: "art_file"
  delete_art_file(
    # filter the rows which have to be deleted
    where: art_file_bool_exp!
  ): art_file_mutation_response

  # delete single row from the table: "art_file"
  delete_art_file_by_pk(id: ID!): art_file

  # delete data from the table: "art_qk"
  delete_art_qk(
    # filter the rows which have to be deleted
    where: art_qk_bool_exp!
  ): art_qk_mutation_response

  # delete single row from the table: "art_qk"
  delete_art_qk_by_pk(id: ID!): art_qk

  # delete data from the table: "art_qk_choosen"
  delete_art_qk_choosen(
    # filter the rows which have to be deleted
    where: art_qk_choosen_bool_exp!
  ): art_qk_choosen_mutation_response

  # delete single row from the table: "art_qk_choosen"
  delete_art_qk_choosen_by_pk(id: ID!): art_qk_choosen

  # delete data from the table: "art_qk_choosen_rev"
  delete_art_qk_choosen_rev(
    # filter the rows which have to be deleted
    where: art_qk_choosen_rev_bool_exp!
  ): art_qk_choosen_rev_mutation_response

  # delete single row from the table: "art_qk_choosen_rev"
  delete_art_qk_choosen_rev_by_pk(id: ID!): art_qk_choosen_rev

  # delete data from the table: "art_qk_rev"
  delete_art_qk_rev(
    # filter the rows which have to be deleted
    where: art_qk_rev_bool_exp!
  ): art_qk_rev_mutation_response

  # delete single row from the table: "art_qk_rev"
  delete_art_qk_rev_by_pk(id: ID!): art_qk_rev

  # delete data from the table: "art_rev"
  delete_art_rev(
    # filter the rows which have to be deleted
    where: art_rev_bool_exp!
  ): art_rev_mutation_response

  # delete single row from the table: "art_rev"
  delete_art_rev_by_pk(id: ID!): art_rev

  # delete data from the table: "av"
  delete_av(
    # filter the rows which have to be deleted
    where: av_bool_exp!
  ): av_mutation_response

  # delete single row from the table: "av"
  delete_av_by_pk(id: ID!): av

  # delete data from the table: "av_rev"
  delete_av_rev(
    # filter the rows which have to be deleted
    where: av_rev_bool_exp!
  ): av_rev_mutation_response

  # delete single row from the table: "av_rev"
  delete_av_rev_by_pk(id: ID!): av_rev

  # delete data from the table: "event"
  delete_event(
    # filter the rows which have to be deleted
    where: event_bool_exp!
  ): event_mutation_response

  # delete single row from the table: "event"
  delete_event_by_pk(id: ID!): event

  # delete data from the table: "event_rev"
  delete_event_rev(
    # filter the rows which have to be deleted
    where: event_rev_bool_exp!
  ): event_rev_mutation_response

  # delete single row from the table: "event_rev"
  delete_event_rev_by_pk(id: ID!): event_rev

  # delete data from the table: "garten"
  delete_garten(
    # filter the rows which have to be deleted
    where: garten_bool_exp!
  ): garten_mutation_response

  # delete single row from the table: "garten"
  delete_garten_by_pk(id: ID!): garten

  # delete data from the table: "garten_file"
  delete_garten_file(
    # filter the rows which have to be deleted
    where: garten_file_bool_exp!
  ): garten_file_mutation_response

  # delete single row from the table: "garten_file"
  delete_garten_file_by_pk(id: ID!): garten_file

  # delete data from the table: "garten_rev"
  delete_garten_rev(
    # filter the rows which have to be deleted
    where: garten_rev_bool_exp!
  ): garten_rev_mutation_response

  # delete single row from the table: "garten_rev"
  delete_garten_rev_by_pk(id: ID!): garten_rev

  # delete data from the table: "gv"
  delete_gv(
    # filter the rows which have to be deleted
    where: gv_bool_exp!
  ): gv_mutation_response

  # delete single row from the table: "gv"
  delete_gv_by_pk(id: ID!): gv

  # delete data from the table: "gv_rev"
  delete_gv_rev(
    # filter the rows which have to be deleted
    where: gv_rev_bool_exp!
  ): gv_rev_mutation_response

  # delete single row from the table: "gv_rev"
  delete_gv_rev_by_pk(id: ID!): gv_rev

  # delete data from the table: "herkunft"
  delete_herkunft(
    # filter the rows which have to be deleted
    where: herkunft_bool_exp!
  ): herkunft_mutation_response

  # delete single row from the table: "herkunft"
  delete_herkunft_by_pk(id: ID!): herkunft

  # delete data from the table: "herkunft_file"
  delete_herkunft_file(
    # filter the rows which have to be deleted
    where: herkunft_file_bool_exp!
  ): herkunft_file_mutation_response

  # delete single row from the table: "herkunft_file"
  delete_herkunft_file_by_pk(id: ID!): herkunft_file

  # delete data from the table: "herkunft_rev"
  delete_herkunft_rev(
    # filter the rows which have to be deleted
    where: herkunft_rev_bool_exp!
  ): herkunft_rev_mutation_response

  # delete single row from the table: "herkunft_rev"
  delete_herkunft_rev_by_pk(id: ID!): herkunft_rev

  # delete data from the table: "kultur"
  delete_kultur(
    # filter the rows which have to be deleted
    where: kultur_bool_exp!
  ): kultur_mutation_response

  # delete single row from the table: "kultur"
  delete_kultur_by_pk(id: ID!): kultur

  # delete data from the table: "kultur_file"
  delete_kultur_file(
    # filter the rows which have to be deleted
    where: kultur_file_bool_exp!
  ): kultur_file_mutation_response

  # delete single row from the table: "kultur_file"
  delete_kultur_file_by_pk(id: ID!): kultur_file

  # delete data from the table: "kultur_option"
  delete_kultur_option(
    # filter the rows which have to be deleted
    where: kultur_option_bool_exp!
  ): kultur_option_mutation_response

  # delete data from the table: "kultur_option_rev"
  delete_kultur_option_rev(
    # filter the rows which have to be deleted
    where: kultur_option_rev_bool_exp!
  ): kultur_option_rev_mutation_response

  # delete single row from the table: "kultur_option_rev"
  delete_kultur_option_rev_by_pk(id: ID!): kultur_option_rev

  # delete data from the table: "kultur_qk"
  delete_kultur_qk(
    # filter the rows which have to be deleted
    where: kultur_qk_bool_exp!
  ): kultur_qk_mutation_response

  # delete single row from the table: "kultur_qk"
  delete_kultur_qk_by_pk(id: ID!): kultur_qk

  # delete data from the table: "kultur_qk_choosen"
  delete_kultur_qk_choosen(
    # filter the rows which have to be deleted
    where: kultur_qk_choosen_bool_exp!
  ): kultur_qk_choosen_mutation_response

  # delete single row from the table: "kultur_qk_choosen"
  delete_kultur_qk_choosen_by_pk(id: ID!): kultur_qk_choosen

  # delete data from the table: "kultur_qk_choosen_rev"
  delete_kultur_qk_choosen_rev(
    # filter the rows which have to be deleted
    where: kultur_qk_choosen_rev_bool_exp!
  ): kultur_qk_choosen_rev_mutation_response

  # delete single row from the table: "kultur_qk_choosen_rev"
  delete_kultur_qk_choosen_rev_by_pk(id: ID!): kultur_qk_choosen_rev

  # delete data from the table: "kultur_qk_rev"
  delete_kultur_qk_rev(
    # filter the rows which have to be deleted
    where: kultur_qk_rev_bool_exp!
  ): kultur_qk_rev_mutation_response

  # delete single row from the table: "kultur_qk_rev"
  delete_kultur_qk_rev_by_pk(name: String!): kultur_qk_rev

  # delete data from the table: "kultur_rev"
  delete_kultur_rev(
    # filter the rows which have to be deleted
    where: kultur_rev_bool_exp!
  ): kultur_rev_mutation_response

  # delete single row from the table: "kultur_rev"
  delete_kultur_rev_by_pk(id: ID!): kultur_rev

  # delete data from the table: "lieferung"
  delete_lieferung(
    # filter the rows which have to be deleted
    where: lieferung_bool_exp!
  ): lieferung_mutation_response

  # delete single row from the table: "lieferung"
  delete_lieferung_by_pk(id: ID!): lieferung

  # delete data from the table: "lieferung_file"
  delete_lieferung_file(
    # filter the rows which have to be deleted
    where: lieferung_file_bool_exp!
  ): lieferung_file_mutation_response

  # delete single row from the table: "lieferung_file"
  delete_lieferung_file_by_pk(id: ID!): lieferung_file

  # delete data from the table: "lieferung_rev"
  delete_lieferung_rev(
    # filter the rows which have to be deleted
    where: lieferung_rev_bool_exp!
  ): lieferung_rev_mutation_response

  # delete single row from the table: "lieferung_rev"
  delete_lieferung_rev_by_pk(id: ID!): lieferung_rev

  # delete data from the table: "person"
  delete_person(
    # filter the rows which have to be deleted
    where: person_bool_exp!
  ): person_mutation_response

  # delete single row from the table: "person"
  delete_person_by_pk(id: ID!): person

  # delete data from the table: "person_file"
  delete_person_file(
    # filter the rows which have to be deleted
    where: person_file_bool_exp!
  ): person_file_mutation_response

  # delete single row from the table: "person_file"
  delete_person_file_by_pk(id: ID!): person_file

  # delete data from the table: "person_option"
  delete_person_option(
    # filter the rows which have to be deleted
    where: person_option_bool_exp!
  ): person_option_mutation_response

  # delete data from the table: "person_option_rev"
  delete_person_option_rev(
    # filter the rows which have to be deleted
    where: person_option_rev_bool_exp!
  ): person_option_rev_mutation_response

  # delete single row from the table: "person_option_rev"
  delete_person_option_rev_by_pk(id: ID!): person_option_rev

  # delete data from the table: "person_rev"
  delete_person_rev(
    # filter the rows which have to be deleted
    where: person_rev_bool_exp!
  ): person_rev_mutation_response

  # delete single row from the table: "person_rev"
  delete_person_rev_by_pk(id: ID!): person_rev

  # delete data from the table: "sammel_lieferung"
  delete_sammel_lieferung(
    # filter the rows which have to be deleted
    where: sammel_lieferung_bool_exp!
  ): sammel_lieferung_mutation_response

  # delete single row from the table: "sammel_lieferung"
  delete_sammel_lieferung_by_pk(id: ID!): sammel_lieferung

  # delete data from the table: "sammel_lieferung_rev"
  delete_sammel_lieferung_rev(
    # filter the rows which have to be deleted
    where: sammel_lieferung_rev_bool_exp!
  ): sammel_lieferung_rev_mutation_response

  # delete single row from the table: "sammel_lieferung_rev"
  delete_sammel_lieferung_rev_by_pk(id: ID!): sammel_lieferung_rev

  # delete data from the table: "sammlung"
  delete_sammlung(
    # filter the rows which have to be deleted
    where: sammlung_bool_exp!
  ): sammlung_mutation_response

  # delete single row from the table: "sammlung"
  delete_sammlung_by_pk(id: ID!): sammlung

  # delete data from the table: "sammlung_file"
  delete_sammlung_file(
    # filter the rows which have to be deleted
    where: sammlung_file_bool_exp!
  ): sammlung_file_mutation_response

  # delete single row from the table: "sammlung_file"
  delete_sammlung_file_by_pk(id: ID!): sammlung_file

  # delete data from the table: "sammlung_rev"
  delete_sammlung_rev(
    # filter the rows which have to be deleted
    where: sammlung_rev_bool_exp!
  ): sammlung_rev_mutation_response

  # delete single row from the table: "sammlung_rev"
  delete_sammlung_rev_by_pk(id: ID!): sammlung_rev

  # delete data from the table: "spatial_ref_sys"
  delete_spatial_ref_sys(
    # filter the rows which have to be deleted
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  # delete single row from the table: "spatial_ref_sys"
  delete_spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  # delete data from the table: "teilkultur"
  delete_teilkultur(
    # filter the rows which have to be deleted
    where: teilkultur_bool_exp!
  ): teilkultur_mutation_response

  # delete single row from the table: "teilkultur"
  delete_teilkultur_by_pk(id: ID!): teilkultur

  # delete data from the table: "teilkultur_rev"
  delete_teilkultur_rev(
    # filter the rows which have to be deleted
    where: teilkultur_rev_bool_exp!
  ): teilkultur_rev_mutation_response

  # delete single row from the table: "teilkultur_rev"
  delete_teilkultur_rev_by_pk(id: ID!): teilkultur_rev

  # delete data from the table: "teilzaehlung"
  delete_teilzaehlung(
    # filter the rows which have to be deleted
    where: teilzaehlung_bool_exp!
  ): teilzaehlung_mutation_response

  # delete single row from the table: "teilzaehlung"
  delete_teilzaehlung_by_pk(id: ID!): teilzaehlung

  # delete data from the table: "teilzaehlung_rev"
  delete_teilzaehlung_rev(
    # filter the rows which have to be deleted
    where: teilzaehlung_rev_bool_exp!
  ): teilzaehlung_rev_mutation_response

  # delete single row from the table: "teilzaehlung_rev"
  delete_teilzaehlung_rev_by_pk(id: ID!): teilzaehlung_rev

  # delete data from the table: "user_role"
  delete_user_role(
    # filter the rows which have to be deleted
    where: user_role_bool_exp!
  ): user_role_mutation_response

  # delete single row from the table: "user_role"
  delete_user_role_by_pk(id: ID!): user_role

  # delete data from the table: "zaehlung"
  delete_zaehlung(
    # filter the rows which have to be deleted
    where: zaehlung_bool_exp!
  ): zaehlung_mutation_response

  # delete single row from the table: "zaehlung"
  delete_zaehlung_by_pk(id: ID!): zaehlung

  # delete data from the table: "zaehlung_rev"
  delete_zaehlung_rev(
    # filter the rows which have to be deleted
    where: zaehlung_rev_bool_exp!
  ): zaehlung_rev_mutation_response

  # delete single row from the table: "zaehlung_rev"
  delete_zaehlung_rev_by_pk(id: ID!): zaehlung_rev

  # insert data into the table: "ae_art"
  insert_ae_art(
    # the rows to be inserted
    objects: [ae_art_insert_input!]!

    # on conflict condition
    on_conflict: ae_art_on_conflict
  ): ae_art_mutation_response

  # insert a single row into the table: "ae_art"
  insert_ae_art_one(
    # the row to be inserted
    object: ae_art_insert_input!

    # on conflict condition
    on_conflict: ae_art_on_conflict
  ): ae_art

  # insert data into the table: "art"
  insert_art(
    # the rows to be inserted
    objects: [art_insert_input!]!

    # on conflict condition
    on_conflict: art_on_conflict
  ): art_mutation_response

  # insert data into the table: "art_file"
  insert_art_file(
    # the rows to be inserted
    objects: [art_file_insert_input!]!

    # on conflict condition
    on_conflict: art_file_on_conflict
  ): art_file_mutation_response

  # insert a single row into the table: "art_file"
  insert_art_file_one(
    # the row to be inserted
    object: art_file_insert_input!

    # on conflict condition
    on_conflict: art_file_on_conflict
  ): art_file

  # insert a single row into the table: "art"
  insert_art_one(
    # the row to be inserted
    object: art_insert_input!

    # on conflict condition
    on_conflict: art_on_conflict
  ): art

  # insert data into the table: "art_qk"
  insert_art_qk(
    # the rows to be inserted
    objects: [art_qk_insert_input!]!

    # on conflict condition
    on_conflict: art_qk_on_conflict
  ): art_qk_mutation_response

  # insert data into the table: "art_qk_choosen"
  insert_art_qk_choosen(
    # the rows to be inserted
    objects: [art_qk_choosen_insert_input!]!

    # on conflict condition
    on_conflict: art_qk_choosen_on_conflict
  ): art_qk_choosen_mutation_response

  # insert a single row into the table: "art_qk_choosen"
  insert_art_qk_choosen_one(
    # the row to be inserted
    object: art_qk_choosen_insert_input!

    # on conflict condition
    on_conflict: art_qk_choosen_on_conflict
  ): art_qk_choosen

  # insert data into the table: "art_qk_choosen_rev"
  insert_art_qk_choosen_rev(
    # the rows to be inserted
    objects: [art_qk_choosen_rev_insert_input!]!

    # on conflict condition
    on_conflict: art_qk_choosen_rev_on_conflict
  ): art_qk_choosen_rev_mutation_response

  # insert a single row into the table: "art_qk_choosen_rev"
  insert_art_qk_choosen_rev_one(
    # the row to be inserted
    object: art_qk_choosen_rev_insert_input!

    # on conflict condition
    on_conflict: art_qk_choosen_rev_on_conflict
  ): art_qk_choosen_rev

  # insert a single row into the table: "art_qk"
  insert_art_qk_one(
    # the row to be inserted
    object: art_qk_insert_input!

    # on conflict condition
    on_conflict: art_qk_on_conflict
  ): art_qk

  # insert data into the table: "art_qk_rev"
  insert_art_qk_rev(
    # the rows to be inserted
    objects: [art_qk_rev_insert_input!]!

    # on conflict condition
    on_conflict: art_qk_rev_on_conflict
  ): art_qk_rev_mutation_response

  # insert a single row into the table: "art_qk_rev"
  insert_art_qk_rev_one(
    # the row to be inserted
    object: art_qk_rev_insert_input!

    # on conflict condition
    on_conflict: art_qk_rev_on_conflict
  ): art_qk_rev

  # insert data into the table: "art_rev"
  insert_art_rev(
    # the rows to be inserted
    objects: [art_rev_insert_input!]!

    # on conflict condition
    on_conflict: art_rev_on_conflict
  ): art_rev_mutation_response

  # insert a single row into the table: "art_rev"
  insert_art_rev_one(
    # the row to be inserted
    object: art_rev_insert_input!

    # on conflict condition
    on_conflict: art_rev_on_conflict
  ): art_rev

  # insert data into the table: "av"
  insert_av(
    # the rows to be inserted
    objects: [av_insert_input!]!

    # on conflict condition
    on_conflict: av_on_conflict
  ): av_mutation_response

  # insert a single row into the table: "av"
  insert_av_one(
    # the row to be inserted
    object: av_insert_input!

    # on conflict condition
    on_conflict: av_on_conflict
  ): av

  # insert data into the table: "av_rev"
  insert_av_rev(
    # the rows to be inserted
    objects: [av_rev_insert_input!]!

    # on conflict condition
    on_conflict: av_rev_on_conflict
  ): av_rev_mutation_response

  # insert a single row into the table: "av_rev"
  insert_av_rev_one(
    # the row to be inserted
    object: av_rev_insert_input!

    # on conflict condition
    on_conflict: av_rev_on_conflict
  ): av_rev

  # insert data into the table: "event"
  insert_event(
    # the rows to be inserted
    objects: [event_insert_input!]!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event_mutation_response

  # insert a single row into the table: "event"
  insert_event_one(
    # the row to be inserted
    object: event_insert_input!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event

  # insert data into the table: "event_rev"
  insert_event_rev(
    # the rows to be inserted
    objects: [event_rev_insert_input!]!

    # on conflict condition
    on_conflict: event_rev_on_conflict
  ): event_rev_mutation_response

  # insert a single row into the table: "event_rev"
  insert_event_rev_one(
    # the row to be inserted
    object: event_rev_insert_input!

    # on conflict condition
    on_conflict: event_rev_on_conflict
  ): event_rev

  # insert data into the table: "garten"
  insert_garten(
    # the rows to be inserted
    objects: [garten_insert_input!]!

    # on conflict condition
    on_conflict: garten_on_conflict
  ): garten_mutation_response

  # insert data into the table: "garten_file"
  insert_garten_file(
    # the rows to be inserted
    objects: [garten_file_insert_input!]!

    # on conflict condition
    on_conflict: garten_file_on_conflict
  ): garten_file_mutation_response

  # insert a single row into the table: "garten_file"
  insert_garten_file_one(
    # the row to be inserted
    object: garten_file_insert_input!

    # on conflict condition
    on_conflict: garten_file_on_conflict
  ): garten_file

  # insert a single row into the table: "garten"
  insert_garten_one(
    # the row to be inserted
    object: garten_insert_input!

    # on conflict condition
    on_conflict: garten_on_conflict
  ): garten

  # insert data into the table: "garten_rev"
  insert_garten_rev(
    # the rows to be inserted
    objects: [garten_rev_insert_input!]!

    # on conflict condition
    on_conflict: garten_rev_on_conflict
  ): garten_rev_mutation_response

  # insert a single row into the table: "garten_rev"
  insert_garten_rev_one(
    # the row to be inserted
    object: garten_rev_insert_input!

    # on conflict condition
    on_conflict: garten_rev_on_conflict
  ): garten_rev

  # insert data into the table: "gv"
  insert_gv(
    # the rows to be inserted
    objects: [gv_insert_input!]!

    # on conflict condition
    on_conflict: gv_on_conflict
  ): gv_mutation_response

  # insert a single row into the table: "gv"
  insert_gv_one(
    # the row to be inserted
    object: gv_insert_input!

    # on conflict condition
    on_conflict: gv_on_conflict
  ): gv

  # insert data into the table: "gv_rev"
  insert_gv_rev(
    # the rows to be inserted
    objects: [gv_rev_insert_input!]!

    # on conflict condition
    on_conflict: gv_rev_on_conflict
  ): gv_rev_mutation_response

  # insert a single row into the table: "gv_rev"
  insert_gv_rev_one(
    # the row to be inserted
    object: gv_rev_insert_input!

    # on conflict condition
    on_conflict: gv_rev_on_conflict
  ): gv_rev

  # insert data into the table: "herkunft"
  insert_herkunft(
    # the rows to be inserted
    objects: [herkunft_insert_input!]!

    # on conflict condition
    on_conflict: herkunft_on_conflict
  ): herkunft_mutation_response

  # insert data into the table: "herkunft_file"
  insert_herkunft_file(
    # the rows to be inserted
    objects: [herkunft_file_insert_input!]!

    # on conflict condition
    on_conflict: herkunft_file_on_conflict
  ): herkunft_file_mutation_response

  # insert a single row into the table: "herkunft_file"
  insert_herkunft_file_one(
    # the row to be inserted
    object: herkunft_file_insert_input!

    # on conflict condition
    on_conflict: herkunft_file_on_conflict
  ): herkunft_file

  # insert a single row into the table: "herkunft"
  insert_herkunft_one(
    # the row to be inserted
    object: herkunft_insert_input!

    # on conflict condition
    on_conflict: herkunft_on_conflict
  ): herkunft

  # insert data into the table: "herkunft_rev"
  insert_herkunft_rev(
    # the rows to be inserted
    objects: [herkunft_rev_insert_input!]!

    # on conflict condition
    on_conflict: herkunft_rev_on_conflict
  ): herkunft_rev_mutation_response

  # insert a single row into the table: "herkunft_rev"
  insert_herkunft_rev_one(
    # the row to be inserted
    object: herkunft_rev_insert_input!

    # on conflict condition
    on_conflict: herkunft_rev_on_conflict
  ): herkunft_rev

  # insert data into the table: "kultur"
  insert_kultur(
    # the rows to be inserted
    objects: [kultur_insert_input!]!

    # on conflict condition
    on_conflict: kultur_on_conflict
  ): kultur_mutation_response

  # insert data into the table: "kultur_file"
  insert_kultur_file(
    # the rows to be inserted
    objects: [kultur_file_insert_input!]!

    # on conflict condition
    on_conflict: kultur_file_on_conflict
  ): kultur_file_mutation_response

  # insert a single row into the table: "kultur_file"
  insert_kultur_file_one(
    # the row to be inserted
    object: kultur_file_insert_input!

    # on conflict condition
    on_conflict: kultur_file_on_conflict
  ): kultur_file

  # insert a single row into the table: "kultur"
  insert_kultur_one(
    # the row to be inserted
    object: kultur_insert_input!

    # on conflict condition
    on_conflict: kultur_on_conflict
  ): kultur

  # insert data into the table: "kultur_option"
  insert_kultur_option(
    # the rows to be inserted
    objects: [kultur_option_insert_input!]!

    # on conflict condition
    on_conflict: kultur_option_on_conflict
  ): kultur_option_mutation_response

  # insert a single row into the table: "kultur_option"
  insert_kultur_option_one(
    # the row to be inserted
    object: kultur_option_insert_input!

    # on conflict condition
    on_conflict: kultur_option_on_conflict
  ): kultur_option

  # insert data into the table: "kultur_option_rev"
  insert_kultur_option_rev(
    # the rows to be inserted
    objects: [kultur_option_rev_insert_input!]!

    # on conflict condition
    on_conflict: kultur_option_rev_on_conflict
  ): kultur_option_rev_mutation_response

  # insert a single row into the table: "kultur_option_rev"
  insert_kultur_option_rev_one(
    # the row to be inserted
    object: kultur_option_rev_insert_input!

    # on conflict condition
    on_conflict: kultur_option_rev_on_conflict
  ): kultur_option_rev

  # insert data into the table: "kultur_qk"
  insert_kultur_qk(
    # the rows to be inserted
    objects: [kultur_qk_insert_input!]!

    # on conflict condition
    on_conflict: kultur_qk_on_conflict
  ): kultur_qk_mutation_response

  # insert data into the table: "kultur_qk_choosen"
  insert_kultur_qk_choosen(
    # the rows to be inserted
    objects: [kultur_qk_choosen_insert_input!]!

    # on conflict condition
    on_conflict: kultur_qk_choosen_on_conflict
  ): kultur_qk_choosen_mutation_response

  # insert a single row into the table: "kultur_qk_choosen"
  insert_kultur_qk_choosen_one(
    # the row to be inserted
    object: kultur_qk_choosen_insert_input!

    # on conflict condition
    on_conflict: kultur_qk_choosen_on_conflict
  ): kultur_qk_choosen

  # insert data into the table: "kultur_qk_choosen_rev"
  insert_kultur_qk_choosen_rev(
    # the rows to be inserted
    objects: [kultur_qk_choosen_rev_insert_input!]!

    # on conflict condition
    on_conflict: kultur_qk_choosen_rev_on_conflict
  ): kultur_qk_choosen_rev_mutation_response

  # insert a single row into the table: "kultur_qk_choosen_rev"
  insert_kultur_qk_choosen_rev_one(
    # the row to be inserted
    object: kultur_qk_choosen_rev_insert_input!

    # on conflict condition
    on_conflict: kultur_qk_choosen_rev_on_conflict
  ): kultur_qk_choosen_rev

  # insert a single row into the table: "kultur_qk"
  insert_kultur_qk_one(
    # the row to be inserted
    object: kultur_qk_insert_input!

    # on conflict condition
    on_conflict: kultur_qk_on_conflict
  ): kultur_qk

  # insert data into the table: "kultur_qk_rev"
  insert_kultur_qk_rev(
    # the rows to be inserted
    objects: [kultur_qk_rev_insert_input!]!

    # on conflict condition
    on_conflict: kultur_qk_rev_on_conflict
  ): kultur_qk_rev_mutation_response

  # insert a single row into the table: "kultur_qk_rev"
  insert_kultur_qk_rev_one(
    # the row to be inserted
    object: kultur_qk_rev_insert_input!

    # on conflict condition
    on_conflict: kultur_qk_rev_on_conflict
  ): kultur_qk_rev

  # insert data into the table: "kultur_rev"
  insert_kultur_rev(
    # the rows to be inserted
    objects: [kultur_rev_insert_input!]!

    # on conflict condition
    on_conflict: kultur_rev_on_conflict
  ): kultur_rev_mutation_response

  # insert a single row into the table: "kultur_rev"
  insert_kultur_rev_one(
    # the row to be inserted
    object: kultur_rev_insert_input!

    # on conflict condition
    on_conflict: kultur_rev_on_conflict
  ): kultur_rev

  # insert data into the table: "lieferung"
  insert_lieferung(
    # the rows to be inserted
    objects: [lieferung_insert_input!]!

    # on conflict condition
    on_conflict: lieferung_on_conflict
  ): lieferung_mutation_response

  # insert data into the table: "lieferung_file"
  insert_lieferung_file(
    # the rows to be inserted
    objects: [lieferung_file_insert_input!]!

    # on conflict condition
    on_conflict: lieferung_file_on_conflict
  ): lieferung_file_mutation_response

  # insert a single row into the table: "lieferung_file"
  insert_lieferung_file_one(
    # the row to be inserted
    object: lieferung_file_insert_input!

    # on conflict condition
    on_conflict: lieferung_file_on_conflict
  ): lieferung_file

  # insert a single row into the table: "lieferung"
  insert_lieferung_one(
    # the row to be inserted
    object: lieferung_insert_input!

    # on conflict condition
    on_conflict: lieferung_on_conflict
  ): lieferung

  # insert data into the table: "lieferung_rev"
  insert_lieferung_rev(
    # the rows to be inserted
    objects: [lieferung_rev_insert_input!]!

    # on conflict condition
    on_conflict: lieferung_rev_on_conflict
  ): lieferung_rev_mutation_response

  # insert a single row into the table: "lieferung_rev"
  insert_lieferung_rev_one(
    # the row to be inserted
    object: lieferung_rev_insert_input!

    # on conflict condition
    on_conflict: lieferung_rev_on_conflict
  ): lieferung_rev

  # insert data into the table: "person"
  insert_person(
    # the rows to be inserted
    objects: [person_insert_input!]!

    # on conflict condition
    on_conflict: person_on_conflict
  ): person_mutation_response

  # insert data into the table: "person_file"
  insert_person_file(
    # the rows to be inserted
    objects: [person_file_insert_input!]!

    # on conflict condition
    on_conflict: person_file_on_conflict
  ): person_file_mutation_response

  # insert a single row into the table: "person_file"
  insert_person_file_one(
    # the row to be inserted
    object: person_file_insert_input!

    # on conflict condition
    on_conflict: person_file_on_conflict
  ): person_file

  # insert a single row into the table: "person"
  insert_person_one(
    # the row to be inserted
    object: person_insert_input!

    # on conflict condition
    on_conflict: person_on_conflict
  ): person

  # insert data into the table: "person_option"
  insert_person_option(
    # the rows to be inserted
    objects: [person_option_insert_input!]!

    # on conflict condition
    on_conflict: person_option_on_conflict
  ): person_option_mutation_response

  # insert a single row into the table: "person_option"
  insert_person_option_one(
    # the row to be inserted
    object: person_option_insert_input!

    # on conflict condition
    on_conflict: person_option_on_conflict
  ): person_option

  # insert data into the table: "person_option_rev"
  insert_person_option_rev(
    # the rows to be inserted
    objects: [person_option_rev_insert_input!]!

    # on conflict condition
    on_conflict: person_option_rev_on_conflict
  ): person_option_rev_mutation_response

  # insert a single row into the table: "person_option_rev"
  insert_person_option_rev_one(
    # the row to be inserted
    object: person_option_rev_insert_input!

    # on conflict condition
    on_conflict: person_option_rev_on_conflict
  ): person_option_rev

  # insert data into the table: "person_rev"
  insert_person_rev(
    # the rows to be inserted
    objects: [person_rev_insert_input!]!

    # on conflict condition
    on_conflict: person_rev_on_conflict
  ): person_rev_mutation_response

  # insert a single row into the table: "person_rev"
  insert_person_rev_one(
    # the row to be inserted
    object: person_rev_insert_input!

    # on conflict condition
    on_conflict: person_rev_on_conflict
  ): person_rev

  # insert data into the table: "sammel_lieferung"
  insert_sammel_lieferung(
    # the rows to be inserted
    objects: [sammel_lieferung_insert_input!]!

    # on conflict condition
    on_conflict: sammel_lieferung_on_conflict
  ): sammel_lieferung_mutation_response

  # insert a single row into the table: "sammel_lieferung"
  insert_sammel_lieferung_one(
    # the row to be inserted
    object: sammel_lieferung_insert_input!

    # on conflict condition
    on_conflict: sammel_lieferung_on_conflict
  ): sammel_lieferung

  # insert data into the table: "sammel_lieferung_rev"
  insert_sammel_lieferung_rev(
    # the rows to be inserted
    objects: [sammel_lieferung_rev_insert_input!]!

    # on conflict condition
    on_conflict: sammel_lieferung_rev_on_conflict
  ): sammel_lieferung_rev_mutation_response

  # insert a single row into the table: "sammel_lieferung_rev"
  insert_sammel_lieferung_rev_one(
    # the row to be inserted
    object: sammel_lieferung_rev_insert_input!

    # on conflict condition
    on_conflict: sammel_lieferung_rev_on_conflict
  ): sammel_lieferung_rev

  # insert data into the table: "sammlung"
  insert_sammlung(
    # the rows to be inserted
    objects: [sammlung_insert_input!]!

    # on conflict condition
    on_conflict: sammlung_on_conflict
  ): sammlung_mutation_response

  # insert data into the table: "sammlung_file"
  insert_sammlung_file(
    # the rows to be inserted
    objects: [sammlung_file_insert_input!]!

    # on conflict condition
    on_conflict: sammlung_file_on_conflict
  ): sammlung_file_mutation_response

  # insert a single row into the table: "sammlung_file"
  insert_sammlung_file_one(
    # the row to be inserted
    object: sammlung_file_insert_input!

    # on conflict condition
    on_conflict: sammlung_file_on_conflict
  ): sammlung_file

  # insert a single row into the table: "sammlung"
  insert_sammlung_one(
    # the row to be inserted
    object: sammlung_insert_input!

    # on conflict condition
    on_conflict: sammlung_on_conflict
  ): sammlung

  # insert data into the table: "sammlung_rev"
  insert_sammlung_rev(
    # the rows to be inserted
    objects: [sammlung_rev_insert_input!]!

    # on conflict condition
    on_conflict: sammlung_rev_on_conflict
  ): sammlung_rev_mutation_response

  # insert a single row into the table: "sammlung_rev"
  insert_sammlung_rev_one(
    # the row to be inserted
    object: sammlung_rev_insert_input!

    # on conflict condition
    on_conflict: sammlung_rev_on_conflict
  ): sammlung_rev

  # insert data into the table: "spatial_ref_sys"
  insert_spatial_ref_sys(
    # the rows to be inserted
    objects: [spatial_ref_sys_insert_input!]!

    # on conflict condition
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys_mutation_response

  # insert a single row into the table: "spatial_ref_sys"
  insert_spatial_ref_sys_one(
    # the row to be inserted
    object: spatial_ref_sys_insert_input!

    # on conflict condition
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys

  # insert data into the table: "teilkultur"
  insert_teilkultur(
    # the rows to be inserted
    objects: [teilkultur_insert_input!]!

    # on conflict condition
    on_conflict: teilkultur_on_conflict
  ): teilkultur_mutation_response

  # insert a single row into the table: "teilkultur"
  insert_teilkultur_one(
    # the row to be inserted
    object: teilkultur_insert_input!

    # on conflict condition
    on_conflict: teilkultur_on_conflict
  ): teilkultur

  # insert data into the table: "teilkultur_rev"
  insert_teilkultur_rev(
    # the rows to be inserted
    objects: [teilkultur_rev_insert_input!]!

    # on conflict condition
    on_conflict: teilkultur_rev_on_conflict
  ): teilkultur_rev_mutation_response

  # insert a single row into the table: "teilkultur_rev"
  insert_teilkultur_rev_one(
    # the row to be inserted
    object: teilkultur_rev_insert_input!

    # on conflict condition
    on_conflict: teilkultur_rev_on_conflict
  ): teilkultur_rev

  # insert data into the table: "teilzaehlung"
  insert_teilzaehlung(
    # the rows to be inserted
    objects: [teilzaehlung_insert_input!]!

    # on conflict condition
    on_conflict: teilzaehlung_on_conflict
  ): teilzaehlung_mutation_response

  # insert a single row into the table: "teilzaehlung"
  insert_teilzaehlung_one(
    # the row to be inserted
    object: teilzaehlung_insert_input!

    # on conflict condition
    on_conflict: teilzaehlung_on_conflict
  ): teilzaehlung

  # insert data into the table: "teilzaehlung_rev"
  insert_teilzaehlung_rev(
    # the rows to be inserted
    objects: [teilzaehlung_rev_insert_input!]!

    # on conflict condition
    on_conflict: teilzaehlung_rev_on_conflict
  ): teilzaehlung_rev_mutation_response

  # insert a single row into the table: "teilzaehlung_rev"
  insert_teilzaehlung_rev_one(
    # the row to be inserted
    object: teilzaehlung_rev_insert_input!

    # on conflict condition
    on_conflict: teilzaehlung_rev_on_conflict
  ): teilzaehlung_rev

  # insert data into the table: "user_role"
  insert_user_role(
    # the rows to be inserted
    objects: [user_role_insert_input!]!

    # on conflict condition
    on_conflict: user_role_on_conflict
  ): user_role_mutation_response

  # insert a single row into the table: "user_role"
  insert_user_role_one(
    # the row to be inserted
    object: user_role_insert_input!

    # on conflict condition
    on_conflict: user_role_on_conflict
  ): user_role

  # insert data into the table: "zaehlung"
  insert_zaehlung(
    # the rows to be inserted
    objects: [zaehlung_insert_input!]!

    # on conflict condition
    on_conflict: zaehlung_on_conflict
  ): zaehlung_mutation_response

  # insert a single row into the table: "zaehlung"
  insert_zaehlung_one(
    # the row to be inserted
    object: zaehlung_insert_input!

    # on conflict condition
    on_conflict: zaehlung_on_conflict
  ): zaehlung

  # insert data into the table: "zaehlung_rev"
  insert_zaehlung_rev(
    # the rows to be inserted
    objects: [zaehlung_rev_insert_input!]!

    # on conflict condition
    on_conflict: zaehlung_rev_on_conflict
  ): zaehlung_rev_mutation_response

  # insert a single row into the table: "zaehlung_rev"
  insert_zaehlung_rev_one(
    # the row to be inserted
    object: zaehlung_rev_insert_input!

    # on conflict condition
    on_conflict: zaehlung_rev_on_conflict
  ): zaehlung_rev

  # update data of the table: "ae_art"
  update_ae_art(
    # increments the integer columns with given value of the filtered values
    _inc: ae_art_inc_input

    # sets the columns of the filtered rows to the given values
    _set: ae_art_set_input

    # filter the rows which have to be updated
    where: ae_art_bool_exp!
  ): ae_art_mutation_response

  # update single row of the table: "ae_art"
  update_ae_art_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: ae_art_inc_input

    # sets the columns of the filtered rows to the given values
    _set: ae_art_set_input
    pk_columns: ae_art_pk_columns_input!
  ): ae_art

  # update data of the table: "art"
  update_art(
    # increments the integer columns with given value of the filtered values
    _inc: art_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_set_input

    # filter the rows which have to be updated
    where: art_bool_exp!
  ): art_mutation_response

  # update single row of the table: "art"
  update_art_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_set_input
    pk_columns: art_pk_columns_input!
  ): art

  # update data of the table: "art_file"
  update_art_file(
    # increments the integer columns with given value of the filtered values
    _inc: art_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_file_set_input

    # filter the rows which have to be updated
    where: art_file_bool_exp!
  ): art_file_mutation_response

  # update single row of the table: "art_file"
  update_art_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_file_set_input
    pk_columns: art_file_pk_columns_input!
  ): art_file

  # update data of the table: "art_qk"
  update_art_qk(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_set_input

    # filter the rows which have to be updated
    where: art_qk_bool_exp!
  ): art_qk_mutation_response

  # update single row of the table: "art_qk"
  update_art_qk_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_set_input
    pk_columns: art_qk_pk_columns_input!
  ): art_qk

  # update data of the table: "art_qk_choosen"
  update_art_qk_choosen(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_choosen_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_choosen_set_input

    # filter the rows which have to be updated
    where: art_qk_choosen_bool_exp!
  ): art_qk_choosen_mutation_response

  # update single row of the table: "art_qk_choosen"
  update_art_qk_choosen_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_choosen_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_choosen_set_input
    pk_columns: art_qk_choosen_pk_columns_input!
  ): art_qk_choosen

  # update data of the table: "art_qk_choosen_rev"
  update_art_qk_choosen_rev(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_choosen_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_choosen_rev_set_input

    # filter the rows which have to be updated
    where: art_qk_choosen_rev_bool_exp!
  ): art_qk_choosen_rev_mutation_response

  # update single row of the table: "art_qk_choosen_rev"
  update_art_qk_choosen_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_choosen_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_choosen_rev_set_input
    pk_columns: art_qk_choosen_rev_pk_columns_input!
  ): art_qk_choosen_rev

  # update data of the table: "art_qk_rev"
  update_art_qk_rev(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_rev_set_input

    # filter the rows which have to be updated
    where: art_qk_rev_bool_exp!
  ): art_qk_rev_mutation_response

  # update single row of the table: "art_qk_rev"
  update_art_qk_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_qk_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_qk_rev_set_input
    pk_columns: art_qk_rev_pk_columns_input!
  ): art_qk_rev

  # update data of the table: "art_rev"
  update_art_rev(
    # increments the integer columns with given value of the filtered values
    _inc: art_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_rev_set_input

    # filter the rows which have to be updated
    where: art_rev_bool_exp!
  ): art_rev_mutation_response

  # update single row of the table: "art_rev"
  update_art_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: art_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: art_rev_set_input
    pk_columns: art_rev_pk_columns_input!
  ): art_rev

  # update data of the table: "av"
  update_av(
    # increments the integer columns with given value of the filtered values
    _inc: av_inc_input

    # sets the columns of the filtered rows to the given values
    _set: av_set_input

    # filter the rows which have to be updated
    where: av_bool_exp!
  ): av_mutation_response

  # update single row of the table: "av"
  update_av_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: av_inc_input

    # sets the columns of the filtered rows to the given values
    _set: av_set_input
    pk_columns: av_pk_columns_input!
  ): av

  # update data of the table: "av_rev"
  update_av_rev(
    # increments the integer columns with given value of the filtered values
    _inc: av_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: av_rev_set_input

    # filter the rows which have to be updated
    where: av_rev_bool_exp!
  ): av_rev_mutation_response

  # update single row of the table: "av_rev"
  update_av_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: av_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: av_rev_set_input
    pk_columns: av_rev_pk_columns_input!
  ): av_rev

  # update data of the table: "event"
  update_event(
    # increments the integer columns with given value of the filtered values
    _inc: event_inc_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input

    # filter the rows which have to be updated
    where: event_bool_exp!
  ): event_mutation_response

  # update single row of the table: "event"
  update_event_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: event_inc_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input
    pk_columns: event_pk_columns_input!
  ): event

  # update data of the table: "event_rev"
  update_event_rev(
    # increments the integer columns with given value of the filtered values
    _inc: event_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: event_rev_set_input

    # filter the rows which have to be updated
    where: event_rev_bool_exp!
  ): event_rev_mutation_response

  # update single row of the table: "event_rev"
  update_event_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: event_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: event_rev_set_input
    pk_columns: event_rev_pk_columns_input!
  ): event_rev

  # update data of the table: "garten"
  update_garten(
    # increments the integer columns with given value of the filtered values
    _inc: garten_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_set_input

    # filter the rows which have to be updated
    where: garten_bool_exp!
  ): garten_mutation_response

  # update single row of the table: "garten"
  update_garten_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: garten_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_set_input
    pk_columns: garten_pk_columns_input!
  ): garten

  # update data of the table: "garten_file"
  update_garten_file(
    # increments the integer columns with given value of the filtered values
    _inc: garten_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_file_set_input

    # filter the rows which have to be updated
    where: garten_file_bool_exp!
  ): garten_file_mutation_response

  # update single row of the table: "garten_file"
  update_garten_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: garten_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_file_set_input
    pk_columns: garten_file_pk_columns_input!
  ): garten_file

  # update data of the table: "garten_rev"
  update_garten_rev(
    # increments the integer columns with given value of the filtered values
    _inc: garten_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_rev_set_input

    # filter the rows which have to be updated
    where: garten_rev_bool_exp!
  ): garten_rev_mutation_response

  # update single row of the table: "garten_rev"
  update_garten_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: garten_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: garten_rev_set_input
    pk_columns: garten_rev_pk_columns_input!
  ): garten_rev

  # update data of the table: "gv"
  update_gv(
    # increments the integer columns with given value of the filtered values
    _inc: gv_inc_input

    # sets the columns of the filtered rows to the given values
    _set: gv_set_input

    # filter the rows which have to be updated
    where: gv_bool_exp!
  ): gv_mutation_response

  # update single row of the table: "gv"
  update_gv_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: gv_inc_input

    # sets the columns of the filtered rows to the given values
    _set: gv_set_input
    pk_columns: gv_pk_columns_input!
  ): gv

  # update data of the table: "gv_rev"
  update_gv_rev(
    # increments the integer columns with given value of the filtered values
    _inc: gv_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: gv_rev_set_input

    # filter the rows which have to be updated
    where: gv_rev_bool_exp!
  ): gv_rev_mutation_response

  # update single row of the table: "gv_rev"
  update_gv_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: gv_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: gv_rev_set_input
    pk_columns: gv_rev_pk_columns_input!
  ): gv_rev

  # update data of the table: "herkunft"
  update_herkunft(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_set_input

    # filter the rows which have to be updated
    where: herkunft_bool_exp!
  ): herkunft_mutation_response

  # update single row of the table: "herkunft"
  update_herkunft_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_set_input
    pk_columns: herkunft_pk_columns_input!
  ): herkunft

  # update data of the table: "herkunft_file"
  update_herkunft_file(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_file_set_input

    # filter the rows which have to be updated
    where: herkunft_file_bool_exp!
  ): herkunft_file_mutation_response

  # update single row of the table: "herkunft_file"
  update_herkunft_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_file_set_input
    pk_columns: herkunft_file_pk_columns_input!
  ): herkunft_file

  # update data of the table: "herkunft_rev"
  update_herkunft_rev(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_rev_set_input

    # filter the rows which have to be updated
    where: herkunft_rev_bool_exp!
  ): herkunft_rev_mutation_response

  # update single row of the table: "herkunft_rev"
  update_herkunft_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: herkunft_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: herkunft_rev_set_input
    pk_columns: herkunft_rev_pk_columns_input!
  ): herkunft_rev

  # update data of the table: "kultur"
  update_kultur(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_set_input

    # filter the rows which have to be updated
    where: kultur_bool_exp!
  ): kultur_mutation_response

  # update single row of the table: "kultur"
  update_kultur_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_set_input
    pk_columns: kultur_pk_columns_input!
  ): kultur

  # update data of the table: "kultur_file"
  update_kultur_file(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_file_set_input

    # filter the rows which have to be updated
    where: kultur_file_bool_exp!
  ): kultur_file_mutation_response

  # update single row of the table: "kultur_file"
  update_kultur_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_file_set_input
    pk_columns: kultur_file_pk_columns_input!
  ): kultur_file

  # update data of the table: "kultur_option"
  update_kultur_option(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_option_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_option_set_input

    # filter the rows which have to be updated
    where: kultur_option_bool_exp!
  ): kultur_option_mutation_response

  # update data of the table: "kultur_option_rev"
  update_kultur_option_rev(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_option_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_option_rev_set_input

    # filter the rows which have to be updated
    where: kultur_option_rev_bool_exp!
  ): kultur_option_rev_mutation_response

  # update single row of the table: "kultur_option_rev"
  update_kultur_option_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_option_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_option_rev_set_input
    pk_columns: kultur_option_rev_pk_columns_input!
  ): kultur_option_rev

  # update data of the table: "kultur_qk"
  update_kultur_qk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_set_input

    # filter the rows which have to be updated
    where: kultur_qk_bool_exp!
  ): kultur_qk_mutation_response

  # update single row of the table: "kultur_qk"
  update_kultur_qk_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_set_input
    pk_columns: kultur_qk_pk_columns_input!
  ): kultur_qk

  # update data of the table: "kultur_qk_choosen"
  update_kultur_qk_choosen(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_choosen_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_choosen_set_input

    # filter the rows which have to be updated
    where: kultur_qk_choosen_bool_exp!
  ): kultur_qk_choosen_mutation_response

  # update single row of the table: "kultur_qk_choosen"
  update_kultur_qk_choosen_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_choosen_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_choosen_set_input
    pk_columns: kultur_qk_choosen_pk_columns_input!
  ): kultur_qk_choosen

  # update data of the table: "kultur_qk_choosen_rev"
  update_kultur_qk_choosen_rev(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_choosen_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_choosen_rev_set_input

    # filter the rows which have to be updated
    where: kultur_qk_choosen_rev_bool_exp!
  ): kultur_qk_choosen_rev_mutation_response

  # update single row of the table: "kultur_qk_choosen_rev"
  update_kultur_qk_choosen_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_choosen_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_choosen_rev_set_input
    pk_columns: kultur_qk_choosen_rev_pk_columns_input!
  ): kultur_qk_choosen_rev

  # update data of the table: "kultur_qk_rev"
  update_kultur_qk_rev(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_rev_set_input

    # filter the rows which have to be updated
    where: kultur_qk_rev_bool_exp!
  ): kultur_qk_rev_mutation_response

  # update single row of the table: "kultur_qk_rev"
  update_kultur_qk_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_qk_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_qk_rev_set_input
    pk_columns: kultur_qk_rev_pk_columns_input!
  ): kultur_qk_rev

  # update data of the table: "kultur_rev"
  update_kultur_rev(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_rev_set_input

    # filter the rows which have to be updated
    where: kultur_rev_bool_exp!
  ): kultur_rev_mutation_response

  # update single row of the table: "kultur_rev"
  update_kultur_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kultur_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kultur_rev_set_input
    pk_columns: kultur_rev_pk_columns_input!
  ): kultur_rev

  # update data of the table: "lieferung"
  update_lieferung(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_set_input

    # filter the rows which have to be updated
    where: lieferung_bool_exp!
  ): lieferung_mutation_response

  # update single row of the table: "lieferung"
  update_lieferung_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_set_input
    pk_columns: lieferung_pk_columns_input!
  ): lieferung

  # update data of the table: "lieferung_file"
  update_lieferung_file(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_file_set_input

    # filter the rows which have to be updated
    where: lieferung_file_bool_exp!
  ): lieferung_file_mutation_response

  # update single row of the table: "lieferung_file"
  update_lieferung_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_file_set_input
    pk_columns: lieferung_file_pk_columns_input!
  ): lieferung_file

  # update data of the table: "lieferung_rev"
  update_lieferung_rev(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_rev_set_input

    # filter the rows which have to be updated
    where: lieferung_rev_bool_exp!
  ): lieferung_rev_mutation_response

  # update single row of the table: "lieferung_rev"
  update_lieferung_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: lieferung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lieferung_rev_set_input
    pk_columns: lieferung_rev_pk_columns_input!
  ): lieferung_rev

  # update data of the table: "person"
  update_person(
    # increments the integer columns with given value of the filtered values
    _inc: person_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_set_input

    # filter the rows which have to be updated
    where: person_bool_exp!
  ): person_mutation_response

  # update single row of the table: "person"
  update_person_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: person_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_set_input
    pk_columns: person_pk_columns_input!
  ): person

  # update data of the table: "person_file"
  update_person_file(
    # increments the integer columns with given value of the filtered values
    _inc: person_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_file_set_input

    # filter the rows which have to be updated
    where: person_file_bool_exp!
  ): person_file_mutation_response

  # update single row of the table: "person_file"
  update_person_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: person_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_file_set_input
    pk_columns: person_file_pk_columns_input!
  ): person_file

  # update data of the table: "person_option"
  update_person_option(
    # increments the integer columns with given value of the filtered values
    _inc: person_option_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_option_set_input

    # filter the rows which have to be updated
    where: person_option_bool_exp!
  ): person_option_mutation_response

  # update data of the table: "person_option_rev"
  update_person_option_rev(
    # increments the integer columns with given value of the filtered values
    _inc: person_option_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_option_rev_set_input

    # filter the rows which have to be updated
    where: person_option_rev_bool_exp!
  ): person_option_rev_mutation_response

  # update single row of the table: "person_option_rev"
  update_person_option_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: person_option_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_option_rev_set_input
    pk_columns: person_option_rev_pk_columns_input!
  ): person_option_rev

  # update data of the table: "person_rev"
  update_person_rev(
    # increments the integer columns with given value of the filtered values
    _inc: person_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_rev_set_input

    # filter the rows which have to be updated
    where: person_rev_bool_exp!
  ): person_rev_mutation_response

  # update single row of the table: "person_rev"
  update_person_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: person_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: person_rev_set_input
    pk_columns: person_rev_pk_columns_input!
  ): person_rev

  # update data of the table: "sammel_lieferung"
  update_sammel_lieferung(
    # increments the integer columns with given value of the filtered values
    _inc: sammel_lieferung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammel_lieferung_set_input

    # filter the rows which have to be updated
    where: sammel_lieferung_bool_exp!
  ): sammel_lieferung_mutation_response

  # update single row of the table: "sammel_lieferung"
  update_sammel_lieferung_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: sammel_lieferung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammel_lieferung_set_input
    pk_columns: sammel_lieferung_pk_columns_input!
  ): sammel_lieferung

  # update data of the table: "sammel_lieferung_rev"
  update_sammel_lieferung_rev(
    # increments the integer columns with given value of the filtered values
    _inc: sammel_lieferung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammel_lieferung_rev_set_input

    # filter the rows which have to be updated
    where: sammel_lieferung_rev_bool_exp!
  ): sammel_lieferung_rev_mutation_response

  # update single row of the table: "sammel_lieferung_rev"
  update_sammel_lieferung_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: sammel_lieferung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammel_lieferung_rev_set_input
    pk_columns: sammel_lieferung_rev_pk_columns_input!
  ): sammel_lieferung_rev

  # update data of the table: "sammlung"
  update_sammlung(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_set_input

    # filter the rows which have to be updated
    where: sammlung_bool_exp!
  ): sammlung_mutation_response

  # update single row of the table: "sammlung"
  update_sammlung_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_set_input
    pk_columns: sammlung_pk_columns_input!
  ): sammlung

  # update data of the table: "sammlung_file"
  update_sammlung_file(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_file_set_input

    # filter the rows which have to be updated
    where: sammlung_file_bool_exp!
  ): sammlung_file_mutation_response

  # update single row of the table: "sammlung_file"
  update_sammlung_file_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_file_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_file_set_input
    pk_columns: sammlung_file_pk_columns_input!
  ): sammlung_file

  # update data of the table: "sammlung_rev"
  update_sammlung_rev(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_rev_set_input

    # filter the rows which have to be updated
    where: sammlung_rev_bool_exp!
  ): sammlung_rev_mutation_response

  # update single row of the table: "sammlung_rev"
  update_sammlung_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: sammlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sammlung_rev_set_input
    pk_columns: sammlung_rev_pk_columns_input!
  ): sammlung_rev

  # update data of the table: "spatial_ref_sys"
  update_spatial_ref_sys(
    # increments the integer columns with given value of the filtered values
    _inc: spatial_ref_sys_inc_input

    # sets the columns of the filtered rows to the given values
    _set: spatial_ref_sys_set_input

    # filter the rows which have to be updated
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  # update single row of the table: "spatial_ref_sys"
  update_spatial_ref_sys_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: spatial_ref_sys_inc_input

    # sets the columns of the filtered rows to the given values
    _set: spatial_ref_sys_set_input
    pk_columns: spatial_ref_sys_pk_columns_input!
  ): spatial_ref_sys

  # update data of the table: "teilkultur"
  update_teilkultur(
    # increments the integer columns with given value of the filtered values
    _inc: teilkultur_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilkultur_set_input

    # filter the rows which have to be updated
    where: teilkultur_bool_exp!
  ): teilkultur_mutation_response

  # update single row of the table: "teilkultur"
  update_teilkultur_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: teilkultur_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilkultur_set_input
    pk_columns: teilkultur_pk_columns_input!
  ): teilkultur

  # update data of the table: "teilkultur_rev"
  update_teilkultur_rev(
    # increments the integer columns with given value of the filtered values
    _inc: teilkultur_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilkultur_rev_set_input

    # filter the rows which have to be updated
    where: teilkultur_rev_bool_exp!
  ): teilkultur_rev_mutation_response

  # update single row of the table: "teilkultur_rev"
  update_teilkultur_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: teilkultur_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilkultur_rev_set_input
    pk_columns: teilkultur_rev_pk_columns_input!
  ): teilkultur_rev

  # update data of the table: "teilzaehlung"
  update_teilzaehlung(
    # increments the integer columns with given value of the filtered values
    _inc: teilzaehlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilzaehlung_set_input

    # filter the rows which have to be updated
    where: teilzaehlung_bool_exp!
  ): teilzaehlung_mutation_response

  # update single row of the table: "teilzaehlung"
  update_teilzaehlung_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: teilzaehlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilzaehlung_set_input
    pk_columns: teilzaehlung_pk_columns_input!
  ): teilzaehlung

  # update data of the table: "teilzaehlung_rev"
  update_teilzaehlung_rev(
    # increments the integer columns with given value of the filtered values
    _inc: teilzaehlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilzaehlung_rev_set_input

    # filter the rows which have to be updated
    where: teilzaehlung_rev_bool_exp!
  ): teilzaehlung_rev_mutation_response

  # update single row of the table: "teilzaehlung_rev"
  update_teilzaehlung_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: teilzaehlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: teilzaehlung_rev_set_input
    pk_columns: teilzaehlung_rev_pk_columns_input!
  ): teilzaehlung_rev

  # update data of the table: "user_role"
  update_user_role(
    # increments the integer columns with given value of the filtered values
    _inc: user_role_inc_input

    # sets the columns of the filtered rows to the given values
    _set: user_role_set_input

    # filter the rows which have to be updated
    where: user_role_bool_exp!
  ): user_role_mutation_response

  # update single row of the table: "user_role"
  update_user_role_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: user_role_inc_input

    # sets the columns of the filtered rows to the given values
    _set: user_role_set_input
    pk_columns: user_role_pk_columns_input!
  ): user_role

  # update data of the table: "zaehlung"
  update_zaehlung(
    # increments the integer columns with given value of the filtered values
    _inc: zaehlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: zaehlung_set_input

    # filter the rows which have to be updated
    where: zaehlung_bool_exp!
  ): zaehlung_mutation_response

  # update single row of the table: "zaehlung"
  update_zaehlung_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: zaehlung_inc_input

    # sets the columns of the filtered rows to the given values
    _set: zaehlung_set_input
    pk_columns: zaehlung_pk_columns_input!
  ): zaehlung

  # update data of the table: "zaehlung_rev"
  update_zaehlung_rev(
    # increments the integer columns with given value of the filtered values
    _inc: zaehlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: zaehlung_rev_set_input

    # filter the rows which have to be updated
    where: zaehlung_rev_bool_exp!
  ): zaehlung_rev_mutation_response

  # update single row of the table: "zaehlung_rev"
  update_zaehlung_rev_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: zaehlung_rev_inc_input

    # sets the columns of the filtered rows to the given values
    _set: zaehlung_rev_set_input
    pk_columns: zaehlung_rev_pk_columns_input!
  ): zaehlung_rev
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "person"
type person {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean

  # An array relationship
  avs(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # An aggregated array relationship
  avs_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String

  # An array relationship
  event_revs(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): [event_rev!]!

  # An aggregated array relationship
  event_revs_aggregate(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): event_rev_aggregate!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # An array relationship
  garten_revs(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): [garten_rev!]!

  # An aggregated array relationship
  garten_revs_aggregate(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): garten_rev_aggregate!

  # An array relationship
  gartens(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): [garten!]!

  # An aggregated array relationship
  gartens_aggregate(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): garten_aggregate!

  # An array relationship
  gvs(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): [gv!]!

  # An aggregated array relationship
  gvs_aggregate(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): gv_aggregate!
  id: ID!
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean

  # An array relationship
  lieferung_revs(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # An aggregated array relationship
  lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!
  name: String
  nr: String
  ort: String

  # An array relationship
  person_files(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): [person_file!]!

  # An aggregated array relationship
  person_files_aggregate(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): person_file_aggregate!

  # An object relationship
  person_option: person_option

  # An array relationship
  person_option_revs(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): [person_option_rev!]!

  # An aggregated array relationship
  person_option_revs_aggregate(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): person_option_rev_aggregate!
  plz: Int

  # An array relationship
  sammel_lieferung_revs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # An aggregated array relationship
  sammel_lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammlung_revs(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): [sammlung_rev!]!

  # An aggregated array relationship
  sammlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): sammlung_rev_aggregate!

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregated selection of "person"
type person_aggregate {
  aggregate: person_aggregate_fields
  nodes: [person!]!
}

# aggregate fields of "person"
type person_aggregate_fields {
  avg: person_avg_fields
  count(columns: [person_select_column!], distinct: Boolean): Int
  max: person_max_fields
  min: person_min_fields
  stddev: person_stddev_fields
  stddev_pop: person_stddev_pop_fields
  stddev_samp: person_stddev_samp_fields
  sum: person_sum_fields
  var_pop: person_var_pop_fields
  var_samp: person_var_samp_fields
  variance: person_variance_fields
}

# order by aggregate values of table "person"
input person_aggregate_order_by {
  avg: person_avg_order_by
  count: order_by
  max: person_max_order_by
  min: person_min_order_by
  stddev: person_stddev_order_by
  stddev_pop: person_stddev_pop_order_by
  stddev_samp: person_stddev_samp_order_by
  sum: person_sum_order_by
  var_pop: person_var_pop_order_by
  var_samp: person_var_samp_order_by
  variance: person_variance_order_by
}

# input type for inserting array relation for remote table "person"
input person_arr_rel_insert_input {
  data: [person_insert_input!]!
  on_conflict: person_on_conflict
}

# aggregate avg on columns
type person_avg_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by avg() on columns of table "person"
input person_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# Boolean expression to filter rows from the table "person". All fields are combined with a logical 'AND'.
input person_bool_exp {
  _and: [person_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: person_bool_exp
  _or: [person_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  account_id: String_comparison_exp
  adresszusatz: String_comparison_exp
  aktiv: Boolean_comparison_exp
  avs: av_bool_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  email: String_comparison_exp
  event_revs: event_rev_bool_exp
  events: event_bool_exp
  garten_revs: garten_rev_bool_exp
  gartens: garten_bool_exp
  gvs: gv_bool_exp
  id: uuid_comparison_exp
  info: Boolean_comparison_exp
  kein_email: Boolean_comparison_exp
  kommerziell: Boolean_comparison_exp
  lieferung_revs: lieferung_rev_bool_exp
  lieferungs: lieferung_bool_exp
  name: String_comparison_exp
  nr: String_comparison_exp
  ort: String_comparison_exp
  person_files: person_file_bool_exp
  person_option: person_option_bool_exp
  person_option_revs: person_option_rev_bool_exp
  plz: Int_comparison_exp
  sammel_lieferung_revs: sammel_lieferung_rev_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlung_revs: sammlung_rev_bool_exp
  sammlungs: sammlung_bool_exp
  strasse: String_comparison_exp
  telefon_geschaeft: String_comparison_exp
  telefon_mobile: String_comparison_exp
  telefon_privat: String_comparison_exp
  user_role_id: uuid_comparison_exp
  vorname: String_comparison_exp
}

# unique or primary key constraints on table "person"
enum person_constraint {
  # unique or primary key constraint
  person_pkey
}

# columns and relationships of "person_file"
type person_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID!
  name: String

  # An object relationship
  person: person
  person_id: uuid
}

# aggregated selection of "person_file"
type person_file_aggregate {
  aggregate: person_file_aggregate_fields
  nodes: [person_file!]!
}

# aggregate fields of "person_file"
type person_file_aggregate_fields {
  avg: person_file_avg_fields
  count(columns: [person_file_select_column!], distinct: Boolean): Int
  max: person_file_max_fields
  min: person_file_min_fields
  stddev: person_file_stddev_fields
  stddev_pop: person_file_stddev_pop_fields
  stddev_samp: person_file_stddev_samp_fields
  sum: person_file_sum_fields
  var_pop: person_file_var_pop_fields
  var_samp: person_file_var_samp_fields
  variance: person_file_variance_fields
}

# order by aggregate values of table "person_file"
input person_file_aggregate_order_by {
  avg: person_file_avg_order_by
  count: order_by
  max: person_file_max_order_by
  min: person_file_min_order_by
  stddev: person_file_stddev_order_by
  stddev_pop: person_file_stddev_pop_order_by
  stddev_samp: person_file_stddev_samp_order_by
  sum: person_file_sum_order_by
  var_pop: person_file_var_pop_order_by
  var_samp: person_file_var_samp_order_by
  variance: person_file_variance_order_by
}

# input type for inserting array relation for remote table "person_file"
input person_file_arr_rel_insert_input {
  data: [person_file_insert_input!]!
  on_conflict: person_file_on_conflict
}

# aggregate avg on columns
type person_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "person_file"
input person_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "person_file". All fields are combined with a logical 'AND'.
input person_file_bool_exp {
  _and: [person_file_bool_exp]
  _not: person_file_bool_exp
  _or: [person_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
}

# unique or primary key constraints on table "person_file"
enum person_file_constraint {
  # unique or primary key constraint
  person_file_pkey
}

# input type for incrementing integer column in table "person_file"
input person_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "person_file"
input person_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  person: person_obj_rel_insert_input
  person_id: uuid
}

# aggregate max on columns
type person_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  person_id: uuid
}

# order by max() on columns of table "person_file"
input person_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  person_id: order_by
}

# aggregate min on columns
type person_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  person_id: uuid
}

# order by min() on columns of table "person_file"
input person_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  person_id: order_by
}

# response of any mutation on the table "person_file"
type person_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [person_file!]!
}

# input type for inserting object relation for remote table "person_file"
input person_file_obj_rel_insert_input {
  data: person_file_insert_input!
  on_conflict: person_file_on_conflict
}

# on conflict condition type for table "person_file"
input person_file_on_conflict {
  constraint: person_file_constraint!
  update_columns: [person_file_update_column!]!
  where: person_file_bool_exp
}

# ordering options when selecting data from "person_file"
input person_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  person: person_order_by
  person_id: order_by
}

# primary key columns input for table: "person_file"
input person_file_pk_columns_input {
  id: ID!
}

# select columns of table "person_file"
enum person_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name

  # column name
  person_id
}

# input type for updating data in table "person_file"
input person_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  person_id: uuid
}

# aggregate stddev on columns
type person_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "person_file"
input person_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type person_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "person_file"
input person_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type person_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "person_file"
input person_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type person_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "person_file"
input person_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "person_file"
enum person_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name

  # column name
  person_id
}

# aggregate var_pop on columns
type person_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "person_file"
input person_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type person_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "person_file"
input person_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type person_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "person_file"
input person_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "person"
input person_inc_input {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# input type for inserting data into table "person"
input person_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean
  avs: av_arr_rel_insert_input
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  event_revs: event_rev_arr_rel_insert_input
  events: event_arr_rel_insert_input
  garten_revs: garten_rev_arr_rel_insert_input
  gartens: garten_arr_rel_insert_input
  gvs: gv_arr_rel_insert_input
  id: ID
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean
  lieferung_revs: lieferung_rev_arr_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  name: String
  nr: String
  ort: String
  person_files: person_file_arr_rel_insert_input
  person_option: person_option_obj_rel_insert_input
  person_option_revs: person_option_rev_arr_rel_insert_input
  plz: Int
  sammel_lieferung_revs: sammel_lieferung_rev_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlung_revs: sammlung_rev_arr_rel_insert_input
  sammlungs: sammlung_arr_rel_insert_input
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregate max on columns
type person_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  account_id: String
  adresszusatz: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  name: String
  nr: String
  ort: String
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# order by max() on columns of table "person"
input person_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  account_id: order_by
  adresszusatz: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  id: order_by
  name: order_by
  nr: order_by
  ort: order_by
  plz: order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# aggregate min on columns
type person_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  account_id: String
  adresszusatz: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  name: String
  nr: String
  ort: String
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# order by min() on columns of table "person"
input person_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  account_id: order_by
  adresszusatz: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  id: order_by
  name: order_by
  nr: order_by
  ort: order_by
  plz: order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# response of any mutation on the table "person"
type person_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [person!]!
}

# input type for inserting object relation for remote table "person"
input person_obj_rel_insert_input {
  data: person_insert_input!
  on_conflict: person_on_conflict
}

# on conflict condition type for table "person"
input person_on_conflict {
  constraint: person_constraint!
  update_columns: [person_update_column!]!
  where: person_bool_exp
}

# columns and relationships of "person_option"
type person_option {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text

  # Dieses Feld wird (momentan) nicht benutzt
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID!
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean

  # Ob die Sammel-Lieferung neben der Lieferung angezeigt wird
  li_show_sl: Boolean

  # Ob Felder, deren Werte aus der Sammel-Lieferung stammen, sichtbar sind
  li_show_sl_felder: Boolean

  # An object relationship
  person: person!
  sl_auto_copy_edits: Boolean

  # Ob in der Sammel-Lieferung leere Felder angezeigt werden (nur wirksam, wenn
  # die Sammel-Lieferung neben einer Lieferung angezeigt wird)
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregated selection of "person_option"
type person_option_aggregate {
  aggregate: person_option_aggregate_fields
  nodes: [person_option!]!
}

# aggregate fields of "person_option"
type person_option_aggregate_fields {
  avg: person_option_avg_fields
  count(columns: [person_option_select_column!], distinct: Boolean): Int
  max: person_option_max_fields
  min: person_option_min_fields
  stddev: person_option_stddev_fields
  stddev_pop: person_option_stddev_pop_fields
  stddev_samp: person_option_stddev_samp_fields
  sum: person_option_sum_fields
  var_pop: person_option_var_pop_fields
  var_samp: person_option_var_samp_fields
  variance: person_option_variance_fields
}

# order by aggregate values of table "person_option"
input person_option_aggregate_order_by {
  avg: person_option_avg_order_by
  count: order_by
  max: person_option_max_order_by
  min: person_option_min_order_by
  stddev: person_option_stddev_order_by
  stddev_pop: person_option_stddev_pop_order_by
  stddev_samp: person_option_stddev_samp_order_by
  sum: person_option_sum_order_by
  var_pop: person_option_var_pop_order_by
  var_samp: person_option_var_samp_order_by
  variance: person_option_variance_order_by
}

# input type for inserting array relation for remote table "person_option"
input person_option_arr_rel_insert_input {
  data: [person_option_insert_input!]!
  on_conflict: person_option_on_conflict
}

# aggregate avg on columns
type person_option_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "person_option"
input person_option_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "person_option". All fields are combined with a logical 'AND'.
input person_option_bool_exp {
  _and: [person_option_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: person_option_bool_exp
  _or: [person_option_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  ar_name_deutsch: Boolean_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  ga_aktiv: Boolean_comparison_exp
  ga_bemerkungen: Boolean_comparison_exp
  ga_geom_point: Boolean_comparison_exp
  ga_lat_lng: Boolean_comparison_exp
  ga_ort: Boolean_comparison_exp
  ga_plz: Boolean_comparison_exp
  ga_strasse: Boolean_comparison_exp
  hk_bemerkungen: Boolean_comparison_exp
  hk_geom_point: Boolean_comparison_exp
  hk_kanton: Boolean_comparison_exp
  hk_land: Boolean_comparison_exp
  id: uuid_comparison_exp
  ku_erhaltungskultur: Boolean_comparison_exp
  ku_zwischenlager: Boolean_comparison_exp
  li_show_sl: Boolean_comparison_exp
  li_show_sl_felder: Boolean_comparison_exp
  person: person_bool_exp
  sl_auto_copy_edits: Boolean_comparison_exp
  sl_show_empty_when_next_to_li: Boolean_comparison_exp
  tree_event: Boolean_comparison_exp
  tree_kultur: Boolean_comparison_exp
  tree_lieferung: Boolean_comparison_exp
  tree_teilkultur: Boolean_comparison_exp
  tree_zaehlung: Boolean_comparison_exp
}

# unique or primary key constraints on table "person_option"
enum person_option_constraint {
  # unique or primary key constraint
  person_option_person_id_key
}

# input type for incrementing integer column in table "person_option"
input person_option_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "person_option"
input person_option_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean
  li_show_sl: Boolean
  li_show_sl_felder: Boolean
  person: person_obj_rel_insert_input
  sl_auto_copy_edits: Boolean
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregate max on columns
type person_option_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
}

# order by max() on columns of table "person_option"
input person_option_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# aggregate min on columns
type person_option_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
}

# order by min() on columns of table "person_option"
input person_option_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
}

# response of any mutation on the table "person_option"
type person_option_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [person_option!]!
}

# input type for inserting object relation for remote table "person_option"
input person_option_obj_rel_insert_input {
  data: person_option_insert_input!
  on_conflict: person_option_on_conflict
}

# on conflict condition type for table "person_option"
input person_option_on_conflict {
  constraint: person_option_constraint!
  update_columns: [person_option_update_column!]!
  where: person_option_bool_exp
}

# ordering options when selecting data from "person_option"
input person_option_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  ar_name_deutsch: order_by
  changed: order_by
  changed_by: order_by
  ga_aktiv: order_by
  ga_bemerkungen: order_by
  ga_geom_point: order_by
  ga_lat_lng: order_by
  ga_ort: order_by
  ga_plz: order_by
  ga_strasse: order_by
  hk_bemerkungen: order_by
  hk_geom_point: order_by
  hk_kanton: order_by
  hk_land: order_by
  id: order_by
  ku_erhaltungskultur: order_by
  ku_zwischenlager: order_by
  li_show_sl: order_by
  li_show_sl_felder: order_by
  person: person_order_by
  sl_auto_copy_edits: order_by
  sl_show_empty_when_next_to_li: order_by
  tree_event: order_by
  tree_kultur: order_by
  tree_lieferung: order_by
  tree_teilkultur: order_by
  tree_zaehlung: order_by
}

# columns and relationships of "person_option_rev"
type person_option_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID!
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean
  li_show_sl: Boolean
  li_show_sl_felder: Boolean

  # An object relationship
  person: person!
  person_id: uuid!
  sl_auto_copy_edits: Boolean
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregated selection of "person_option_rev"
type person_option_rev_aggregate {
  aggregate: person_option_rev_aggregate_fields
  nodes: [person_option_rev!]!
}

# aggregate fields of "person_option_rev"
type person_option_rev_aggregate_fields {
  avg: person_option_rev_avg_fields
  count(columns: [person_option_rev_select_column!], distinct: Boolean): Int
  max: person_option_rev_max_fields
  min: person_option_rev_min_fields
  stddev: person_option_rev_stddev_fields
  stddev_pop: person_option_rev_stddev_pop_fields
  stddev_samp: person_option_rev_stddev_samp_fields
  sum: person_option_rev_sum_fields
  var_pop: person_option_rev_var_pop_fields
  var_samp: person_option_rev_var_samp_fields
  variance: person_option_rev_variance_fields
}

# order by aggregate values of table "person_option_rev"
input person_option_rev_aggregate_order_by {
  avg: person_option_rev_avg_order_by
  count: order_by
  max: person_option_rev_max_order_by
  min: person_option_rev_min_order_by
  stddev: person_option_rev_stddev_order_by
  stddev_pop: person_option_rev_stddev_pop_order_by
  stddev_samp: person_option_rev_stddev_samp_order_by
  sum: person_option_rev_sum_order_by
  var_pop: person_option_rev_var_pop_order_by
  var_samp: person_option_rev_var_samp_order_by
  variance: person_option_rev_variance_order_by
}

# input type for inserting array relation for remote table "person_option_rev"
input person_option_rev_arr_rel_insert_input {
  data: [person_option_rev_insert_input!]!
  on_conflict: person_option_rev_on_conflict
}

# aggregate avg on columns
type person_option_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "person_option_rev"
input person_option_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "person_option_rev". All fields are combined with a logical 'AND'.
input person_option_rev_bool_exp {
  _and: [person_option_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: person_option_rev_bool_exp
  _or: [person_option_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  ar_name_deutsch: Boolean_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  ga_aktiv: Boolean_comparison_exp
  ga_bemerkungen: Boolean_comparison_exp
  ga_geom_point: Boolean_comparison_exp
  ga_lat_lng: Boolean_comparison_exp
  ga_ort: Boolean_comparison_exp
  ga_plz: Boolean_comparison_exp
  ga_strasse: Boolean_comparison_exp
  hk_bemerkungen: Boolean_comparison_exp
  hk_geom_point: Boolean_comparison_exp
  hk_kanton: Boolean_comparison_exp
  hk_land: Boolean_comparison_exp
  id: uuid_comparison_exp
  ku_erhaltungskultur: Boolean_comparison_exp
  ku_zwischenlager: Boolean_comparison_exp
  li_show_sl: Boolean_comparison_exp
  li_show_sl_felder: Boolean_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sl_auto_copy_edits: Boolean_comparison_exp
  sl_show_empty_when_next_to_li: Boolean_comparison_exp
  tree_event: Boolean_comparison_exp
  tree_kultur: Boolean_comparison_exp
  tree_lieferung: Boolean_comparison_exp
  tree_teilkultur: Boolean_comparison_exp
  tree_zaehlung: Boolean_comparison_exp
}

# unique or primary key constraints on table "person_option_rev"
enum person_option_rev_constraint {
  # unique or primary key constraint
  person_option_rev_pkey
}

# input type for incrementing integer column in table "person_option_rev"
input person_option_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "person_option_rev"
input person_option_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean
  li_show_sl: Boolean
  li_show_sl_felder: Boolean
  person: person_obj_rel_insert_input
  person_id: uuid
  sl_auto_copy_edits: Boolean
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregate max on columns
type person_option_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by max() on columns of table "person_option_rev"
input person_option_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# aggregate min on columns
type person_option_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  changed: timestamp
  changed_by: String
  id: ID
  person_id: uuid
}

# order by min() on columns of table "person_option_rev"
input person_option_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  person_id: order_by
}

# response of any mutation on the table "person_option_rev"
type person_option_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [person_option_rev!]!
}

# input type for inserting object relation for remote table "person_option_rev"
input person_option_rev_obj_rel_insert_input {
  data: person_option_rev_insert_input!
  on_conflict: person_option_rev_on_conflict
}

# on conflict condition type for table "person_option_rev"
input person_option_rev_on_conflict {
  constraint: person_option_rev_constraint!
  update_columns: [person_option_rev_update_column!]!
  where: person_option_rev_bool_exp
}

# ordering options when selecting data from "person_option_rev"
input person_option_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  ar_name_deutsch: order_by
  changed: order_by
  changed_by: order_by
  ga_aktiv: order_by
  ga_bemerkungen: order_by
  ga_geom_point: order_by
  ga_lat_lng: order_by
  ga_ort: order_by
  ga_plz: order_by
  ga_strasse: order_by
  hk_bemerkungen: order_by
  hk_geom_point: order_by
  hk_kanton: order_by
  hk_land: order_by
  id: order_by
  ku_erhaltungskultur: order_by
  ku_zwischenlager: order_by
  li_show_sl: order_by
  li_show_sl_felder: order_by
  person: person_order_by
  person_id: order_by
  sl_auto_copy_edits: order_by
  sl_show_empty_when_next_to_li: order_by
  tree_event: order_by
  tree_kultur: order_by
  tree_lieferung: order_by
  tree_teilkultur: order_by
  tree_zaehlung: order_by
}

# primary key columns input for table: "person_option_rev"
input person_option_rev_pk_columns_input {
  id: ID!
}

# select columns of table "person_option_rev"
enum person_option_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ar_name_deutsch

  # column name
  changed

  # column name
  changed_by

  # column name
  ga_aktiv

  # column name
  ga_bemerkungen

  # column name
  ga_geom_point

  # column name
  ga_lat_lng

  # column name
  ga_ort

  # column name
  ga_plz

  # column name
  ga_strasse

  # column name
  hk_bemerkungen

  # column name
  hk_geom_point

  # column name
  hk_kanton

  # column name
  hk_land

  # column name
  id

  # column name
  ku_erhaltungskultur

  # column name
  ku_zwischenlager

  # column name
  li_show_sl

  # column name
  li_show_sl_felder

  # column name
  person_id

  # column name
  sl_auto_copy_edits

  # column name
  sl_show_empty_when_next_to_li

  # column name
  tree_event

  # column name
  tree_kultur

  # column name
  tree_lieferung

  # column name
  tree_teilkultur

  # column name
  tree_zaehlung
}

# input type for updating data in table "person_option_rev"
input person_option_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean
  li_show_sl: Boolean
  li_show_sl_felder: Boolean
  person_id: uuid
  sl_auto_copy_edits: Boolean
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregate stddev on columns
type person_option_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "person_option_rev"
input person_option_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type person_option_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "person_option_rev"
input person_option_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type person_option_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "person_option_rev"
input person_option_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type person_option_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "person_option_rev"
input person_option_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "person_option_rev"
enum person_option_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ar_name_deutsch

  # column name
  changed

  # column name
  changed_by

  # column name
  ga_aktiv

  # column name
  ga_bemerkungen

  # column name
  ga_geom_point

  # column name
  ga_lat_lng

  # column name
  ga_ort

  # column name
  ga_plz

  # column name
  ga_strasse

  # column name
  hk_bemerkungen

  # column name
  hk_geom_point

  # column name
  hk_kanton

  # column name
  hk_land

  # column name
  id

  # column name
  ku_erhaltungskultur

  # column name
  ku_zwischenlager

  # column name
  li_show_sl

  # column name
  li_show_sl_felder

  # column name
  person_id

  # column name
  sl_auto_copy_edits

  # column name
  sl_show_empty_when_next_to_li

  # column name
  tree_event

  # column name
  tree_kultur

  # column name
  tree_lieferung

  # column name
  tree_teilkultur

  # column name
  tree_zaehlung
}

# aggregate var_pop on columns
type person_option_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "person_option_rev"
input person_option_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type person_option_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "person_option_rev"
input person_option_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type person_option_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "person_option_rev"
input person_option_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "person_option"
enum person_option_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ar_name_deutsch

  # column name
  changed

  # column name
  changed_by

  # column name
  ga_aktiv

  # column name
  ga_bemerkungen

  # column name
  ga_geom_point

  # column name
  ga_lat_lng

  # column name
  ga_ort

  # column name
  ga_plz

  # column name
  ga_strasse

  # column name
  hk_bemerkungen

  # column name
  hk_geom_point

  # column name
  hk_kanton

  # column name
  hk_land

  # column name
  id

  # column name
  ku_erhaltungskultur

  # column name
  ku_zwischenlager

  # column name
  li_show_sl

  # column name
  li_show_sl_felder

  # column name
  sl_auto_copy_edits

  # column name
  sl_show_empty_when_next_to_li

  # column name
  tree_event

  # column name
  tree_kultur

  # column name
  tree_lieferung

  # column name
  tree_teilkultur

  # column name
  tree_zaehlung
}

# input type for updating data in table "person_option"
input person_option_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  ar_name_deutsch: Boolean
  changed: timestamp
  changed_by: String
  ga_aktiv: Boolean
  ga_bemerkungen: Boolean
  ga_geom_point: Boolean
  ga_lat_lng: Boolean
  ga_ort: Boolean
  ga_plz: Boolean
  ga_strasse: Boolean
  hk_bemerkungen: Boolean
  hk_geom_point: Boolean
  hk_kanton: Boolean
  hk_land: Boolean
  id: ID
  ku_erhaltungskultur: Boolean
  ku_zwischenlager: Boolean
  li_show_sl: Boolean
  li_show_sl_felder: Boolean
  sl_auto_copy_edits: Boolean
  sl_show_empty_when_next_to_li: Boolean
  tree_event: Boolean
  tree_kultur: Boolean
  tree_lieferung: Boolean
  tree_teilkultur: Boolean
  tree_zaehlung: Boolean
}

# aggregate stddev on columns
type person_option_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "person_option"
input person_option_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type person_option_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "person_option"
input person_option_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type person_option_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "person_option"
input person_option_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type person_option_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "person_option"
input person_option_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "person_option"
enum person_option_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  ar_name_deutsch

  # column name
  changed

  # column name
  changed_by

  # column name
  ga_aktiv

  # column name
  ga_bemerkungen

  # column name
  ga_geom_point

  # column name
  ga_lat_lng

  # column name
  ga_ort

  # column name
  ga_plz

  # column name
  ga_strasse

  # column name
  hk_bemerkungen

  # column name
  hk_geom_point

  # column name
  hk_kanton

  # column name
  hk_land

  # column name
  id

  # column name
  ku_erhaltungskultur

  # column name
  ku_zwischenlager

  # column name
  li_show_sl

  # column name
  li_show_sl_felder

  # column name
  sl_auto_copy_edits

  # column name
  sl_show_empty_when_next_to_li

  # column name
  tree_event

  # column name
  tree_kultur

  # column name
  tree_lieferung

  # column name
  tree_teilkultur

  # column name
  tree_zaehlung
}

# aggregate var_pop on columns
type person_option_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "person_option"
input person_option_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type person_option_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "person_option"
input person_option_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type person_option_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "person_option"
input person_option_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# ordering options when selecting data from "person"
input person_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  account_id: order_by
  adresszusatz: order_by
  aktiv: order_by
  avs_aggregate: av_aggregate_order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  event_revs_aggregate: event_rev_aggregate_order_by
  events_aggregate: event_aggregate_order_by
  garten_revs_aggregate: garten_rev_aggregate_order_by
  gartens_aggregate: garten_aggregate_order_by
  gvs_aggregate: gv_aggregate_order_by
  id: order_by
  info: order_by
  kein_email: order_by
  kommerziell: order_by
  lieferung_revs_aggregate: lieferung_rev_aggregate_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  name: order_by
  nr: order_by
  ort: order_by
  person_files_aggregate: person_file_aggregate_order_by
  person_option: person_option_order_by
  person_option_revs_aggregate: person_option_rev_aggregate_order_by
  plz: order_by
  sammel_lieferung_revs_aggregate: sammel_lieferung_rev_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlung_revs_aggregate: sammlung_rev_aggregate_order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# primary key columns input for table: "person"
input person_pk_columns_input {
  id: ID!
}

# columns and relationships of "person_rev"
type person_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean

  # An array relationship
  av(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # An aggregated array relationship
  av_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # An array relationship
  gartens(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): [garten!]!

  # An aggregated array relationship
  gartens_aggregate(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): garten_aggregate!
  id: ID!
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean
  name: String
  nr: String
  ort: String

  # An array relationship
  person_files(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): [person_file!]!

  # An aggregated array relationship
  person_files_aggregate(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): person_file_aggregate!
  person_id: uuid!

  # An object relationship
  person_option: person_option
  plz: Int

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammlungs(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # An aggregated array relationship
  sammlungs_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregated selection of "person_rev"
type person_rev_aggregate {
  aggregate: person_rev_aggregate_fields
  nodes: [person_rev!]!
}

# aggregate fields of "person_rev"
type person_rev_aggregate_fields {
  avg: person_rev_avg_fields
  count(columns: [person_rev_select_column!], distinct: Boolean): Int
  max: person_rev_max_fields
  min: person_rev_min_fields
  stddev: person_rev_stddev_fields
  stddev_pop: person_rev_stddev_pop_fields
  stddev_samp: person_rev_stddev_samp_fields
  sum: person_rev_sum_fields
  var_pop: person_rev_var_pop_fields
  var_samp: person_rev_var_samp_fields
  variance: person_rev_variance_fields
}

# order by aggregate values of table "person_rev"
input person_rev_aggregate_order_by {
  avg: person_rev_avg_order_by
  count: order_by
  max: person_rev_max_order_by
  min: person_rev_min_order_by
  stddev: person_rev_stddev_order_by
  stddev_pop: person_rev_stddev_pop_order_by
  stddev_samp: person_rev_stddev_samp_order_by
  sum: person_rev_sum_order_by
  var_pop: person_rev_var_pop_order_by
  var_samp: person_rev_var_samp_order_by
  variance: person_rev_variance_order_by
}

# input type for inserting array relation for remote table "person_rev"
input person_rev_arr_rel_insert_input {
  data: [person_rev_insert_input!]!
  on_conflict: person_rev_on_conflict
}

# aggregate avg on columns
type person_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by avg() on columns of table "person_rev"
input person_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# Boolean expression to filter rows from the table "person_rev". All fields are combined with a logical 'AND'.
input person_rev_bool_exp {
  _and: [person_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: person_rev_bool_exp
  _or: [person_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  account_id: String_comparison_exp
  adresszusatz: String_comparison_exp
  aktiv: Boolean_comparison_exp
  av: av_bool_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  email: String_comparison_exp
  events: event_bool_exp
  gartens: garten_bool_exp
  id: uuid_comparison_exp
  info: Boolean_comparison_exp
  kein_email: Boolean_comparison_exp
  kommerziell: Boolean_comparison_exp
  name: String_comparison_exp
  nr: String_comparison_exp
  ort: String_comparison_exp
  person_files: person_file_bool_exp
  person_id: uuid_comparison_exp
  person_option: person_option_bool_exp
  plz: Int_comparison_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlungs: sammlung_bool_exp
  strasse: String_comparison_exp
  telefon_geschaeft: String_comparison_exp
  telefon_mobile: String_comparison_exp
  telefon_privat: String_comparison_exp
  user_role_id: uuid_comparison_exp
  vorname: String_comparison_exp
}

# unique or primary key constraints on table "person_rev"
enum person_rev_constraint {
  # unique or primary key constraint
  person_rev_pkey
}

# input type for incrementing integer column in table "person_rev"
input person_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# input type for inserting data into table "person_rev"
input person_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean
  av: av_arr_rel_insert_input
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  events: event_arr_rel_insert_input
  gartens: garten_arr_rel_insert_input
  id: ID
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean
  name: String
  nr: String
  ort: String
  person_files: person_file_arr_rel_insert_input
  person_id: uuid
  person_option: person_option_obj_rel_insert_input
  plz: Int
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlungs: sammlung_arr_rel_insert_input
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregate max on columns
type person_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  account_id: String
  adresszusatz: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  name: String
  nr: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# order by max() on columns of table "person_rev"
input person_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  account_id: order_by
  adresszusatz: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  id: order_by
  name: order_by
  nr: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# aggregate min on columns
type person_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  account_id: String
  adresszusatz: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  name: String
  nr: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# order by min() on columns of table "person_rev"
input person_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  account_id: order_by
  adresszusatz: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  id: order_by
  name: order_by
  nr: order_by
  ort: order_by
  person_id: order_by
  plz: order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# response of any mutation on the table "person_rev"
type person_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [person_rev!]!
}

# input type for inserting object relation for remote table "person_rev"
input person_rev_obj_rel_insert_input {
  data: person_rev_insert_input!
  on_conflict: person_rev_on_conflict
}

# on conflict condition type for table "person_rev"
input person_rev_on_conflict {
  constraint: person_rev_constraint!
  update_columns: [person_rev_update_column!]!
  where: person_rev_bool_exp
}

# ordering options when selecting data from "person_rev"
input person_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  account_id: order_by
  adresszusatz: order_by
  aktiv: order_by
  av_aggregate: av_aggregate_order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  email: order_by
  events_aggregate: event_aggregate_order_by
  gartens_aggregate: garten_aggregate_order_by
  id: order_by
  info: order_by
  kein_email: order_by
  kommerziell: order_by
  name: order_by
  nr: order_by
  ort: order_by
  person_files_aggregate: person_file_aggregate_order_by
  person_id: order_by
  person_option: person_option_order_by
  plz: order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlungs_aggregate: sammlung_aggregate_order_by
  strasse: order_by
  telefon_geschaeft: order_by
  telefon_mobile: order_by
  telefon_privat: order_by
  user_role_id: order_by
  vorname: order_by
}

# primary key columns input for table: "person_rev"
input person_rev_pk_columns_input {
  id: ID!
}

# select columns of table "person_rev"
enum person_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  account_id

  # column name
  adresszusatz

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  email

  # column name
  id

  # column name
  info

  # column name
  kein_email

  # column name
  kommerziell

  # column name
  name

  # column name
  nr

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse

  # column name
  telefon_geschaeft

  # column name
  telefon_mobile

  # column name
  telefon_privat

  # column name
  user_role_id

  # column name
  vorname
}

# input type for updating data in table "person_rev"
input person_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean
  name: String
  nr: String
  ort: String
  person_id: uuid
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregate stddev on columns
type person_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev() on columns of table "person_rev"
input person_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_pop on columns
type person_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_pop() on columns of table "person_rev"
input person_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_samp on columns
type person_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_samp() on columns of table "person_rev"
input person_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate sum on columns
type person_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# order by sum() on columns of table "person_rev"
input person_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# update columns of table "person_rev"
enum person_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  account_id

  # column name
  adresszusatz

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  email

  # column name
  id

  # column name
  info

  # column name
  kein_email

  # column name
  kommerziell

  # column name
  name

  # column name
  nr

  # column name
  ort

  # column name
  person_id

  # column name
  plz

  # column name
  strasse

  # column name
  telefon_geschaeft

  # column name
  telefon_mobile

  # column name
  telefon_privat

  # column name
  user_role_id

  # column name
  vorname
}

# aggregate var_pop on columns
type person_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_pop() on columns of table "person_rev"
input person_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate var_samp on columns
type person_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_samp() on columns of table "person_rev"
input person_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate variance on columns
type person_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by variance() on columns of table "person_rev"
input person_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# select columns of table "person"
enum person_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  account_id

  # column name
  adresszusatz

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  email

  # column name
  id

  # column name
  info

  # column name
  kein_email

  # column name
  kommerziell

  # column name
  name

  # column name
  nr

  # column name
  ort

  # column name
  plz

  # column name
  strasse

  # column name
  telefon_geschaeft

  # column name
  telefon_mobile

  # column name
  telefon_privat

  # column name
  user_role_id

  # column name
  vorname
}

# input type for updating data in table "person"
input person_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  account_id: String
  adresszusatz: String
  aktiv: Boolean
  bemerkungen: String
  changed: timestamp
  changed_by: String
  email: String
  id: ID
  info: Boolean
  kein_email: Boolean
  kommerziell: Boolean
  name: String
  nr: String
  ort: String
  plz: Int
  strasse: String
  telefon_geschaeft: String
  telefon_mobile: String
  telefon_privat: String
  user_role_id: uuid
  vorname: String
}

# aggregate stddev on columns
type person_stddev_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev() on columns of table "person"
input person_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_pop on columns
type person_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_pop() on columns of table "person"
input person_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate stddev_samp on columns
type person_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by stddev_samp() on columns of table "person"
input person_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate sum on columns
type person_sum_fields {
  _depth: Int
  _rev_at: numeric
  plz: Int
}

# order by sum() on columns of table "person"
input person_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# update columns of table "person"
enum person_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  account_id

  # column name
  adresszusatz

  # column name
  aktiv

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  email

  # column name
  id

  # column name
  info

  # column name
  kein_email

  # column name
  kommerziell

  # column name
  name

  # column name
  nr

  # column name
  ort

  # column name
  plz

  # column name
  strasse

  # column name
  telefon_geschaeft

  # column name
  telefon_mobile

  # column name
  telefon_privat

  # column name
  user_role_id

  # column name
  vorname
}

# aggregate var_pop on columns
type person_var_pop_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_pop() on columns of table "person"
input person_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate var_samp on columns
type person_var_samp_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by var_samp() on columns of table "person"
input person_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# aggregate variance on columns
type person_variance_fields {
  _depth: Float
  _rev_at: Float
  plz: Float
}

# order by variance() on columns of table "person"
input person_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  plz: order_by
}

# query root
type query_root {
  # fetch data from the table: "ae_art"
  ae_art(
    # distinct select on columns
    distinct_on: [ae_art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ae_art_order_by!]

    # filter the rows returned
    where: ae_art_bool_exp
  ): [ae_art!]!

  # fetch aggregated fields from the table: "ae_art"
  ae_art_aggregate(
    # distinct select on columns
    distinct_on: [ae_art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ae_art_order_by!]

    # filter the rows returned
    where: ae_art_bool_exp
  ): ae_art_aggregate!

  # fetch data from the table: "ae_art" using primary key columns
  ae_art_by_pk(id: ID!): ae_art

  # fetch data from the table: "art"
  art(
    # distinct select on columns
    distinct_on: [art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_order_by!]

    # filter the rows returned
    where: art_bool_exp
  ): [art!]!

  # fetch aggregated fields from the table: "art"
  art_aggregate(
    # distinct select on columns
    distinct_on: [art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_order_by!]

    # filter the rows returned
    where: art_bool_exp
  ): art_aggregate!

  # fetch data from the table: "art" using primary key columns
  art_by_pk(id: ID!): art

  # fetch data from the table: "art_file"
  art_file(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): [art_file!]!

  # fetch aggregated fields from the table: "art_file"
  art_file_aggregate(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): art_file_aggregate!

  # fetch data from the table: "art_file" using primary key columns
  art_file_by_pk(id: ID!): art_file

  # fetch data from the table: "art_qk"
  art_qk(
    # distinct select on columns
    distinct_on: [art_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_order_by!]

    # filter the rows returned
    where: art_qk_bool_exp
  ): [art_qk!]!

  # fetch aggregated fields from the table: "art_qk"
  art_qk_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_order_by!]

    # filter the rows returned
    where: art_qk_bool_exp
  ): art_qk_aggregate!

  # fetch data from the table: "art_qk" using primary key columns
  art_qk_by_pk(id: ID!): art_qk

  # fetch data from the table: "art_qk_choosen"
  art_qk_choosen(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): [art_qk_choosen!]!

  # fetch aggregated fields from the table: "art_qk_choosen"
  art_qk_choosen_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): art_qk_choosen_aggregate!

  # fetch data from the table: "art_qk_choosen" using primary key columns
  art_qk_choosen_by_pk(id: ID!): art_qk_choosen

  # fetch data from the table: "art_qk_choosen_rev"
  art_qk_choosen_rev(
    # distinct select on columns
    distinct_on: [art_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: art_qk_choosen_rev_bool_exp
  ): [art_qk_choosen_rev!]!

  # fetch aggregated fields from the table: "art_qk_choosen_rev"
  art_qk_choosen_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: art_qk_choosen_rev_bool_exp
  ): art_qk_choosen_rev_aggregate!

  # fetch data from the table: "art_qk_choosen_rev" using primary key columns
  art_qk_choosen_rev_by_pk(id: ID!): art_qk_choosen_rev

  # fetch data from the table: "art_qk_rev"
  art_qk_rev(
    # distinct select on columns
    distinct_on: [art_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_rev_order_by!]

    # filter the rows returned
    where: art_qk_rev_bool_exp
  ): [art_qk_rev!]!

  # fetch aggregated fields from the table: "art_qk_rev"
  art_qk_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_rev_order_by!]

    # filter the rows returned
    where: art_qk_rev_bool_exp
  ): art_qk_rev_aggregate!

  # fetch data from the table: "art_qk_rev" using primary key columns
  art_qk_rev_by_pk(id: ID!): art_qk_rev

  # fetch data from the table: "art_rev"
  art_rev(
    # distinct select on columns
    distinct_on: [art_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_rev_order_by!]

    # filter the rows returned
    where: art_rev_bool_exp
  ): [art_rev!]!

  # fetch aggregated fields from the table: "art_rev"
  art_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_rev_order_by!]

    # filter the rows returned
    where: art_rev_bool_exp
  ): art_rev_aggregate!

  # fetch data from the table: "art_rev" using primary key columns
  art_rev_by_pk(id: ID!): art_rev

  # fetch data from the table: "av"
  av(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # fetch aggregated fields from the table: "av"
  av_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!

  # fetch data from the table: "av" using primary key columns
  av_by_pk(id: ID!): av

  # fetch data from the table: "av_rev"
  av_rev(
    # distinct select on columns
    distinct_on: [av_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_rev_order_by!]

    # filter the rows returned
    where: av_rev_bool_exp
  ): [av_rev!]!

  # fetch aggregated fields from the table: "av_rev"
  av_rev_aggregate(
    # distinct select on columns
    distinct_on: [av_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_rev_order_by!]

    # filter the rows returned
    where: av_rev_bool_exp
  ): av_rev_aggregate!

  # fetch data from the table: "av_rev" using primary key columns
  av_rev_by_pk(id: ID!): av_rev

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event" using primary key columns
  event_by_pk(id: ID!): event

  # fetch data from the table: "event_rev"
  event_rev(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): [event_rev!]!

  # fetch aggregated fields from the table: "event_rev"
  event_rev_aggregate(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): event_rev_aggregate!

  # fetch data from the table: "event_rev" using primary key columns
  event_rev_by_pk(id: ID!): event_rev

  # fetch data from the table: "garten"
  garten(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): [garten!]!

  # fetch aggregated fields from the table: "garten"
  garten_aggregate(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): garten_aggregate!

  # fetch data from the table: "garten" using primary key columns
  garten_by_pk(id: ID!): garten

  # fetch data from the table: "garten_file"
  garten_file(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): [garten_file!]!

  # fetch aggregated fields from the table: "garten_file"
  garten_file_aggregate(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): garten_file_aggregate!

  # fetch data from the table: "garten_file" using primary key columns
  garten_file_by_pk(id: ID!): garten_file

  # fetch data from the table: "garten_rev"
  garten_rev(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): [garten_rev!]!

  # fetch aggregated fields from the table: "garten_rev"
  garten_rev_aggregate(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): garten_rev_aggregate!

  # fetch data from the table: "garten_rev" using primary key columns
  garten_rev_by_pk(id: ID!): garten_rev

  # fetch data from the table: "gv"
  gv(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): [gv!]!

  # fetch aggregated fields from the table: "gv"
  gv_aggregate(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): gv_aggregate!

  # fetch data from the table: "gv" using primary key columns
  gv_by_pk(id: ID!): gv

  # fetch data from the table: "gv_rev"
  gv_rev(
    # distinct select on columns
    distinct_on: [gv_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_rev_order_by!]

    # filter the rows returned
    where: gv_rev_bool_exp
  ): [gv_rev!]!

  # fetch aggregated fields from the table: "gv_rev"
  gv_rev_aggregate(
    # distinct select on columns
    distinct_on: [gv_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_rev_order_by!]

    # filter the rows returned
    where: gv_rev_bool_exp
  ): gv_rev_aggregate!

  # fetch data from the table: "gv_rev" using primary key columns
  gv_rev_by_pk(id: ID!): gv_rev

  # fetch data from the table: "herkunft"
  herkunft(
    # distinct select on columns
    distinct_on: [herkunft_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_order_by!]

    # filter the rows returned
    where: herkunft_bool_exp
  ): [herkunft!]!

  # fetch aggregated fields from the table: "herkunft"
  herkunft_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_order_by!]

    # filter the rows returned
    where: herkunft_bool_exp
  ): herkunft_aggregate!

  # fetch data from the table: "herkunft" using primary key columns
  herkunft_by_pk(id: ID!): herkunft

  # fetch data from the table: "herkunft_file"
  herkunft_file(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): [herkunft_file!]!

  # fetch aggregated fields from the table: "herkunft_file"
  herkunft_file_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): herkunft_file_aggregate!

  # fetch data from the table: "herkunft_file" using primary key columns
  herkunft_file_by_pk(id: ID!): herkunft_file

  # fetch data from the table: "herkunft_rev"
  herkunft_rev(
    # distinct select on columns
    distinct_on: [herkunft_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_rev_order_by!]

    # filter the rows returned
    where: herkunft_rev_bool_exp
  ): [herkunft_rev!]!

  # fetch aggregated fields from the table: "herkunft_rev"
  herkunft_rev_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_rev_order_by!]

    # filter the rows returned
    where: herkunft_rev_bool_exp
  ): herkunft_rev_aggregate!

  # fetch data from the table: "herkunft_rev" using primary key columns
  herkunft_rev_by_pk(id: ID!): herkunft_rev

  # fetch data from the table: "kultur"
  kultur(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # fetch aggregated fields from the table: "kultur"
  kultur_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!

  # fetch data from the table: "kultur" using primary key columns
  kultur_by_pk(id: ID!): kultur

  # fetch data from the table: "kultur_file"
  kultur_file(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): [kultur_file!]!

  # fetch aggregated fields from the table: "kultur_file"
  kultur_file_aggregate(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): kultur_file_aggregate!

  # fetch data from the table: "kultur_file" using primary key columns
  kultur_file_by_pk(id: ID!): kultur_file

  # fetch data from the table: "kultur_option"
  kultur_option(
    # distinct select on columns
    distinct_on: [kultur_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_order_by!]

    # filter the rows returned
    where: kultur_option_bool_exp
  ): [kultur_option!]!

  # fetch aggregated fields from the table: "kultur_option"
  kultur_option_aggregate(
    # distinct select on columns
    distinct_on: [kultur_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_order_by!]

    # filter the rows returned
    where: kultur_option_bool_exp
  ): kultur_option_aggregate!

  # fetch data from the table: "kultur_option_rev"
  kultur_option_rev(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): [kultur_option_rev!]!

  # fetch aggregated fields from the table: "kultur_option_rev"
  kultur_option_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): kultur_option_rev_aggregate!

  # fetch data from the table: "kultur_option_rev" using primary key columns
  kultur_option_rev_by_pk(id: ID!): kultur_option_rev

  # fetch data from the table: "kultur_qk"
  kultur_qk(
    # distinct select on columns
    distinct_on: [kultur_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_order_by!]

    # filter the rows returned
    where: kultur_qk_bool_exp
  ): [kultur_qk!]!

  # fetch aggregated fields from the table: "kultur_qk"
  kultur_qk_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_order_by!]

    # filter the rows returned
    where: kultur_qk_bool_exp
  ): kultur_qk_aggregate!

  # fetch data from the table: "kultur_qk" using primary key columns
  kultur_qk_by_pk(id: ID!): kultur_qk

  # fetch data from the table: "kultur_qk_choosen"
  kultur_qk_choosen(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): [kultur_qk_choosen!]!

  # fetch aggregated fields from the table: "kultur_qk_choosen"
  kultur_qk_choosen_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): kultur_qk_choosen_aggregate!

  # fetch data from the table: "kultur_qk_choosen" using primary key columns
  kultur_qk_choosen_by_pk(id: ID!): kultur_qk_choosen

  # fetch data from the table: "kultur_qk_choosen_rev"
  kultur_qk_choosen_rev(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_rev_bool_exp
  ): [kultur_qk_choosen_rev!]!

  # fetch aggregated fields from the table: "kultur_qk_choosen_rev"
  kultur_qk_choosen_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_rev_bool_exp
  ): kultur_qk_choosen_rev_aggregate!

  # fetch data from the table: "kultur_qk_choosen_rev" using primary key columns
  kultur_qk_choosen_rev_by_pk(id: ID!): kultur_qk_choosen_rev

  # fetch data from the table: "kultur_qk_rev"
  kultur_qk_rev(
    # distinct select on columns
    distinct_on: [kultur_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_rev_bool_exp
  ): [kultur_qk_rev!]!

  # fetch aggregated fields from the table: "kultur_qk_rev"
  kultur_qk_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_rev_bool_exp
  ): kultur_qk_rev_aggregate!

  # fetch data from the table: "kultur_qk_rev" using primary key columns
  kultur_qk_rev_by_pk(name: String!): kultur_qk_rev

  # fetch data from the table: "kultur_rev"
  kultur_rev(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): [kultur_rev!]!

  # fetch aggregated fields from the table: "kultur_rev"
  kultur_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): kultur_rev_aggregate!

  # fetch data from the table: "kultur_rev" using primary key columns
  kultur_rev_by_pk(id: ID!): kultur_rev

  # fetch data from the table: "lieferung"
  lieferung(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # fetch aggregated fields from the table: "lieferung"
  lieferung_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # fetch data from the table: "lieferung" using primary key columns
  lieferung_by_pk(id: ID!): lieferung

  # fetch data from the table: "lieferung_file"
  lieferung_file(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): [lieferung_file!]!

  # fetch aggregated fields from the table: "lieferung_file"
  lieferung_file_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): lieferung_file_aggregate!

  # fetch data from the table: "lieferung_file" using primary key columns
  lieferung_file_by_pk(id: ID!): lieferung_file

  # fetch data from the table: "lieferung_rev"
  lieferung_rev(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # fetch aggregated fields from the table: "lieferung_rev"
  lieferung_rev_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # fetch data from the table: "lieferung_rev" using primary key columns
  lieferung_rev_by_pk(id: ID!): lieferung_rev

  # fetch data from the table: "person"
  person(
    # distinct select on columns
    distinct_on: [person_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_order_by!]

    # filter the rows returned
    where: person_bool_exp
  ): [person!]!

  # fetch aggregated fields from the table: "person"
  person_aggregate(
    # distinct select on columns
    distinct_on: [person_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_order_by!]

    # filter the rows returned
    where: person_bool_exp
  ): person_aggregate!

  # fetch data from the table: "person" using primary key columns
  person_by_pk(id: ID!): person

  # fetch data from the table: "person_file"
  person_file(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): [person_file!]!

  # fetch aggregated fields from the table: "person_file"
  person_file_aggregate(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): person_file_aggregate!

  # fetch data from the table: "person_file" using primary key columns
  person_file_by_pk(id: ID!): person_file

  # fetch data from the table: "person_option"
  person_option(
    # distinct select on columns
    distinct_on: [person_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_order_by!]

    # filter the rows returned
    where: person_option_bool_exp
  ): [person_option!]!

  # fetch aggregated fields from the table: "person_option"
  person_option_aggregate(
    # distinct select on columns
    distinct_on: [person_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_order_by!]

    # filter the rows returned
    where: person_option_bool_exp
  ): person_option_aggregate!

  # fetch data from the table: "person_option_rev"
  person_option_rev(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): [person_option_rev!]!

  # fetch aggregated fields from the table: "person_option_rev"
  person_option_rev_aggregate(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): person_option_rev_aggregate!

  # fetch data from the table: "person_option_rev" using primary key columns
  person_option_rev_by_pk(id: ID!): person_option_rev

  # fetch data from the table: "person_rev"
  person_rev(
    # distinct select on columns
    distinct_on: [person_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_rev_order_by!]

    # filter the rows returned
    where: person_rev_bool_exp
  ): [person_rev!]!

  # fetch aggregated fields from the table: "person_rev"
  person_rev_aggregate(
    # distinct select on columns
    distinct_on: [person_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_rev_order_by!]

    # filter the rows returned
    where: person_rev_bool_exp
  ): person_rev_aggregate!

  # fetch data from the table: "person_rev" using primary key columns
  person_rev_by_pk(id: ID!): person_rev

  # fetch data from the table: "sammel_lieferung"
  sammel_lieferung(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # fetch aggregated fields from the table: "sammel_lieferung"
  sammel_lieferung_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # fetch data from the table: "sammel_lieferung" using primary key columns
  sammel_lieferung_by_pk(id: ID!): sammel_lieferung

  # fetch data from the table: "sammel_lieferung_rev"
  sammel_lieferung_rev(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # fetch aggregated fields from the table: "sammel_lieferung_rev"
  sammel_lieferung_rev_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # fetch data from the table: "sammel_lieferung_rev" using primary key columns
  sammel_lieferung_rev_by_pk(id: ID!): sammel_lieferung_rev

  # fetch data from the table: "sammlung"
  sammlung(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # fetch aggregated fields from the table: "sammlung"
  sammlung_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!

  # fetch data from the table: "sammlung" using primary key columns
  sammlung_by_pk(id: ID!): sammlung

  # fetch data from the table: "sammlung_file"
  sammlung_file(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): [sammlung_file!]!

  # fetch aggregated fields from the table: "sammlung_file"
  sammlung_file_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): sammlung_file_aggregate!

  # fetch data from the table: "sammlung_file" using primary key columns
  sammlung_file_by_pk(id: ID!): sammlung_file

  # fetch data from the table: "sammlung_rev"
  sammlung_rev(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): [sammlung_rev!]!

  # fetch aggregated fields from the table: "sammlung_rev"
  sammlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): sammlung_rev_aggregate!

  # fetch data from the table: "sammlung_rev" using primary key columns
  sammlung_rev_by_pk(id: ID!): sammlung_rev

  # fetch data from the table: "spatial_ref_sys"
  spatial_ref_sys(
    # distinct select on columns
    distinct_on: [spatial_ref_sys_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [spatial_ref_sys_order_by!]

    # filter the rows returned
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  # fetch aggregated fields from the table: "spatial_ref_sys"
  spatial_ref_sys_aggregate(
    # distinct select on columns
    distinct_on: [spatial_ref_sys_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [spatial_ref_sys_order_by!]

    # filter the rows returned
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  # fetch data from the table: "spatial_ref_sys" using primary key columns
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  # fetch data from the table: "teilkultur"
  teilkultur(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): [teilkultur!]!

  # fetch aggregated fields from the table: "teilkultur"
  teilkultur_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): teilkultur_aggregate!

  # fetch data from the table: "teilkultur" using primary key columns
  teilkultur_by_pk(id: ID!): teilkultur

  # fetch data from the table: "teilkultur_rev"
  teilkultur_rev(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): [teilkultur_rev!]!

  # fetch aggregated fields from the table: "teilkultur_rev"
  teilkultur_rev_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): teilkultur_rev_aggregate!

  # fetch data from the table: "teilkultur_rev" using primary key columns
  teilkultur_rev_by_pk(id: ID!): teilkultur_rev

  # fetch data from the table: "teilzaehlung"
  teilzaehlung(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # fetch aggregated fields from the table: "teilzaehlung"
  teilzaehlung_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!

  # fetch data from the table: "teilzaehlung" using primary key columns
  teilzaehlung_by_pk(id: ID!): teilzaehlung

  # fetch data from the table: "teilzaehlung_rev"
  teilzaehlung_rev(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): [teilzaehlung_rev!]!

  # fetch aggregated fields from the table: "teilzaehlung_rev"
  teilzaehlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): teilzaehlung_rev_aggregate!

  # fetch data from the table: "teilzaehlung_rev" using primary key columns
  teilzaehlung_rev_by_pk(id: ID!): teilzaehlung_rev

  # fetch data from the table: "user_role"
  user_role(
    # distinct select on columns
    distinct_on: [user_role_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_role_order_by!]

    # filter the rows returned
    where: user_role_bool_exp
  ): [user_role!]!

  # fetch aggregated fields from the table: "user_role"
  user_role_aggregate(
    # distinct select on columns
    distinct_on: [user_role_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_role_order_by!]

    # filter the rows returned
    where: user_role_bool_exp
  ): user_role_aggregate!

  # fetch data from the table: "user_role" using primary key columns
  user_role_by_pk(id: ID!): user_role

  # fetch data from the table: "zaehlung"
  zaehlung(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): [zaehlung!]!

  # fetch aggregated fields from the table: "zaehlung"
  zaehlung_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): zaehlung_aggregate!

  # fetch data from the table: "zaehlung" using primary key columns
  zaehlung_by_pk(id: ID!): zaehlung

  # fetch data from the table: "zaehlung_rev"
  zaehlung_rev(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): [zaehlung_rev!]!

  # fetch aggregated fields from the table: "zaehlung_rev"
  zaehlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): zaehlung_rev_aggregate!

  # fetch data from the table: "zaehlung_rev" using primary key columns
  zaehlung_rev_by_pk(id: ID!): zaehlung_rev
}

# columns and relationships of "sammel_lieferung"
type sammel_lieferung {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID!

  # An object relationship
  kulturByNachKulturId: kultur

  # An object relationship
  kulturByVonKulturId: kultur

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid

  # An object relationship
  sammlung: sammlung
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregated selection of "sammel_lieferung"
type sammel_lieferung_aggregate {
  aggregate: sammel_lieferung_aggregate_fields
  nodes: [sammel_lieferung!]!
}

# aggregate fields of "sammel_lieferung"
type sammel_lieferung_aggregate_fields {
  avg: sammel_lieferung_avg_fields
  count(columns: [sammel_lieferung_select_column!], distinct: Boolean): Int
  max: sammel_lieferung_max_fields
  min: sammel_lieferung_min_fields
  stddev: sammel_lieferung_stddev_fields
  stddev_pop: sammel_lieferung_stddev_pop_fields
  stddev_samp: sammel_lieferung_stddev_samp_fields
  sum: sammel_lieferung_sum_fields
  var_pop: sammel_lieferung_var_pop_fields
  var_samp: sammel_lieferung_var_samp_fields
  variance: sammel_lieferung_variance_fields
}

# order by aggregate values of table "sammel_lieferung"
input sammel_lieferung_aggregate_order_by {
  avg: sammel_lieferung_avg_order_by
  count: order_by
  max: sammel_lieferung_max_order_by
  min: sammel_lieferung_min_order_by
  stddev: sammel_lieferung_stddev_order_by
  stddev_pop: sammel_lieferung_stddev_pop_order_by
  stddev_samp: sammel_lieferung_stddev_samp_order_by
  sum: sammel_lieferung_sum_order_by
  var_pop: sammel_lieferung_var_pop_order_by
  var_samp: sammel_lieferung_var_samp_order_by
  variance: sammel_lieferung_variance_order_by
}

# input type for inserting array relation for remote table "sammel_lieferung"
input sammel_lieferung_arr_rel_insert_input {
  data: [sammel_lieferung_insert_input!]!
  on_conflict: sammel_lieferung_on_conflict
}

# aggregate avg on columns
type sammel_lieferung_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "sammel_lieferung"
input sammel_lieferung_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "sammel_lieferung". All fields are combined with a logical 'AND'.
input sammel_lieferung_bool_exp {
  _and: [sammel_lieferung_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: sammel_lieferung_bool_exp
  _or: [sammel_lieferung_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  id: uuid_comparison_exp
  kulturByNachKulturId: kultur_bool_exp
  kulturByVonKulturId: kultur_bool_exp
  lieferungs: lieferung_bool_exp
  nach_ausgepflanzt: Boolean_comparison_exp
  nach_kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammlung: sammlung_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  von_kultur_id: uuid_comparison_exp
  von_sammlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "sammel_lieferung"
enum sammel_lieferung_constraint {
  # unique or primary key constraint
  sammel_lieferung_pkey
}

# input type for incrementing integer column in table "sammel_lieferung"
input sammel_lieferung_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "sammel_lieferung"
input sammel_lieferung_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  kulturByNachKulturId: kultur_obj_rel_insert_input
  kulturByVonKulturId: kultur_obj_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  sammlung: sammlung_obj_rel_insert_input
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate max on columns
type sammel_lieferung_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by max() on columns of table "sammel_lieferung"
input sammel_lieferung_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# aggregate min on columns
type sammel_lieferung_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by min() on columns of table "sammel_lieferung"
input sammel_lieferung_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# response of any mutation on the table "sammel_lieferung"
type sammel_lieferung_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sammel_lieferung!]!
}

# input type for inserting object relation for remote table "sammel_lieferung"
input sammel_lieferung_obj_rel_insert_input {
  data: sammel_lieferung_insert_input!
  on_conflict: sammel_lieferung_on_conflict
}

# on conflict condition type for table "sammel_lieferung"
input sammel_lieferung_on_conflict {
  constraint: sammel_lieferung_constraint!
  update_columns: [sammel_lieferung_update_column!]!
  where: sammel_lieferung_bool_exp
}

# ordering options when selecting data from "sammel_lieferung"
input sammel_lieferung_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geplant: order_by
  gramm_samen: order_by
  id: order_by
  kulturByNachKulturId: kultur_order_by
  kulturByVonKulturId: kultur_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  nach_ausgepflanzt: order_by
  nach_kultur_id: order_by
  person: person_order_by
  person_id: order_by
  sammlung: sammlung_order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# primary key columns input for table: "sammel_lieferung"
input sammel_lieferung_pk_columns_input {
  id: ID!
}

# columns and relationships of "sammel_lieferung_rev"
type sammel_lieferung_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID!

  # An object relationship
  kulturByNachKulturId: kultur

  # An object relationship
  kulturByVonKulturId: kultur

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid

  # An object relationship
  person: person
  person_id: uuid
  sammel_lieferung_id: uuid!

  # An object relationship
  sammlung: sammlung
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregated selection of "sammel_lieferung_rev"
type sammel_lieferung_rev_aggregate {
  aggregate: sammel_lieferung_rev_aggregate_fields
  nodes: [sammel_lieferung_rev!]!
}

# aggregate fields of "sammel_lieferung_rev"
type sammel_lieferung_rev_aggregate_fields {
  avg: sammel_lieferung_rev_avg_fields
  count(columns: [sammel_lieferung_rev_select_column!], distinct: Boolean): Int
  max: sammel_lieferung_rev_max_fields
  min: sammel_lieferung_rev_min_fields
  stddev: sammel_lieferung_rev_stddev_fields
  stddev_pop: sammel_lieferung_rev_stddev_pop_fields
  stddev_samp: sammel_lieferung_rev_stddev_samp_fields
  sum: sammel_lieferung_rev_sum_fields
  var_pop: sammel_lieferung_rev_var_pop_fields
  var_samp: sammel_lieferung_rev_var_samp_fields
  variance: sammel_lieferung_rev_variance_fields
}

# order by aggregate values of table "sammel_lieferung_rev"
input sammel_lieferung_rev_aggregate_order_by {
  avg: sammel_lieferung_rev_avg_order_by
  count: order_by
  max: sammel_lieferung_rev_max_order_by
  min: sammel_lieferung_rev_min_order_by
  stddev: sammel_lieferung_rev_stddev_order_by
  stddev_pop: sammel_lieferung_rev_stddev_pop_order_by
  stddev_samp: sammel_lieferung_rev_stddev_samp_order_by
  sum: sammel_lieferung_rev_sum_order_by
  var_pop: sammel_lieferung_rev_var_pop_order_by
  var_samp: sammel_lieferung_rev_var_samp_order_by
  variance: sammel_lieferung_rev_variance_order_by
}

# input type for inserting array relation for remote table "sammel_lieferung_rev"
input sammel_lieferung_rev_arr_rel_insert_input {
  data: [sammel_lieferung_rev_insert_input!]!
  on_conflict: sammel_lieferung_rev_on_conflict
}

# aggregate avg on columns
type sammel_lieferung_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "sammel_lieferung_rev". All fields are combined with a logical 'AND'.
input sammel_lieferung_rev_bool_exp {
  _and: [sammel_lieferung_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: sammel_lieferung_rev_bool_exp
  _or: [sammel_lieferung_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  id: uuid_comparison_exp
  kulturByNachKulturId: kultur_bool_exp
  kulturByVonKulturId: kultur_bool_exp
  lieferungs: lieferung_bool_exp
  nach_ausgepflanzt: Boolean_comparison_exp
  nach_kultur_id: uuid_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammel_lieferung_id: uuid_comparison_exp
  sammlung: sammlung_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  von_kultur_id: uuid_comparison_exp
  von_sammlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "sammel_lieferung_rev"
enum sammel_lieferung_rev_constraint {
  # unique or primary key constraint
  sammel_lieferung_rev_pkey
}

# input type for incrementing integer column in table "sammel_lieferung_rev"
input sammel_lieferung_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "sammel_lieferung_rev"
input sammel_lieferung_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  kulturByNachKulturId: kultur_obj_rel_insert_input
  kulturByVonKulturId: kultur_obj_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person: person_obj_rel_insert_input
  person_id: uuid
  sammel_lieferung_id: uuid
  sammlung: sammlung_obj_rel_insert_input
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate max on columns
type sammel_lieferung_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by max() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# aggregate min on columns
type sammel_lieferung_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  id: ID
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# order by min() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  id: order_by
  nach_kultur_id: order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# response of any mutation on the table "sammel_lieferung_rev"
type sammel_lieferung_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sammel_lieferung_rev!]!
}

# input type for inserting object relation for remote table "sammel_lieferung_rev"
input sammel_lieferung_rev_obj_rel_insert_input {
  data: sammel_lieferung_rev_insert_input!
  on_conflict: sammel_lieferung_rev_on_conflict
}

# on conflict condition type for table "sammel_lieferung_rev"
input sammel_lieferung_rev_on_conflict {
  constraint: sammel_lieferung_rev_constraint!
  update_columns: [sammel_lieferung_rev_update_column!]!
  where: sammel_lieferung_rev_bool_exp
}

# ordering options when selecting data from "sammel_lieferung_rev"
input sammel_lieferung_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geplant: order_by
  gramm_samen: order_by
  id: order_by
  kulturByNachKulturId: kultur_order_by
  kulturByVonKulturId: kultur_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  nach_ausgepflanzt: order_by
  nach_kultur_id: order_by
  person: person_order_by
  person_id: order_by
  sammel_lieferung_id: order_by
  sammlung: sammlung_order_by
  von_anzahl_individuen: order_by
  von_kultur_id: order_by
  von_sammlung_id: order_by
}

# primary key columns input for table: "sammel_lieferung_rev"
input sammel_lieferung_rev_pk_columns_input {
  id: ID!
}

# select columns of table "sammel_lieferung_rev"
enum sammel_lieferung_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# input type for updating data in table "sammel_lieferung_rev"
input sammel_lieferung_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person_id: uuid
  sammel_lieferung_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate stddev on columns
type sammel_lieferung_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type sammel_lieferung_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type sammel_lieferung_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type sammel_lieferung_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "sammel_lieferung_rev"
enum sammel_lieferung_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  sammel_lieferung_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# aggregate var_pop on columns
type sammel_lieferung_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type sammel_lieferung_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type sammel_lieferung_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "sammel_lieferung_rev"
input sammel_lieferung_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# select columns of table "sammel_lieferung"
enum sammel_lieferung_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# input type for updating data in table "sammel_lieferung"
input sammel_lieferung_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geplant: Boolean
  gramm_samen: numeric
  id: ID
  nach_ausgepflanzt: Boolean
  nach_kultur_id: uuid
  person_id: uuid
  von_anzahl_individuen: Int
  von_kultur_id: uuid
  von_sammlung_id: uuid
}

# aggregate stddev on columns
type sammel_lieferung_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "sammel_lieferung"
input sammel_lieferung_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type sammel_lieferung_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "sammel_lieferung"
input sammel_lieferung_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type sammel_lieferung_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "sammel_lieferung"
input sammel_lieferung_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type sammel_lieferung_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "sammel_lieferung"
input sammel_lieferung_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "sammel_lieferung"
enum sammel_lieferung_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  id

  # column name
  nach_ausgepflanzt

  # column name
  nach_kultur_id

  # column name
  person_id

  # column name
  von_anzahl_individuen

  # column name
  von_kultur_id

  # column name
  von_sammlung_id
}

# aggregate var_pop on columns
type sammel_lieferung_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "sammel_lieferung"
input sammel_lieferung_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type sammel_lieferung_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "sammel_lieferung"
input sammel_lieferung_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type sammel_lieferung_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "sammel_lieferung"
input sammel_lieferung_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# columns and relationships of "sammlung"
type sammlung {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric

  # An object relationship
  herkunft: herkunft
  herkunft_id: uuid
  id: ID!

  # An array relationship
  lieferung_revs(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # An aggregated array relationship
  lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!
  lv95_x: numeric
  lv95_y: numeric
  nr: String

  # An object relationship
  person: person
  person_id: uuid

  # An array relationship
  sammel_lieferung_revs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # An aggregated array relationship
  sammel_lieferung_revs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # An array relationship
  sammlung_files(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): [sammlung_file!]!

  # An aggregated array relationship
  sammlung_files_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): sammlung_file_aggregate!
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregated selection of "sammlung"
type sammlung_aggregate {
  aggregate: sammlung_aggregate_fields
  nodes: [sammlung!]!
}

# aggregate fields of "sammlung"
type sammlung_aggregate_fields {
  avg: sammlung_avg_fields
  count(columns: [sammlung_select_column!], distinct: Boolean): Int
  max: sammlung_max_fields
  min: sammlung_min_fields
  stddev: sammlung_stddev_fields
  stddev_pop: sammlung_stddev_pop_fields
  stddev_samp: sammlung_stddev_samp_fields
  sum: sammlung_sum_fields
  var_pop: sammlung_var_pop_fields
  var_samp: sammlung_var_samp_fields
  variance: sammlung_variance_fields
}

# order by aggregate values of table "sammlung"
input sammlung_aggregate_order_by {
  avg: sammlung_avg_order_by
  count: order_by
  max: sammlung_max_order_by
  min: sammlung_min_order_by
  stddev: sammlung_stddev_order_by
  stddev_pop: sammlung_stddev_pop_order_by
  stddev_samp: sammlung_stddev_samp_order_by
  sum: sammlung_sum_order_by
  var_pop: sammlung_var_pop_order_by
  var_samp: sammlung_var_samp_order_by
  variance: sammlung_variance_order_by
}

# input type for inserting array relation for remote table "sammlung"
input sammlung_arr_rel_insert_input {
  data: [sammlung_insert_input!]!
  on_conflict: sammlung_on_conflict
}

# aggregate avg on columns
type sammlung_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by avg() on columns of table "sammlung"
input sammlung_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# Boolean expression to filter rows from the table "sammlung". All fields are combined with a logical 'AND'.
input sammlung_bool_exp {
  _and: [sammlung_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: sammlung_bool_exp
  _or: [sammlung_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geom_point: geometry_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  herkunft: herkunft_bool_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  lieferung_revs: lieferung_rev_bool_exp
  lieferungs: lieferung_bool_exp
  lv95_x: numeric_comparison_exp
  lv95_y: numeric_comparison_exp
  nr: String_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammel_lieferung_revs: sammel_lieferung_rev_bool_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlung_files: sammlung_file_bool_exp
  von_anzahl_individuen: Int_comparison_exp
  wgs84_lat: numeric_comparison_exp
  wgs84_long: numeric_comparison_exp
}

# unique or primary key constraints on table "sammlung"
enum sammlung_constraint {
  # unique or primary key constraint
  sammlung_pkey
}

# columns and relationships of "sammlung_file"
type sammlung_file {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID!
  name: String

  # An object relationship
  sammlung: sammlung
  sammlung_id: uuid
}

# aggregated selection of "sammlung_file"
type sammlung_file_aggregate {
  aggregate: sammlung_file_aggregate_fields
  nodes: [sammlung_file!]!
}

# aggregate fields of "sammlung_file"
type sammlung_file_aggregate_fields {
  avg: sammlung_file_avg_fields
  count(columns: [sammlung_file_select_column!], distinct: Boolean): Int
  max: sammlung_file_max_fields
  min: sammlung_file_min_fields
  stddev: sammlung_file_stddev_fields
  stddev_pop: sammlung_file_stddev_pop_fields
  stddev_samp: sammlung_file_stddev_samp_fields
  sum: sammlung_file_sum_fields
  var_pop: sammlung_file_var_pop_fields
  var_samp: sammlung_file_var_samp_fields
  variance: sammlung_file_variance_fields
}

# order by aggregate values of table "sammlung_file"
input sammlung_file_aggregate_order_by {
  avg: sammlung_file_avg_order_by
  count: order_by
  max: sammlung_file_max_order_by
  min: sammlung_file_min_order_by
  stddev: sammlung_file_stddev_order_by
  stddev_pop: sammlung_file_stddev_pop_order_by
  stddev_samp: sammlung_file_stddev_samp_order_by
  sum: sammlung_file_sum_order_by
  var_pop: sammlung_file_var_pop_order_by
  var_samp: sammlung_file_var_samp_order_by
  variance: sammlung_file_variance_order_by
}

# input type for inserting array relation for remote table "sammlung_file"
input sammlung_file_arr_rel_insert_input {
  data: [sammlung_file_insert_input!]!
  on_conflict: sammlung_file_on_conflict
}

# aggregate avg on columns
type sammlung_file_avg_fields {
  _rev_at: Float
}

# order by avg() on columns of table "sammlung_file"
input sammlung_file_avg_order_by {
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "sammlung_file". All fields are combined with a logical 'AND'.
input sammlung_file_bool_exp {
  _and: [sammlung_file_bool_exp]
  _not: sammlung_file_bool_exp
  _or: [sammlung_file_bool_exp]
  _rev_at: numeric_comparison_exp
  beschreibung: String_comparison_exp
  changed: timestamp_comparison_exp
  file_id: uuid_comparison_exp
  file_mime_type: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  sammlung: sammlung_bool_exp
  sammlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "sammlung_file"
enum sammlung_file_constraint {
  # unique or primary key constraint
  sammlung_file_pkey
}

# input type for incrementing integer column in table "sammlung_file"
input sammlung_file_inc_input {
  _rev_at: numeric
}

# input type for inserting data into table "sammlung_file"
input sammlung_file_insert_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  sammlung: sammlung_obj_rel_insert_input
  sammlung_id: uuid
}

# aggregate max on columns
type sammlung_file_max_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  sammlung_id: uuid
}

# order by max() on columns of table "sammlung_file"
input sammlung_file_max_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  sammlung_id: order_by
}

# aggregate min on columns
type sammlung_file_min_fields {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  sammlung_id: uuid
}

# order by min() on columns of table "sammlung_file"
input sammlung_file_min_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  sammlung_id: order_by
}

# response of any mutation on the table "sammlung_file"
type sammlung_file_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sammlung_file!]!
}

# input type for inserting object relation for remote table "sammlung_file"
input sammlung_file_obj_rel_insert_input {
  data: sammlung_file_insert_input!
  on_conflict: sammlung_file_on_conflict
}

# on conflict condition type for table "sammlung_file"
input sammlung_file_on_conflict {
  constraint: sammlung_file_constraint!
  update_columns: [sammlung_file_update_column!]!
  where: sammlung_file_bool_exp
}

# ordering options when selecting data from "sammlung_file"
input sammlung_file_order_by {
  _rev_at: order_by
  beschreibung: order_by
  changed: order_by
  file_id: order_by
  file_mime_type: order_by
  id: order_by
  name: order_by
  sammlung: sammlung_order_by
  sammlung_id: order_by
}

# primary key columns input for table: "sammlung_file"
input sammlung_file_pk_columns_input {
  id: ID!
}

# select columns of table "sammlung_file"
enum sammlung_file_select_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name

  # column name
  sammlung_id
}

# input type for updating data in table "sammlung_file"
input sammlung_file_set_input {
  _rev_at: numeric
  beschreibung: String
  changed: timestamp
  file_id: uuid
  file_mime_type: String
  id: ID
  name: String
  sammlung_id: uuid
}

# aggregate stddev on columns
type sammlung_file_stddev_fields {
  _rev_at: Float
}

# order by stddev() on columns of table "sammlung_file"
input sammlung_file_stddev_order_by {
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type sammlung_file_stddev_pop_fields {
  _rev_at: Float
}

# order by stddev_pop() on columns of table "sammlung_file"
input sammlung_file_stddev_pop_order_by {
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type sammlung_file_stddev_samp_fields {
  _rev_at: Float
}

# order by stddev_samp() on columns of table "sammlung_file"
input sammlung_file_stddev_samp_order_by {
  _rev_at: order_by
}

# aggregate sum on columns
type sammlung_file_sum_fields {
  _rev_at: numeric
}

# order by sum() on columns of table "sammlung_file"
input sammlung_file_sum_order_by {
  _rev_at: order_by
}

# update columns of table "sammlung_file"
enum sammlung_file_update_column {
  # column name
  _rev_at

  # column name
  beschreibung

  # column name
  changed

  # column name
  file_id

  # column name
  file_mime_type

  # column name
  id

  # column name
  name

  # column name
  sammlung_id
}

# aggregate var_pop on columns
type sammlung_file_var_pop_fields {
  _rev_at: Float
}

# order by var_pop() on columns of table "sammlung_file"
input sammlung_file_var_pop_order_by {
  _rev_at: order_by
}

# aggregate var_samp on columns
type sammlung_file_var_samp_fields {
  _rev_at: Float
}

# order by var_samp() on columns of table "sammlung_file"
input sammlung_file_var_samp_order_by {
  _rev_at: order_by
}

# aggregate variance on columns
type sammlung_file_variance_fields {
  _rev_at: Float
}

# order by variance() on columns of table "sammlung_file"
input sammlung_file_variance_order_by {
  _rev_at: order_by
}

# input type for incrementing integer column in table "sammlung"
input sammlung_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_pflanzen: Int
  gramm_samen: numeric
  lv95_x: numeric
  lv95_y: numeric
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# input type for inserting data into table "sammlung"
input sammlung_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric
  herkunft: herkunft_obj_rel_insert_input
  herkunft_id: uuid
  id: ID
  lieferung_revs: lieferung_rev_arr_rel_insert_input
  lieferungs: lieferung_arr_rel_insert_input
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  person: person_obj_rel_insert_input
  person_id: uuid
  sammel_lieferung_revs: sammel_lieferung_rev_arr_rel_insert_input
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlung_files: sammlung_file_arr_rel_insert_input
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate max on columns
type sammlung_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  person_id: uuid
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by max() on columns of table "sammlung"
input sammlung_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  herkunft_id: order_by
  id: order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  person_id: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate min on columns
type sammlung_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  person_id: uuid
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by min() on columns of table "sammlung"
input sammlung_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  herkunft_id: order_by
  id: order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  person_id: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# response of any mutation on the table "sammlung"
type sammlung_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sammlung!]!
}

# input type for inserting object relation for remote table "sammlung"
input sammlung_obj_rel_insert_input {
  data: sammlung_insert_input!
  on_conflict: sammlung_on_conflict
}

# on conflict condition type for table "sammlung"
input sammlung_on_conflict {
  constraint: sammlung_constraint!
  update_columns: [sammlung_update_column!]!
  where: sammlung_bool_exp
}

# ordering options when selecting data from "sammlung"
input sammlung_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geom_point: order_by
  geplant: order_by
  gramm_samen: order_by
  herkunft: herkunft_order_by
  herkunft_id: order_by
  id: order_by
  lieferung_revs_aggregate: lieferung_rev_aggregate_order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  lv95_x: order_by
  lv95_y: order_by
  nr: order_by
  person: person_order_by
  person_id: order_by
  sammel_lieferung_revs_aggregate: sammel_lieferung_rev_aggregate_order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlung_files_aggregate: sammlung_file_aggregate_order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# primary key columns input for table: "sammlung"
input sammlung_pk_columns_input {
  id: ID!
}

# columns and relationships of "sammlung_rev"
type sammlung_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int

  # An object relationship
  art: art
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric

  # An object relationship
  herkunft: herkunft
  herkunft_id: uuid
  id: ID!

  # An array relationship
  lieferungs(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # An aggregated array relationship
  lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!
  nr: String

  # An object relationship
  person: person
  person_id: uuid

  # An array relationship
  sammel_lieferungs(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # An aggregated array relationship
  sammel_lieferungs_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!
  sammlung_id: uuid!
  von_anzahl_individuen: Int
}

# aggregated selection of "sammlung_rev"
type sammlung_rev_aggregate {
  aggregate: sammlung_rev_aggregate_fields
  nodes: [sammlung_rev!]!
}

# aggregate fields of "sammlung_rev"
type sammlung_rev_aggregate_fields {
  avg: sammlung_rev_avg_fields
  count(columns: [sammlung_rev_select_column!], distinct: Boolean): Int
  max: sammlung_rev_max_fields
  min: sammlung_rev_min_fields
  stddev: sammlung_rev_stddev_fields
  stddev_pop: sammlung_rev_stddev_pop_fields
  stddev_samp: sammlung_rev_stddev_samp_fields
  sum: sammlung_rev_sum_fields
  var_pop: sammlung_rev_var_pop_fields
  var_samp: sammlung_rev_var_samp_fields
  variance: sammlung_rev_variance_fields
}

# order by aggregate values of table "sammlung_rev"
input sammlung_rev_aggregate_order_by {
  avg: sammlung_rev_avg_order_by
  count: order_by
  max: sammlung_rev_max_order_by
  min: sammlung_rev_min_order_by
  stddev: sammlung_rev_stddev_order_by
  stddev_pop: sammlung_rev_stddev_pop_order_by
  stddev_samp: sammlung_rev_stddev_samp_order_by
  sum: sammlung_rev_sum_order_by
  var_pop: sammlung_rev_var_pop_order_by
  var_samp: sammlung_rev_var_samp_order_by
  variance: sammlung_rev_variance_order_by
}

# input type for inserting array relation for remote table "sammlung_rev"
input sammlung_rev_arr_rel_insert_input {
  data: [sammlung_rev_insert_input!]!
  on_conflict: sammlung_rev_on_conflict
}

# aggregate avg on columns
type sammlung_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by avg() on columns of table "sammlung_rev"
input sammlung_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# Boolean expression to filter rows from the table "sammlung_rev". All fields are combined with a logical 'AND'.
input sammlung_rev_bool_exp {
  _and: [sammlung_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: sammlung_rev_bool_exp
  _or: [sammlung_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  art: art_bool_exp
  art_id: uuid_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  geom_point: geometry_comparison_exp
  geplant: Boolean_comparison_exp
  gramm_samen: numeric_comparison_exp
  herkunft: herkunft_bool_exp
  herkunft_id: uuid_comparison_exp
  id: uuid_comparison_exp
  lieferungs: lieferung_bool_exp
  nr: String_comparison_exp
  person: person_bool_exp
  person_id: uuid_comparison_exp
  sammel_lieferungs: sammel_lieferung_bool_exp
  sammlung_id: uuid_comparison_exp
  von_anzahl_individuen: Int_comparison_exp
}

# unique or primary key constraints on table "sammlung_rev"
enum sammlung_rev_constraint {
  # unique or primary key constraint
  sammlung_rev_pkey
}

# input type for incrementing integer column in table "sammlung_rev"
input sammlung_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# input type for inserting data into table "sammlung_rev"
input sammlung_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int
  art: art_obj_rel_insert_input
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric
  herkunft: herkunft_obj_rel_insert_input
  herkunft_id: uuid
  id: ID
  lieferungs: lieferung_arr_rel_insert_input
  nr: String
  person: person_obj_rel_insert_input
  person_id: uuid
  sammel_lieferungs: sammel_lieferung_arr_rel_insert_input
  sammlung_id: uuid
  von_anzahl_individuen: Int
}

# aggregate max on columns
type sammlung_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  nr: String
  person_id: uuid
  sammlung_id: uuid
  von_anzahl_individuen: Int
}

# order by max() on columns of table "sammlung_rev"
input sammlung_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  herkunft_id: order_by
  id: order_by
  nr: order_by
  person_id: order_by
  sammlung_id: order_by
  von_anzahl_individuen: order_by
}

# aggregate min on columns
type sammlung_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  nr: String
  person_id: uuid
  sammlung_id: uuid
  von_anzahl_individuen: Int
}

# order by min() on columns of table "sammlung_rev"
input sammlung_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  gramm_samen: order_by
  herkunft_id: order_by
  id: order_by
  nr: order_by
  person_id: order_by
  sammlung_id: order_by
  von_anzahl_individuen: order_by
}

# response of any mutation on the table "sammlung_rev"
type sammlung_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sammlung_rev!]!
}

# input type for inserting object relation for remote table "sammlung_rev"
input sammlung_rev_obj_rel_insert_input {
  data: sammlung_rev_insert_input!
  on_conflict: sammlung_rev_on_conflict
}

# on conflict condition type for table "sammlung_rev"
input sammlung_rev_on_conflict {
  constraint: sammlung_rev_constraint!
  update_columns: [sammlung_rev_update_column!]!
  where: sammlung_rev_bool_exp
}

# ordering options when selecting data from "sammlung_rev"
input sammlung_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_pflanzen: order_by
  art: art_order_by
  art_id: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  geom_point: order_by
  geplant: order_by
  gramm_samen: order_by
  herkunft: herkunft_order_by
  herkunft_id: order_by
  id: order_by
  lieferungs_aggregate: lieferung_aggregate_order_by
  nr: order_by
  person: person_order_by
  person_id: order_by
  sammel_lieferungs_aggregate: sammel_lieferung_aggregate_order_by
  sammlung_id: order_by
  von_anzahl_individuen: order_by
}

# primary key columns input for table: "sammlung_rev"
input sammlung_rev_pk_columns_input {
  id: ID!
}

# select columns of table "sammlung_rev"
enum sammlung_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geom_point

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  herkunft_id

  # column name
  id

  # column name
  nr

  # column name
  person_id

  # column name
  sammlung_id

  # column name
  von_anzahl_individuen
}

# input type for updating data in table "sammlung_rev"
input sammlung_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  nr: String
  person_id: uuid
  sammlung_id: uuid
  von_anzahl_individuen: Int
}

# aggregate stddev on columns
type sammlung_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev() on columns of table "sammlung_rev"
input sammlung_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_pop on columns
type sammlung_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_pop() on columns of table "sammlung_rev"
input sammlung_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate stddev_samp on columns
type sammlung_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by stddev_samp() on columns of table "sammlung_rev"
input sammlung_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate sum on columns
type sammlung_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_pflanzen: Int
  gramm_samen: numeric
  von_anzahl_individuen: Int
}

# order by sum() on columns of table "sammlung_rev"
input sammlung_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# update columns of table "sammlung_rev"
enum sammlung_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geom_point

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  herkunft_id

  # column name
  id

  # column name
  nr

  # column name
  person_id

  # column name
  sammlung_id

  # column name
  von_anzahl_individuen
}

# aggregate var_pop on columns
type sammlung_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_pop() on columns of table "sammlung_rev"
input sammlung_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate var_samp on columns
type sammlung_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by var_samp() on columns of table "sammlung_rev"
input sammlung_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# aggregate variance on columns
type sammlung_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  von_anzahl_individuen: Float
}

# order by variance() on columns of table "sammlung_rev"
input sammlung_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  von_anzahl_individuen: order_by
}

# select columns of table "sammlung"
enum sammlung_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geom_point

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  herkunft_id

  # column name
  id

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  nr

  # column name
  person_id

  # column name
  von_anzahl_individuen

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# input type for updating data in table "sammlung"
input sammlung_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_pflanzen: Int
  art_id: uuid
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  geom_point: geometry
  geplant: Boolean
  gramm_samen: numeric
  herkunft_id: uuid
  id: ID
  lv95_x: numeric
  lv95_y: numeric
  nr: String
  person_id: uuid
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# aggregate stddev on columns
type sammlung_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev() on columns of table "sammlung"
input sammlung_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_pop on columns
type sammlung_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_pop() on columns of table "sammlung"
input sammlung_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate stddev_samp on columns
type sammlung_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by stddev_samp() on columns of table "sammlung"
input sammlung_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate sum on columns
type sammlung_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_pflanzen: Int
  gramm_samen: numeric
  lv95_x: numeric
  lv95_y: numeric
  von_anzahl_individuen: Int
  wgs84_lat: numeric
  wgs84_long: numeric
}

# order by sum() on columns of table "sammlung"
input sammlung_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# update columns of table "sammlung"
enum sammlung_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_pflanzen

  # column name
  art_id

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  geom_point

  # column name
  geplant

  # column name
  gramm_samen

  # column name
  herkunft_id

  # column name
  id

  # column name
  lv95_x

  # column name
  lv95_y

  # column name
  nr

  # column name
  person_id

  # column name
  von_anzahl_individuen

  # column name
  wgs84_lat

  # column name
  wgs84_long
}

# aggregate var_pop on columns
type sammlung_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_pop() on columns of table "sammlung"
input sammlung_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate var_samp on columns
type sammlung_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by var_samp() on columns of table "sammlung"
input sammlung_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

# aggregate variance on columns
type sammlung_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_pflanzen: Float
  gramm_samen: Float
  lv95_x: Float
  lv95_y: Float
  von_anzahl_individuen: Float
  wgs84_lat: Float
  wgs84_long: Float
}

# order by variance() on columns of table "sammlung"
input sammlung_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_pflanzen: order_by
  gramm_samen: order_by
  lv95_x: order_by
  lv95_y: order_by
  von_anzahl_individuen: order_by
  wgs84_lat: order_by
  wgs84_long: order_by
}

scalar smallint

# expression to compare columns of type smallint. All fields are combined with logical 'AND'.
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# columns and relationships of "spatial_ref_sys"
type spatial_ref_sys {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int!
  srtext: String
}

# aggregated selection of "spatial_ref_sys"
type spatial_ref_sys_aggregate {
  aggregate: spatial_ref_sys_aggregate_fields
  nodes: [spatial_ref_sys!]!
}

# aggregate fields of "spatial_ref_sys"
type spatial_ref_sys_aggregate_fields {
  avg: spatial_ref_sys_avg_fields
  count(columns: [spatial_ref_sys_select_column!], distinct: Boolean): Int
  max: spatial_ref_sys_max_fields
  min: spatial_ref_sys_min_fields
  stddev: spatial_ref_sys_stddev_fields
  stddev_pop: spatial_ref_sys_stddev_pop_fields
  stddev_samp: spatial_ref_sys_stddev_samp_fields
  sum: spatial_ref_sys_sum_fields
  var_pop: spatial_ref_sys_var_pop_fields
  var_samp: spatial_ref_sys_var_samp_fields
  variance: spatial_ref_sys_variance_fields
}

# order by aggregate values of table "spatial_ref_sys"
input spatial_ref_sys_aggregate_order_by {
  avg: spatial_ref_sys_avg_order_by
  count: order_by
  max: spatial_ref_sys_max_order_by
  min: spatial_ref_sys_min_order_by
  stddev: spatial_ref_sys_stddev_order_by
  stddev_pop: spatial_ref_sys_stddev_pop_order_by
  stddev_samp: spatial_ref_sys_stddev_samp_order_by
  sum: spatial_ref_sys_sum_order_by
  var_pop: spatial_ref_sys_var_pop_order_by
  var_samp: spatial_ref_sys_var_samp_order_by
  variance: spatial_ref_sys_variance_order_by
}

# input type for inserting array relation for remote table "spatial_ref_sys"
input spatial_ref_sys_arr_rel_insert_input {
  data: [spatial_ref_sys_insert_input!]!
  on_conflict: spatial_ref_sys_on_conflict
}

# aggregate avg on columns
type spatial_ref_sys_avg_fields {
  auth_srid: Float
  srid: Float
}

# order by avg() on columns of table "spatial_ref_sys"
input spatial_ref_sys_avg_order_by {
  auth_srid: order_by
  srid: order_by
}

# Boolean expression to filter rows from the table "spatial_ref_sys". All fields are combined with a logical 'AND'.
input spatial_ref_sys_bool_exp {
  _and: [spatial_ref_sys_bool_exp]
  _not: spatial_ref_sys_bool_exp
  _or: [spatial_ref_sys_bool_exp]
  auth_name: String_comparison_exp
  auth_srid: Int_comparison_exp
  proj4text: String_comparison_exp
  srid: Int_comparison_exp
  srtext: String_comparison_exp
}

# unique or primary key constraints on table "spatial_ref_sys"
enum spatial_ref_sys_constraint {
  # unique or primary key constraint
  spatial_ref_sys_pkey
}

# input type for incrementing integer column in table "spatial_ref_sys"
input spatial_ref_sys_inc_input {
  auth_srid: Int
  srid: Int
}

# input type for inserting data into table "spatial_ref_sys"
input spatial_ref_sys_insert_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

# aggregate max on columns
type spatial_ref_sys_max_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

# order by max() on columns of table "spatial_ref_sys"
input spatial_ref_sys_max_order_by {
  auth_name: order_by
  auth_srid: order_by
  proj4text: order_by
  srid: order_by
  srtext: order_by
}

# aggregate min on columns
type spatial_ref_sys_min_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

# order by min() on columns of table "spatial_ref_sys"
input spatial_ref_sys_min_order_by {
  auth_name: order_by
  auth_srid: order_by
  proj4text: order_by
  srid: order_by
  srtext: order_by
}

# response of any mutation on the table "spatial_ref_sys"
type spatial_ref_sys_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [spatial_ref_sys!]!
}

# input type for inserting object relation for remote table "spatial_ref_sys"
input spatial_ref_sys_obj_rel_insert_input {
  data: spatial_ref_sys_insert_input!
  on_conflict: spatial_ref_sys_on_conflict
}

# on conflict condition type for table "spatial_ref_sys"
input spatial_ref_sys_on_conflict {
  constraint: spatial_ref_sys_constraint!
  update_columns: [spatial_ref_sys_update_column!]!
  where: spatial_ref_sys_bool_exp
}

# ordering options when selecting data from "spatial_ref_sys"
input spatial_ref_sys_order_by {
  auth_name: order_by
  auth_srid: order_by
  proj4text: order_by
  srid: order_by
  srtext: order_by
}

# primary key columns input for table: "spatial_ref_sys"
input spatial_ref_sys_pk_columns_input {
  srid: Int!
}

# select columns of table "spatial_ref_sys"
enum spatial_ref_sys_select_column {
  # column name
  auth_name

  # column name
  auth_srid

  # column name
  proj4text

  # column name
  srid

  # column name
  srtext
}

# input type for updating data in table "spatial_ref_sys"
input spatial_ref_sys_set_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

# aggregate stddev on columns
type spatial_ref_sys_stddev_fields {
  auth_srid: Float
  srid: Float
}

# order by stddev() on columns of table "spatial_ref_sys"
input spatial_ref_sys_stddev_order_by {
  auth_srid: order_by
  srid: order_by
}

# aggregate stddev_pop on columns
type spatial_ref_sys_stddev_pop_fields {
  auth_srid: Float
  srid: Float
}

# order by stddev_pop() on columns of table "spatial_ref_sys"
input spatial_ref_sys_stddev_pop_order_by {
  auth_srid: order_by
  srid: order_by
}

# aggregate stddev_samp on columns
type spatial_ref_sys_stddev_samp_fields {
  auth_srid: Float
  srid: Float
}

# order by stddev_samp() on columns of table "spatial_ref_sys"
input spatial_ref_sys_stddev_samp_order_by {
  auth_srid: order_by
  srid: order_by
}

# aggregate sum on columns
type spatial_ref_sys_sum_fields {
  auth_srid: Int
  srid: Int
}

# order by sum() on columns of table "spatial_ref_sys"
input spatial_ref_sys_sum_order_by {
  auth_srid: order_by
  srid: order_by
}

# update columns of table "spatial_ref_sys"
enum spatial_ref_sys_update_column {
  # column name
  auth_name

  # column name
  auth_srid

  # column name
  proj4text

  # column name
  srid

  # column name
  srtext
}

# aggregate var_pop on columns
type spatial_ref_sys_var_pop_fields {
  auth_srid: Float
  srid: Float
}

# order by var_pop() on columns of table "spatial_ref_sys"
input spatial_ref_sys_var_pop_order_by {
  auth_srid: order_by
  srid: order_by
}

# aggregate var_samp on columns
type spatial_ref_sys_var_samp_fields {
  auth_srid: Float
  srid: Float
}

# order by var_samp() on columns of table "spatial_ref_sys"
input spatial_ref_sys_var_samp_order_by {
  auth_srid: order_by
  srid: order_by
}

# aggregate variance on columns
type spatial_ref_sys_variance_fields {
  auth_srid: Float
  srid: Float
}

# order by variance() on columns of table "spatial_ref_sys"
input spatial_ref_sys_variance_order_by {
  auth_srid: order_by
  srid: order_by
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "ae_art"
  ae_art(
    # distinct select on columns
    distinct_on: [ae_art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ae_art_order_by!]

    # filter the rows returned
    where: ae_art_bool_exp
  ): [ae_art!]!

  # fetch aggregated fields from the table: "ae_art"
  ae_art_aggregate(
    # distinct select on columns
    distinct_on: [ae_art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ae_art_order_by!]

    # filter the rows returned
    where: ae_art_bool_exp
  ): ae_art_aggregate!

  # fetch data from the table: "ae_art" using primary key columns
  ae_art_by_pk(id: ID!): ae_art

  # fetch data from the table: "art"
  art(
    # distinct select on columns
    distinct_on: [art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_order_by!]

    # filter the rows returned
    where: art_bool_exp
  ): [art!]!

  # fetch aggregated fields from the table: "art"
  art_aggregate(
    # distinct select on columns
    distinct_on: [art_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_order_by!]

    # filter the rows returned
    where: art_bool_exp
  ): art_aggregate!

  # fetch data from the table: "art" using primary key columns
  art_by_pk(id: ID!): art

  # fetch data from the table: "art_file"
  art_file(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): [art_file!]!

  # fetch aggregated fields from the table: "art_file"
  art_file_aggregate(
    # distinct select on columns
    distinct_on: [art_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_file_order_by!]

    # filter the rows returned
    where: art_file_bool_exp
  ): art_file_aggregate!

  # fetch data from the table: "art_file" using primary key columns
  art_file_by_pk(id: ID!): art_file

  # fetch data from the table: "art_qk"
  art_qk(
    # distinct select on columns
    distinct_on: [art_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_order_by!]

    # filter the rows returned
    where: art_qk_bool_exp
  ): [art_qk!]!

  # fetch aggregated fields from the table: "art_qk"
  art_qk_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_order_by!]

    # filter the rows returned
    where: art_qk_bool_exp
  ): art_qk_aggregate!

  # fetch data from the table: "art_qk" using primary key columns
  art_qk_by_pk(id: ID!): art_qk

  # fetch data from the table: "art_qk_choosen"
  art_qk_choosen(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): [art_qk_choosen!]!

  # fetch aggregated fields from the table: "art_qk_choosen"
  art_qk_choosen_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_order_by!]

    # filter the rows returned
    where: art_qk_choosen_bool_exp
  ): art_qk_choosen_aggregate!

  # fetch data from the table: "art_qk_choosen" using primary key columns
  art_qk_choosen_by_pk(id: ID!): art_qk_choosen

  # fetch data from the table: "art_qk_choosen_rev"
  art_qk_choosen_rev(
    # distinct select on columns
    distinct_on: [art_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: art_qk_choosen_rev_bool_exp
  ): [art_qk_choosen_rev!]!

  # fetch aggregated fields from the table: "art_qk_choosen_rev"
  art_qk_choosen_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: art_qk_choosen_rev_bool_exp
  ): art_qk_choosen_rev_aggregate!

  # fetch data from the table: "art_qk_choosen_rev" using primary key columns
  art_qk_choosen_rev_by_pk(id: ID!): art_qk_choosen_rev

  # fetch data from the table: "art_qk_rev"
  art_qk_rev(
    # distinct select on columns
    distinct_on: [art_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_rev_order_by!]

    # filter the rows returned
    where: art_qk_rev_bool_exp
  ): [art_qk_rev!]!

  # fetch aggregated fields from the table: "art_qk_rev"
  art_qk_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_qk_rev_order_by!]

    # filter the rows returned
    where: art_qk_rev_bool_exp
  ): art_qk_rev_aggregate!

  # fetch data from the table: "art_qk_rev" using primary key columns
  art_qk_rev_by_pk(id: ID!): art_qk_rev

  # fetch data from the table: "art_rev"
  art_rev(
    # distinct select on columns
    distinct_on: [art_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_rev_order_by!]

    # filter the rows returned
    where: art_rev_bool_exp
  ): [art_rev!]!

  # fetch aggregated fields from the table: "art_rev"
  art_rev_aggregate(
    # distinct select on columns
    distinct_on: [art_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [art_rev_order_by!]

    # filter the rows returned
    where: art_rev_bool_exp
  ): art_rev_aggregate!

  # fetch data from the table: "art_rev" using primary key columns
  art_rev_by_pk(id: ID!): art_rev

  # fetch data from the table: "av"
  av(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): [av!]!

  # fetch aggregated fields from the table: "av"
  av_aggregate(
    # distinct select on columns
    distinct_on: [av_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_order_by!]

    # filter the rows returned
    where: av_bool_exp
  ): av_aggregate!

  # fetch data from the table: "av" using primary key columns
  av_by_pk(id: ID!): av

  # fetch data from the table: "av_rev"
  av_rev(
    # distinct select on columns
    distinct_on: [av_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_rev_order_by!]

    # filter the rows returned
    where: av_rev_bool_exp
  ): [av_rev!]!

  # fetch aggregated fields from the table: "av_rev"
  av_rev_aggregate(
    # distinct select on columns
    distinct_on: [av_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [av_rev_order_by!]

    # filter the rows returned
    where: av_rev_bool_exp
  ): av_rev_aggregate!

  # fetch data from the table: "av_rev" using primary key columns
  av_rev_by_pk(id: ID!): av_rev

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event" using primary key columns
  event_by_pk(id: ID!): event

  # fetch data from the table: "event_rev"
  event_rev(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): [event_rev!]!

  # fetch aggregated fields from the table: "event_rev"
  event_rev_aggregate(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): event_rev_aggregate!

  # fetch data from the table: "event_rev" using primary key columns
  event_rev_by_pk(id: ID!): event_rev

  # fetch data from the table: "garten"
  garten(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): [garten!]!

  # fetch aggregated fields from the table: "garten"
  garten_aggregate(
    # distinct select on columns
    distinct_on: [garten_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_order_by!]

    # filter the rows returned
    where: garten_bool_exp
  ): garten_aggregate!

  # fetch data from the table: "garten" using primary key columns
  garten_by_pk(id: ID!): garten

  # fetch data from the table: "garten_file"
  garten_file(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): [garten_file!]!

  # fetch aggregated fields from the table: "garten_file"
  garten_file_aggregate(
    # distinct select on columns
    distinct_on: [garten_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_file_order_by!]

    # filter the rows returned
    where: garten_file_bool_exp
  ): garten_file_aggregate!

  # fetch data from the table: "garten_file" using primary key columns
  garten_file_by_pk(id: ID!): garten_file

  # fetch data from the table: "garten_rev"
  garten_rev(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): [garten_rev!]!

  # fetch aggregated fields from the table: "garten_rev"
  garten_rev_aggregate(
    # distinct select on columns
    distinct_on: [garten_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [garten_rev_order_by!]

    # filter the rows returned
    where: garten_rev_bool_exp
  ): garten_rev_aggregate!

  # fetch data from the table: "garten_rev" using primary key columns
  garten_rev_by_pk(id: ID!): garten_rev

  # fetch data from the table: "gv"
  gv(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): [gv!]!

  # fetch aggregated fields from the table: "gv"
  gv_aggregate(
    # distinct select on columns
    distinct_on: [gv_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_order_by!]

    # filter the rows returned
    where: gv_bool_exp
  ): gv_aggregate!

  # fetch data from the table: "gv" using primary key columns
  gv_by_pk(id: ID!): gv

  # fetch data from the table: "gv_rev"
  gv_rev(
    # distinct select on columns
    distinct_on: [gv_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_rev_order_by!]

    # filter the rows returned
    where: gv_rev_bool_exp
  ): [gv_rev!]!

  # fetch aggregated fields from the table: "gv_rev"
  gv_rev_aggregate(
    # distinct select on columns
    distinct_on: [gv_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [gv_rev_order_by!]

    # filter the rows returned
    where: gv_rev_bool_exp
  ): gv_rev_aggregate!

  # fetch data from the table: "gv_rev" using primary key columns
  gv_rev_by_pk(id: ID!): gv_rev

  # fetch data from the table: "herkunft"
  herkunft(
    # distinct select on columns
    distinct_on: [herkunft_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_order_by!]

    # filter the rows returned
    where: herkunft_bool_exp
  ): [herkunft!]!

  # fetch aggregated fields from the table: "herkunft"
  herkunft_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_order_by!]

    # filter the rows returned
    where: herkunft_bool_exp
  ): herkunft_aggregate!

  # fetch data from the table: "herkunft" using primary key columns
  herkunft_by_pk(id: ID!): herkunft

  # fetch data from the table: "herkunft_file"
  herkunft_file(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): [herkunft_file!]!

  # fetch aggregated fields from the table: "herkunft_file"
  herkunft_file_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_file_order_by!]

    # filter the rows returned
    where: herkunft_file_bool_exp
  ): herkunft_file_aggregate!

  # fetch data from the table: "herkunft_file" using primary key columns
  herkunft_file_by_pk(id: ID!): herkunft_file

  # fetch data from the table: "herkunft_rev"
  herkunft_rev(
    # distinct select on columns
    distinct_on: [herkunft_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_rev_order_by!]

    # filter the rows returned
    where: herkunft_rev_bool_exp
  ): [herkunft_rev!]!

  # fetch aggregated fields from the table: "herkunft_rev"
  herkunft_rev_aggregate(
    # distinct select on columns
    distinct_on: [herkunft_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [herkunft_rev_order_by!]

    # filter the rows returned
    where: herkunft_rev_bool_exp
  ): herkunft_rev_aggregate!

  # fetch data from the table: "herkunft_rev" using primary key columns
  herkunft_rev_by_pk(id: ID!): herkunft_rev

  # fetch data from the table: "kultur"
  kultur(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): [kultur!]!

  # fetch aggregated fields from the table: "kultur"
  kultur_aggregate(
    # distinct select on columns
    distinct_on: [kultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_order_by!]

    # filter the rows returned
    where: kultur_bool_exp
  ): kultur_aggregate!

  # fetch data from the table: "kultur" using primary key columns
  kultur_by_pk(id: ID!): kultur

  # fetch data from the table: "kultur_file"
  kultur_file(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): [kultur_file!]!

  # fetch aggregated fields from the table: "kultur_file"
  kultur_file_aggregate(
    # distinct select on columns
    distinct_on: [kultur_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_file_order_by!]

    # filter the rows returned
    where: kultur_file_bool_exp
  ): kultur_file_aggregate!

  # fetch data from the table: "kultur_file" using primary key columns
  kultur_file_by_pk(id: ID!): kultur_file

  # fetch data from the table: "kultur_option"
  kultur_option(
    # distinct select on columns
    distinct_on: [kultur_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_order_by!]

    # filter the rows returned
    where: kultur_option_bool_exp
  ): [kultur_option!]!

  # fetch aggregated fields from the table: "kultur_option"
  kultur_option_aggregate(
    # distinct select on columns
    distinct_on: [kultur_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_order_by!]

    # filter the rows returned
    where: kultur_option_bool_exp
  ): kultur_option_aggregate!

  # fetch data from the table: "kultur_option_rev"
  kultur_option_rev(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): [kultur_option_rev!]!

  # fetch aggregated fields from the table: "kultur_option_rev"
  kultur_option_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_option_rev_order_by!]

    # filter the rows returned
    where: kultur_option_rev_bool_exp
  ): kultur_option_rev_aggregate!

  # fetch data from the table: "kultur_option_rev" using primary key columns
  kultur_option_rev_by_pk(id: ID!): kultur_option_rev

  # fetch data from the table: "kultur_qk"
  kultur_qk(
    # distinct select on columns
    distinct_on: [kultur_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_order_by!]

    # filter the rows returned
    where: kultur_qk_bool_exp
  ): [kultur_qk!]!

  # fetch aggregated fields from the table: "kultur_qk"
  kultur_qk_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_order_by!]

    # filter the rows returned
    where: kultur_qk_bool_exp
  ): kultur_qk_aggregate!

  # fetch data from the table: "kultur_qk" using primary key columns
  kultur_qk_by_pk(id: ID!): kultur_qk

  # fetch data from the table: "kultur_qk_choosen"
  kultur_qk_choosen(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): [kultur_qk_choosen!]!

  # fetch aggregated fields from the table: "kultur_qk_choosen"
  kultur_qk_choosen_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_bool_exp
  ): kultur_qk_choosen_aggregate!

  # fetch data from the table: "kultur_qk_choosen" using primary key columns
  kultur_qk_choosen_by_pk(id: ID!): kultur_qk_choosen

  # fetch data from the table: "kultur_qk_choosen_rev"
  kultur_qk_choosen_rev(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_rev_bool_exp
  ): [kultur_qk_choosen_rev!]!

  # fetch aggregated fields from the table: "kultur_qk_choosen_rev"
  kultur_qk_choosen_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_choosen_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_choosen_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_choosen_rev_bool_exp
  ): kultur_qk_choosen_rev_aggregate!

  # fetch data from the table: "kultur_qk_choosen_rev" using primary key columns
  kultur_qk_choosen_rev_by_pk(id: ID!): kultur_qk_choosen_rev

  # fetch data from the table: "kultur_qk_rev"
  kultur_qk_rev(
    # distinct select on columns
    distinct_on: [kultur_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_rev_bool_exp
  ): [kultur_qk_rev!]!

  # fetch aggregated fields from the table: "kultur_qk_rev"
  kultur_qk_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_qk_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_qk_rev_order_by!]

    # filter the rows returned
    where: kultur_qk_rev_bool_exp
  ): kultur_qk_rev_aggregate!

  # fetch data from the table: "kultur_qk_rev" using primary key columns
  kultur_qk_rev_by_pk(name: String!): kultur_qk_rev

  # fetch data from the table: "kultur_rev"
  kultur_rev(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): [kultur_rev!]!

  # fetch aggregated fields from the table: "kultur_rev"
  kultur_rev_aggregate(
    # distinct select on columns
    distinct_on: [kultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kultur_rev_order_by!]

    # filter the rows returned
    where: kultur_rev_bool_exp
  ): kultur_rev_aggregate!

  # fetch data from the table: "kultur_rev" using primary key columns
  kultur_rev_by_pk(id: ID!): kultur_rev

  # fetch data from the table: "lieferung"
  lieferung(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): [lieferung!]!

  # fetch aggregated fields from the table: "lieferung"
  lieferung_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_order_by!]

    # filter the rows returned
    where: lieferung_bool_exp
  ): lieferung_aggregate!

  # fetch data from the table: "lieferung" using primary key columns
  lieferung_by_pk(id: ID!): lieferung

  # fetch data from the table: "lieferung_file"
  lieferung_file(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): [lieferung_file!]!

  # fetch aggregated fields from the table: "lieferung_file"
  lieferung_file_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_file_order_by!]

    # filter the rows returned
    where: lieferung_file_bool_exp
  ): lieferung_file_aggregate!

  # fetch data from the table: "lieferung_file" using primary key columns
  lieferung_file_by_pk(id: ID!): lieferung_file

  # fetch data from the table: "lieferung_rev"
  lieferung_rev(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): [lieferung_rev!]!

  # fetch aggregated fields from the table: "lieferung_rev"
  lieferung_rev_aggregate(
    # distinct select on columns
    distinct_on: [lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lieferung_rev_order_by!]

    # filter the rows returned
    where: lieferung_rev_bool_exp
  ): lieferung_rev_aggregate!

  # fetch data from the table: "lieferung_rev" using primary key columns
  lieferung_rev_by_pk(id: ID!): lieferung_rev

  # fetch data from the table: "person"
  person(
    # distinct select on columns
    distinct_on: [person_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_order_by!]

    # filter the rows returned
    where: person_bool_exp
  ): [person!]!

  # fetch aggregated fields from the table: "person"
  person_aggregate(
    # distinct select on columns
    distinct_on: [person_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_order_by!]

    # filter the rows returned
    where: person_bool_exp
  ): person_aggregate!

  # fetch data from the table: "person" using primary key columns
  person_by_pk(id: ID!): person

  # fetch data from the table: "person_file"
  person_file(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): [person_file!]!

  # fetch aggregated fields from the table: "person_file"
  person_file_aggregate(
    # distinct select on columns
    distinct_on: [person_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_file_order_by!]

    # filter the rows returned
    where: person_file_bool_exp
  ): person_file_aggregate!

  # fetch data from the table: "person_file" using primary key columns
  person_file_by_pk(id: ID!): person_file

  # fetch data from the table: "person_option"
  person_option(
    # distinct select on columns
    distinct_on: [person_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_order_by!]

    # filter the rows returned
    where: person_option_bool_exp
  ): [person_option!]!

  # fetch aggregated fields from the table: "person_option"
  person_option_aggregate(
    # distinct select on columns
    distinct_on: [person_option_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_order_by!]

    # filter the rows returned
    where: person_option_bool_exp
  ): person_option_aggregate!

  # fetch data from the table: "person_option_rev"
  person_option_rev(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): [person_option_rev!]!

  # fetch aggregated fields from the table: "person_option_rev"
  person_option_rev_aggregate(
    # distinct select on columns
    distinct_on: [person_option_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_option_rev_order_by!]

    # filter the rows returned
    where: person_option_rev_bool_exp
  ): person_option_rev_aggregate!

  # fetch data from the table: "person_option_rev" using primary key columns
  person_option_rev_by_pk(id: ID!): person_option_rev

  # fetch data from the table: "person_rev"
  person_rev(
    # distinct select on columns
    distinct_on: [person_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_rev_order_by!]

    # filter the rows returned
    where: person_rev_bool_exp
  ): [person_rev!]!

  # fetch aggregated fields from the table: "person_rev"
  person_rev_aggregate(
    # distinct select on columns
    distinct_on: [person_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [person_rev_order_by!]

    # filter the rows returned
    where: person_rev_bool_exp
  ): person_rev_aggregate!

  # fetch data from the table: "person_rev" using primary key columns
  person_rev_by_pk(id: ID!): person_rev

  # fetch data from the table: "sammel_lieferung"
  sammel_lieferung(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): [sammel_lieferung!]!

  # fetch aggregated fields from the table: "sammel_lieferung"
  sammel_lieferung_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_order_by!]

    # filter the rows returned
    where: sammel_lieferung_bool_exp
  ): sammel_lieferung_aggregate!

  # fetch data from the table: "sammel_lieferung" using primary key columns
  sammel_lieferung_by_pk(id: ID!): sammel_lieferung

  # fetch data from the table: "sammel_lieferung_rev"
  sammel_lieferung_rev(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): [sammel_lieferung_rev!]!

  # fetch aggregated fields from the table: "sammel_lieferung_rev"
  sammel_lieferung_rev_aggregate(
    # distinct select on columns
    distinct_on: [sammel_lieferung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammel_lieferung_rev_order_by!]

    # filter the rows returned
    where: sammel_lieferung_rev_bool_exp
  ): sammel_lieferung_rev_aggregate!

  # fetch data from the table: "sammel_lieferung_rev" using primary key columns
  sammel_lieferung_rev_by_pk(id: ID!): sammel_lieferung_rev

  # fetch data from the table: "sammlung"
  sammlung(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): [sammlung!]!

  # fetch aggregated fields from the table: "sammlung"
  sammlung_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_order_by!]

    # filter the rows returned
    where: sammlung_bool_exp
  ): sammlung_aggregate!

  # fetch data from the table: "sammlung" using primary key columns
  sammlung_by_pk(id: ID!): sammlung

  # fetch data from the table: "sammlung_file"
  sammlung_file(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): [sammlung_file!]!

  # fetch aggregated fields from the table: "sammlung_file"
  sammlung_file_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_file_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_file_order_by!]

    # filter the rows returned
    where: sammlung_file_bool_exp
  ): sammlung_file_aggregate!

  # fetch data from the table: "sammlung_file" using primary key columns
  sammlung_file_by_pk(id: ID!): sammlung_file

  # fetch data from the table: "sammlung_rev"
  sammlung_rev(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): [sammlung_rev!]!

  # fetch aggregated fields from the table: "sammlung_rev"
  sammlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [sammlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sammlung_rev_order_by!]

    # filter the rows returned
    where: sammlung_rev_bool_exp
  ): sammlung_rev_aggregate!

  # fetch data from the table: "sammlung_rev" using primary key columns
  sammlung_rev_by_pk(id: ID!): sammlung_rev

  # fetch data from the table: "spatial_ref_sys"
  spatial_ref_sys(
    # distinct select on columns
    distinct_on: [spatial_ref_sys_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [spatial_ref_sys_order_by!]

    # filter the rows returned
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  # fetch aggregated fields from the table: "spatial_ref_sys"
  spatial_ref_sys_aggregate(
    # distinct select on columns
    distinct_on: [spatial_ref_sys_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [spatial_ref_sys_order_by!]

    # filter the rows returned
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  # fetch data from the table: "spatial_ref_sys" using primary key columns
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  # fetch data from the table: "teilkultur"
  teilkultur(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): [teilkultur!]!

  # fetch aggregated fields from the table: "teilkultur"
  teilkultur_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_order_by!]

    # filter the rows returned
    where: teilkultur_bool_exp
  ): teilkultur_aggregate!

  # fetch data from the table: "teilkultur" using primary key columns
  teilkultur_by_pk(id: ID!): teilkultur

  # fetch data from the table: "teilkultur_rev"
  teilkultur_rev(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): [teilkultur_rev!]!

  # fetch aggregated fields from the table: "teilkultur_rev"
  teilkultur_rev_aggregate(
    # distinct select on columns
    distinct_on: [teilkultur_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilkultur_rev_order_by!]

    # filter the rows returned
    where: teilkultur_rev_bool_exp
  ): teilkultur_rev_aggregate!

  # fetch data from the table: "teilkultur_rev" using primary key columns
  teilkultur_rev_by_pk(id: ID!): teilkultur_rev

  # fetch data from the table: "teilzaehlung"
  teilzaehlung(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # fetch aggregated fields from the table: "teilzaehlung"
  teilzaehlung_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!

  # fetch data from the table: "teilzaehlung" using primary key columns
  teilzaehlung_by_pk(id: ID!): teilzaehlung

  # fetch data from the table: "teilzaehlung_rev"
  teilzaehlung_rev(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): [teilzaehlung_rev!]!

  # fetch aggregated fields from the table: "teilzaehlung_rev"
  teilzaehlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): teilzaehlung_rev_aggregate!

  # fetch data from the table: "teilzaehlung_rev" using primary key columns
  teilzaehlung_rev_by_pk(id: ID!): teilzaehlung_rev

  # fetch data from the table: "user_role"
  user_role(
    # distinct select on columns
    distinct_on: [user_role_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_role_order_by!]

    # filter the rows returned
    where: user_role_bool_exp
  ): [user_role!]!

  # fetch aggregated fields from the table: "user_role"
  user_role_aggregate(
    # distinct select on columns
    distinct_on: [user_role_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_role_order_by!]

    # filter the rows returned
    where: user_role_bool_exp
  ): user_role_aggregate!

  # fetch data from the table: "user_role" using primary key columns
  user_role_by_pk(id: ID!): user_role

  # fetch data from the table: "zaehlung"
  zaehlung(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): [zaehlung!]!

  # fetch aggregated fields from the table: "zaehlung"
  zaehlung_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_order_by!]

    # filter the rows returned
    where: zaehlung_bool_exp
  ): zaehlung_aggregate!

  # fetch data from the table: "zaehlung" using primary key columns
  zaehlung_by_pk(id: ID!): zaehlung

  # fetch data from the table: "zaehlung_rev"
  zaehlung_rev(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): [zaehlung_rev!]!

  # fetch aggregated fields from the table: "zaehlung_rev"
  zaehlung_rev_aggregate(
    # distinct select on columns
    distinct_on: [zaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [zaehlung_rev_order_by!]

    # filter the rows returned
    where: zaehlung_rev_bool_exp
  ): zaehlung_rev_aggregate!

  # fetch data from the table: "zaehlung_rev" using primary key columns
  zaehlung_rev_by_pk(id: ID!): zaehlung_rev
}

# columns and relationships of "teilkultur"
type teilkultur {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String

  # An array relationship
  event_revs(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): [event_rev!]!

  # An aggregated array relationship
  event_revs_aggregate(
    # distinct select on columns
    distinct_on: [event_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_rev_order_by!]

    # filter the rows returned
    where: event_rev_bool_exp
  ): event_rev_aggregate!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String

  # An array relationship
  teilzaehlung_revs(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): [teilzaehlung_rev!]!

  # An aggregated array relationship
  teilzaehlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): teilzaehlung_rev_aggregate!

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!
}

# aggregated selection of "teilkultur"
type teilkultur_aggregate {
  aggregate: teilkultur_aggregate_fields
  nodes: [teilkultur!]!
}

# aggregate fields of "teilkultur"
type teilkultur_aggregate_fields {
  avg: teilkultur_avg_fields
  count(columns: [teilkultur_select_column!], distinct: Boolean): Int
  max: teilkultur_max_fields
  min: teilkultur_min_fields
  stddev: teilkultur_stddev_fields
  stddev_pop: teilkultur_stddev_pop_fields
  stddev_samp: teilkultur_stddev_samp_fields
  sum: teilkultur_sum_fields
  var_pop: teilkultur_var_pop_fields
  var_samp: teilkultur_var_samp_fields
  variance: teilkultur_variance_fields
}

# order by aggregate values of table "teilkultur"
input teilkultur_aggregate_order_by {
  avg: teilkultur_avg_order_by
  count: order_by
  max: teilkultur_max_order_by
  min: teilkultur_min_order_by
  stddev: teilkultur_stddev_order_by
  stddev_pop: teilkultur_stddev_pop_order_by
  stddev_samp: teilkultur_stddev_samp_order_by
  sum: teilkultur_sum_order_by
  var_pop: teilkultur_var_pop_order_by
  var_samp: teilkultur_var_samp_order_by
  variance: teilkultur_variance_order_by
}

# input type for inserting array relation for remote table "teilkultur"
input teilkultur_arr_rel_insert_input {
  data: [teilkultur_insert_input!]!
  on_conflict: teilkultur_on_conflict
}

# aggregate avg on columns
type teilkultur_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "teilkultur"
input teilkultur_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "teilkultur". All fields are combined with a logical 'AND'.
input teilkultur_bool_exp {
  _and: [teilkultur_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: teilkultur_bool_exp
  _or: [teilkultur_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  event_revs: event_rev_bool_exp
  events: event_bool_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  name: String_comparison_exp
  ort1: String_comparison_exp
  ort2: String_comparison_exp
  ort3: String_comparison_exp
  teilzaehlung_revs: teilzaehlung_rev_bool_exp
  teilzaehlungs: teilzaehlung_bool_exp
}

# unique or primary key constraints on table "teilkultur"
enum teilkultur_constraint {
  # unique or primary key constraint
  teilkultur_pkey
}

# input type for incrementing integer column in table "teilkultur"
input teilkultur_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "teilkultur"
input teilkultur_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  event_revs: event_rev_arr_rel_insert_input
  events: event_arr_rel_insert_input
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilzaehlung_revs: teilzaehlung_rev_arr_rel_insert_input
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
}

# aggregate max on columns
type teilkultur_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
}

# order by max() on columns of table "teilkultur"
input teilkultur_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
}

# aggregate min on columns
type teilkultur_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
}

# order by min() on columns of table "teilkultur"
input teilkultur_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
}

# response of any mutation on the table "teilkultur"
type teilkultur_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [teilkultur!]!
}

# input type for inserting object relation for remote table "teilkultur"
input teilkultur_obj_rel_insert_input {
  data: teilkultur_insert_input!
  on_conflict: teilkultur_on_conflict
}

# on conflict condition type for table "teilkultur"
input teilkultur_on_conflict {
  constraint: teilkultur_constraint!
  update_columns: [teilkultur_update_column!]!
  where: teilkultur_bool_exp
}

# ordering options when selecting data from "teilkultur"
input teilkultur_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  event_revs_aggregate: event_rev_aggregate_order_by
  events_aggregate: event_aggregate_order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
  teilzaehlung_revs_aggregate: teilzaehlung_rev_aggregate_order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
}

# primary key columns input for table: "teilkultur"
input teilkultur_pk_columns_input {
  id: ID!
}

# columns and relationships of "teilkultur_rev"
type teilkultur_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilkultur_id: uuid!

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!
}

# aggregated selection of "teilkultur_rev"
type teilkultur_rev_aggregate {
  aggregate: teilkultur_rev_aggregate_fields
  nodes: [teilkultur_rev!]!
}

# aggregate fields of "teilkultur_rev"
type teilkultur_rev_aggregate_fields {
  avg: teilkultur_rev_avg_fields
  count(columns: [teilkultur_rev_select_column!], distinct: Boolean): Int
  max: teilkultur_rev_max_fields
  min: teilkultur_rev_min_fields
  stddev: teilkultur_rev_stddev_fields
  stddev_pop: teilkultur_rev_stddev_pop_fields
  stddev_samp: teilkultur_rev_stddev_samp_fields
  sum: teilkultur_rev_sum_fields
  var_pop: teilkultur_rev_var_pop_fields
  var_samp: teilkultur_rev_var_samp_fields
  variance: teilkultur_rev_variance_fields
}

# order by aggregate values of table "teilkultur_rev"
input teilkultur_rev_aggregate_order_by {
  avg: teilkultur_rev_avg_order_by
  count: order_by
  max: teilkultur_rev_max_order_by
  min: teilkultur_rev_min_order_by
  stddev: teilkultur_rev_stddev_order_by
  stddev_pop: teilkultur_rev_stddev_pop_order_by
  stddev_samp: teilkultur_rev_stddev_samp_order_by
  sum: teilkultur_rev_sum_order_by
  var_pop: teilkultur_rev_var_pop_order_by
  var_samp: teilkultur_rev_var_samp_order_by
  variance: teilkultur_rev_variance_order_by
}

# input type for inserting array relation for remote table "teilkultur_rev"
input teilkultur_rev_arr_rel_insert_input {
  data: [teilkultur_rev_insert_input!]!
  on_conflict: teilkultur_rev_on_conflict
}

# aggregate avg on columns
type teilkultur_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "teilkultur_rev"
input teilkultur_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "teilkultur_rev". All fields are combined with a logical 'AND'.
input teilkultur_rev_bool_exp {
  _and: [teilkultur_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: teilkultur_rev_bool_exp
  _or: [teilkultur_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  events: event_bool_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  name: String_comparison_exp
  ort1: String_comparison_exp
  ort2: String_comparison_exp
  ort3: String_comparison_exp
  teilkultur_id: uuid_comparison_exp
  teilzaehlungs: teilzaehlung_bool_exp
}

# unique or primary key constraints on table "teilkultur_rev"
enum teilkultur_rev_constraint {
  # unique or primary key constraint
  teilkultur_rev_pkey
}

# input type for incrementing integer column in table "teilkultur_rev"
input teilkultur_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "teilkultur_rev"
input teilkultur_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  events: event_arr_rel_insert_input
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilkultur_id: uuid
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
}

# aggregate max on columns
type teilkultur_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilkultur_id: uuid
}

# order by max() on columns of table "teilkultur_rev"
input teilkultur_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
  teilkultur_id: order_by
}

# aggregate min on columns
type teilkultur_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilkultur_id: uuid
}

# order by min() on columns of table "teilkultur_rev"
input teilkultur_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
  teilkultur_id: order_by
}

# response of any mutation on the table "teilkultur_rev"
type teilkultur_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [teilkultur_rev!]!
}

# input type for inserting object relation for remote table "teilkultur_rev"
input teilkultur_rev_obj_rel_insert_input {
  data: teilkultur_rev_insert_input!
  on_conflict: teilkultur_rev_on_conflict
}

# on conflict condition type for table "teilkultur_rev"
input teilkultur_rev_on_conflict {
  constraint: teilkultur_rev_constraint!
  update_columns: [teilkultur_rev_update_column!]!
  where: teilkultur_rev_bool_exp
}

# ordering options when selecting data from "teilkultur_rev"
input teilkultur_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  events_aggregate: event_aggregate_order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  name: order_by
  ort1: order_by
  ort2: order_by
  ort3: order_by
  teilkultur_id: order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
}

# primary key columns input for table: "teilkultur_rev"
input teilkultur_rev_pk_columns_input {
  id: ID!
}

# select columns of table "teilkultur_rev"
enum teilkultur_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_id

  # column name
  name

  # column name
  ort1

  # column name
  ort2

  # column name
  ort3

  # column name
  teilkultur_id
}

# input type for updating data in table "teilkultur_rev"
input teilkultur_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
  teilkultur_id: uuid
}

# aggregate stddev on columns
type teilkultur_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "teilkultur_rev"
input teilkultur_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type teilkultur_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "teilkultur_rev"
input teilkultur_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type teilkultur_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "teilkultur_rev"
input teilkultur_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type teilkultur_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "teilkultur_rev"
input teilkultur_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "teilkultur_rev"
enum teilkultur_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_id

  # column name
  name

  # column name
  ort1

  # column name
  ort2

  # column name
  ort3

  # column name
  teilkultur_id
}

# aggregate var_pop on columns
type teilkultur_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "teilkultur_rev"
input teilkultur_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type teilkultur_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "teilkultur_rev"
input teilkultur_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type teilkultur_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "teilkultur_rev"
input teilkultur_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "teilkultur"
enum teilkultur_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_id

  # column name
  name

  # column name
  ort1

  # column name
  ort2

  # column name
  ort3
}

# input type for updating data in table "teilkultur"
input teilkultur_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  kultur_id: uuid
  name: String
  ort1: String
  ort2: String
  ort3: String
}

# aggregate stddev on columns
type teilkultur_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "teilkultur"
input teilkultur_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type teilkultur_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "teilkultur"
input teilkultur_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type teilkultur_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "teilkultur"
input teilkultur_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type teilkultur_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "teilkultur"
input teilkultur_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "teilkultur"
enum teilkultur_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  kultur_id

  # column name
  name

  # column name
  ort1

  # column name
  ort2

  # column name
  ort3
}

# aggregate var_pop on columns
type teilkultur_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "teilkultur"
input teilkultur_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type teilkultur_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "teilkultur"
input teilkultur_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type teilkultur_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "teilkultur"
input teilkultur_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# columns and relationships of "teilzaehlung"
type teilzaehlung {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID!
  prognose_von_tz: uuid

  # An object relationship
  teilkultur: teilkultur
  teilkultur_id: uuid

  # An object relationship
  teilzaehlung: teilzaehlung

  # An array relationship
  teilzaehlung_revs(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): [teilzaehlung_rev!]!

  # An aggregated array relationship
  teilzaehlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): teilzaehlung_rev_aggregate!

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!

  # An object relationship
  zaehlung: zaehlung
  zaehlung_id: uuid
}

# aggregated selection of "teilzaehlung"
type teilzaehlung_aggregate {
  aggregate: teilzaehlung_aggregate_fields
  nodes: [teilzaehlung!]!
}

# aggregate fields of "teilzaehlung"
type teilzaehlung_aggregate_fields {
  avg: teilzaehlung_avg_fields
  count(columns: [teilzaehlung_select_column!], distinct: Boolean): Int
  max: teilzaehlung_max_fields
  min: teilzaehlung_min_fields
  stddev: teilzaehlung_stddev_fields
  stddev_pop: teilzaehlung_stddev_pop_fields
  stddev_samp: teilzaehlung_stddev_samp_fields
  sum: teilzaehlung_sum_fields
  var_pop: teilzaehlung_var_pop_fields
  var_samp: teilzaehlung_var_samp_fields
  variance: teilzaehlung_variance_fields
}

# order by aggregate values of table "teilzaehlung"
input teilzaehlung_aggregate_order_by {
  avg: teilzaehlung_avg_order_by
  count: order_by
  max: teilzaehlung_max_order_by
  min: teilzaehlung_min_order_by
  stddev: teilzaehlung_stddev_order_by
  stddev_pop: teilzaehlung_stddev_pop_order_by
  stddev_samp: teilzaehlung_stddev_samp_order_by
  sum: teilzaehlung_sum_order_by
  var_pop: teilzaehlung_var_pop_order_by
  var_samp: teilzaehlung_var_samp_order_by
  variance: teilzaehlung_variance_order_by
}

# input type for inserting array relation for remote table "teilzaehlung"
input teilzaehlung_arr_rel_insert_input {
  data: [teilzaehlung_insert_input!]!
  on_conflict: teilzaehlung_on_conflict
}

# aggregate avg on columns
type teilzaehlung_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by avg() on columns of table "teilzaehlung"
input teilzaehlung_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# Boolean expression to filter rows from the table "teilzaehlung". All fields are combined with a logical 'AND'.
input teilzaehlung_bool_exp {
  _and: [teilzaehlung_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: teilzaehlung_bool_exp
  _or: [teilzaehlung_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_mutterpflanzen: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  auspflanzbereit_beschreibung: String_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  prognose_von_tz: uuid_comparison_exp
  teilkultur: teilkultur_bool_exp
  teilkultur_id: uuid_comparison_exp
  teilzaehlung: teilzaehlung_bool_exp
  teilzaehlung_revs: teilzaehlung_rev_bool_exp
  teilzaehlungs: teilzaehlung_bool_exp
  zaehlung: zaehlung_bool_exp
  zaehlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "teilzaehlung"
enum teilzaehlung_constraint {
  # unique or primary key constraint
  teilzaehlung_pkey
}

# input type for incrementing integer column in table "teilzaehlung"
input teilzaehlung_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
}

# input type for inserting data into table "teilzaehlung"
input teilzaehlung_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur: teilkultur_obj_rel_insert_input
  teilkultur_id: uuid
  teilzaehlung: teilzaehlung_obj_rel_insert_input
  teilzaehlung_revs: teilzaehlung_rev_arr_rel_insert_input
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
  zaehlung: zaehlung_obj_rel_insert_input
  zaehlung_id: uuid
}

# aggregate max on columns
type teilzaehlung_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  zaehlung_id: uuid
}

# order by max() on columns of table "teilzaehlung"
input teilzaehlung_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur_id: order_by
  zaehlung_id: order_by
}

# aggregate min on columns
type teilzaehlung_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  zaehlung_id: uuid
}

# order by min() on columns of table "teilzaehlung"
input teilzaehlung_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur_id: order_by
  zaehlung_id: order_by
}

# response of any mutation on the table "teilzaehlung"
type teilzaehlung_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [teilzaehlung!]!
}

# input type for inserting object relation for remote table "teilzaehlung"
input teilzaehlung_obj_rel_insert_input {
  data: teilzaehlung_insert_input!
  on_conflict: teilzaehlung_on_conflict
}

# on conflict condition type for table "teilzaehlung"
input teilzaehlung_on_conflict {
  constraint: teilzaehlung_constraint!
  update_columns: [teilzaehlung_update_column!]!
  where: teilzaehlung_bool_exp
}

# ordering options when selecting data from "teilzaehlung"
input teilzaehlung_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur: teilkultur_order_by
  teilkultur_id: order_by
  teilzaehlung: teilzaehlung_order_by
  teilzaehlung_revs_aggregate: teilzaehlung_rev_aggregate_order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
  zaehlung: zaehlung_order_by
  zaehlung_id: order_by
}

# primary key columns input for table: "teilzaehlung"
input teilzaehlung_pk_columns_input {
  id: ID!
}

# columns and relationships of "teilzaehlung_rev"
type teilzaehlung_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID!
  prognose_von_tz: uuid

  # An object relationship
  teilkultur: teilkultur
  teilkultur_id: uuid

  # An object relationship
  teilzaehlung: teilzaehlung
  teilzaehlung_id: uuid!

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!

  # An object relationship
  zaehlung: zaehlung
  zaehlung_id: uuid
}

# aggregated selection of "teilzaehlung_rev"
type teilzaehlung_rev_aggregate {
  aggregate: teilzaehlung_rev_aggregate_fields
  nodes: [teilzaehlung_rev!]!
}

# aggregate fields of "teilzaehlung_rev"
type teilzaehlung_rev_aggregate_fields {
  avg: teilzaehlung_rev_avg_fields
  count(columns: [teilzaehlung_rev_select_column!], distinct: Boolean): Int
  max: teilzaehlung_rev_max_fields
  min: teilzaehlung_rev_min_fields
  stddev: teilzaehlung_rev_stddev_fields
  stddev_pop: teilzaehlung_rev_stddev_pop_fields
  stddev_samp: teilzaehlung_rev_stddev_samp_fields
  sum: teilzaehlung_rev_sum_fields
  var_pop: teilzaehlung_rev_var_pop_fields
  var_samp: teilzaehlung_rev_var_samp_fields
  variance: teilzaehlung_rev_variance_fields
}

# order by aggregate values of table "teilzaehlung_rev"
input teilzaehlung_rev_aggregate_order_by {
  avg: teilzaehlung_rev_avg_order_by
  count: order_by
  max: teilzaehlung_rev_max_order_by
  min: teilzaehlung_rev_min_order_by
  stddev: teilzaehlung_rev_stddev_order_by
  stddev_pop: teilzaehlung_rev_stddev_pop_order_by
  stddev_samp: teilzaehlung_rev_stddev_samp_order_by
  sum: teilzaehlung_rev_sum_order_by
  var_pop: teilzaehlung_rev_var_pop_order_by
  var_samp: teilzaehlung_rev_var_samp_order_by
  variance: teilzaehlung_rev_variance_order_by
}

# input type for inserting array relation for remote table "teilzaehlung_rev"
input teilzaehlung_rev_arr_rel_insert_input {
  data: [teilzaehlung_rev_insert_input!]!
  on_conflict: teilzaehlung_rev_on_conflict
}

# aggregate avg on columns
type teilzaehlung_rev_avg_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by avg() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# Boolean expression to filter rows from the table "teilzaehlung_rev". All fields are combined with a logical 'AND'.
input teilzaehlung_rev_bool_exp {
  _and: [teilzaehlung_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: teilzaehlung_rev_bool_exp
  _or: [teilzaehlung_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  andere_menge: String_comparison_exp
  anzahl_auspflanzbereit: Int_comparison_exp
  anzahl_mutterpflanzen: Int_comparison_exp
  anzahl_pflanzen: Int_comparison_exp
  auspflanzbereit_beschreibung: String_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  id: uuid_comparison_exp
  prognose_von_tz: uuid_comparison_exp
  teilkultur: teilkultur_bool_exp
  teilkultur_id: uuid_comparison_exp
  teilzaehlung: teilzaehlung_bool_exp
  teilzaehlung_id: uuid_comparison_exp
  teilzaehlungs: teilzaehlung_bool_exp
  zaehlung: zaehlung_bool_exp
  zaehlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "teilzaehlung_rev"
enum teilzaehlung_rev_constraint {
  # unique or primary key constraint
  teilzaehlung_rev_pkey
}

# input type for incrementing integer column in table "teilzaehlung_rev"
input teilzaehlung_rev_inc_input {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
}

# input type for inserting data into table "teilzaehlung_rev"
input teilzaehlung_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur: teilkultur_obj_rel_insert_input
  teilkultur_id: uuid
  teilzaehlung: teilzaehlung_obj_rel_insert_input
  teilzaehlung_id: uuid
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
  zaehlung: zaehlung_obj_rel_insert_input
  zaehlung_id: uuid
}

# aggregate max on columns
type teilzaehlung_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  teilzaehlung_id: uuid
  zaehlung_id: uuid
}

# order by max() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur_id: order_by
  teilzaehlung_id: order_by
  zaehlung_id: order_by
}

# aggregate min on columns
type teilzaehlung_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  teilzaehlung_id: uuid
  zaehlung_id: uuid
}

# order by min() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur_id: order_by
  teilzaehlung_id: order_by
  zaehlung_id: order_by
}

# response of any mutation on the table "teilzaehlung_rev"
type teilzaehlung_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [teilzaehlung_rev!]!
}

# input type for inserting object relation for remote table "teilzaehlung_rev"
input teilzaehlung_rev_obj_rel_insert_input {
  data: teilzaehlung_rev_insert_input!
  on_conflict: teilzaehlung_rev_on_conflict
}

# on conflict condition type for table "teilzaehlung_rev"
input teilzaehlung_rev_on_conflict {
  constraint: teilzaehlung_rev_constraint!
  update_columns: [teilzaehlung_rev_update_column!]!
  where: teilzaehlung_rev_bool_exp
}

# ordering options when selecting data from "teilzaehlung_rev"
input teilzaehlung_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  andere_menge: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
  auspflanzbereit_beschreibung: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  id: order_by
  prognose_von_tz: order_by
  teilkultur: teilkultur_order_by
  teilkultur_id: order_by
  teilzaehlung: teilzaehlung_order_by
  teilzaehlung_id: order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
  zaehlung: zaehlung_order_by
  zaehlung_id: order_by
}

# primary key columns input for table: "teilzaehlung_rev"
input teilzaehlung_rev_pk_columns_input {
  id: ID!
}

# select columns of table "teilzaehlung_rev"
enum teilzaehlung_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_mutterpflanzen

  # column name
  anzahl_pflanzen

  # column name
  auspflanzbereit_beschreibung

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  prognose_von_tz

  # column name
  teilkultur_id

  # column name
  teilzaehlung_id

  # column name
  zaehlung_id
}

# input type for updating data in table "teilzaehlung_rev"
input teilzaehlung_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  teilzaehlung_id: uuid
  zaehlung_id: uuid
}

# aggregate stddev on columns
type teilzaehlung_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate stddev_pop on columns
type teilzaehlung_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev_pop() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate stddev_samp on columns
type teilzaehlung_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev_samp() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate sum on columns
type teilzaehlung_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
}

# order by sum() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# update columns of table "teilzaehlung_rev"
enum teilzaehlung_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_mutterpflanzen

  # column name
  anzahl_pflanzen

  # column name
  auspflanzbereit_beschreibung

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  prognose_von_tz

  # column name
  teilkultur_id

  # column name
  teilzaehlung_id

  # column name
  zaehlung_id
}

# aggregate var_pop on columns
type teilzaehlung_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by var_pop() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate var_samp on columns
type teilzaehlung_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by var_samp() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate variance on columns
type teilzaehlung_rev_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by variance() on columns of table "teilzaehlung_rev"
input teilzaehlung_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# select columns of table "teilzaehlung"
enum teilzaehlung_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_mutterpflanzen

  # column name
  anzahl_pflanzen

  # column name
  auspflanzbereit_beschreibung

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  prognose_von_tz

  # column name
  teilkultur_id

  # column name
  zaehlung_id
}

# input type for updating data in table "teilzaehlung"
input teilzaehlung_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  andere_menge: String
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
  auspflanzbereit_beschreibung: String
  bemerkungen: String
  changed: timestamp
  changed_by: String
  id: ID
  prognose_von_tz: uuid
  teilkultur_id: uuid
  zaehlung_id: uuid
}

# aggregate stddev on columns
type teilzaehlung_stddev_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev() on columns of table "teilzaehlung"
input teilzaehlung_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate stddev_pop on columns
type teilzaehlung_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev_pop() on columns of table "teilzaehlung"
input teilzaehlung_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate stddev_samp on columns
type teilzaehlung_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by stddev_samp() on columns of table "teilzaehlung"
input teilzaehlung_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate sum on columns
type teilzaehlung_sum_fields {
  _depth: Int
  _rev_at: numeric
  anzahl_auspflanzbereit: Int
  anzahl_mutterpflanzen: Int
  anzahl_pflanzen: Int
}

# order by sum() on columns of table "teilzaehlung"
input teilzaehlung_sum_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# update columns of table "teilzaehlung"
enum teilzaehlung_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  andere_menge

  # column name
  anzahl_auspflanzbereit

  # column name
  anzahl_mutterpflanzen

  # column name
  anzahl_pflanzen

  # column name
  auspflanzbereit_beschreibung

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  id

  # column name
  prognose_von_tz

  # column name
  teilkultur_id

  # column name
  zaehlung_id
}

# aggregate var_pop on columns
type teilzaehlung_var_pop_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by var_pop() on columns of table "teilzaehlung"
input teilzaehlung_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate var_samp on columns
type teilzaehlung_var_samp_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by var_samp() on columns of table "teilzaehlung"
input teilzaehlung_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

# aggregate variance on columns
type teilzaehlung_variance_fields {
  _depth: Float
  _rev_at: Float
  anzahl_auspflanzbereit: Float
  anzahl_mutterpflanzen: Float
  anzahl_pflanzen: Float
}

# order by variance() on columns of table "teilzaehlung"
input teilzaehlung_variance_order_by {
  _depth: order_by
  _rev_at: order_by
  anzahl_auspflanzbereit: order_by
  anzahl_mutterpflanzen: order_by
  anzahl_pflanzen: order_by
}

scalar timestamp

# expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

# columns and relationships of "user_role"
type user_role {
  _rev_at: numeric
  changed: timestamp
  comment: String
  id: ID!
  label: String
  name: String!
  sort: Int
}

# aggregated selection of "user_role"
type user_role_aggregate {
  aggregate: user_role_aggregate_fields
  nodes: [user_role!]!
}

# aggregate fields of "user_role"
type user_role_aggregate_fields {
  avg: user_role_avg_fields
  count(columns: [user_role_select_column!], distinct: Boolean): Int
  max: user_role_max_fields
  min: user_role_min_fields
  stddev: user_role_stddev_fields
  stddev_pop: user_role_stddev_pop_fields
  stddev_samp: user_role_stddev_samp_fields
  sum: user_role_sum_fields
  var_pop: user_role_var_pop_fields
  var_samp: user_role_var_samp_fields
  variance: user_role_variance_fields
}

# order by aggregate values of table "user_role"
input user_role_aggregate_order_by {
  avg: user_role_avg_order_by
  count: order_by
  max: user_role_max_order_by
  min: user_role_min_order_by
  stddev: user_role_stddev_order_by
  stddev_pop: user_role_stddev_pop_order_by
  stddev_samp: user_role_stddev_samp_order_by
  sum: user_role_sum_order_by
  var_pop: user_role_var_pop_order_by
  var_samp: user_role_var_samp_order_by
  variance: user_role_variance_order_by
}

# input type for inserting array relation for remote table "user_role"
input user_role_arr_rel_insert_input {
  data: [user_role_insert_input!]!
  on_conflict: user_role_on_conflict
}

# aggregate avg on columns
type user_role_avg_fields {
  _rev_at: Float
  sort: Float
}

# order by avg() on columns of table "user_role"
input user_role_avg_order_by {
  _rev_at: order_by
  sort: order_by
}

# Boolean expression to filter rows from the table "user_role". All fields are combined with a logical 'AND'.
input user_role_bool_exp {
  _and: [user_role_bool_exp]
  _not: user_role_bool_exp
  _or: [user_role_bool_exp]
  _rev_at: numeric_comparison_exp
  changed: timestamp_comparison_exp
  comment: String_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  name: String_comparison_exp
  sort: Int_comparison_exp
}

# unique or primary key constraints on table "user_role"
enum user_role_constraint {
  # unique or primary key constraint
  user_role_name_key

  # unique or primary key constraint
  user_role_pkey
}

# input type for incrementing integer column in table "user_role"
input user_role_inc_input {
  _rev_at: numeric
  sort: Int
}

# input type for inserting data into table "user_role"
input user_role_insert_input {
  _rev_at: numeric
  changed: timestamp
  comment: String
  id: ID
  label: String
  name: String
  sort: Int
}

# aggregate max on columns
type user_role_max_fields {
  _rev_at: numeric
  changed: timestamp
  comment: String
  id: ID
  label: String
  name: String
  sort: Int
}

# order by max() on columns of table "user_role"
input user_role_max_order_by {
  _rev_at: order_by
  changed: order_by
  comment: order_by
  id: order_by
  label: order_by
  name: order_by
  sort: order_by
}

# aggregate min on columns
type user_role_min_fields {
  _rev_at: numeric
  changed: timestamp
  comment: String
  id: ID
  label: String
  name: String
  sort: Int
}

# order by min() on columns of table "user_role"
input user_role_min_order_by {
  _rev_at: order_by
  changed: order_by
  comment: order_by
  id: order_by
  label: order_by
  name: order_by
  sort: order_by
}

# response of any mutation on the table "user_role"
type user_role_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [user_role!]!
}

# input type for inserting object relation for remote table "user_role"
input user_role_obj_rel_insert_input {
  data: user_role_insert_input!
  on_conflict: user_role_on_conflict
}

# on conflict condition type for table "user_role"
input user_role_on_conflict {
  constraint: user_role_constraint!
  update_columns: [user_role_update_column!]!
  where: user_role_bool_exp
}

# ordering options when selecting data from "user_role"
input user_role_order_by {
  _rev_at: order_by
  changed: order_by
  comment: order_by
  id: order_by
  label: order_by
  name: order_by
  sort: order_by
}

# primary key columns input for table: "user_role"
input user_role_pk_columns_input {
  id: ID!
}

# select columns of table "user_role"
enum user_role_select_column {
  # column name
  _rev_at

  # column name
  changed

  # column name
  comment

  # column name
  id

  # column name
  label

  # column name
  name

  # column name
  sort
}

# input type for updating data in table "user_role"
input user_role_set_input {
  _rev_at: numeric
  changed: timestamp
  comment: String
  id: ID
  label: String
  name: String
  sort: Int
}

# aggregate stddev on columns
type user_role_stddev_fields {
  _rev_at: Float
  sort: Float
}

# order by stddev() on columns of table "user_role"
input user_role_stddev_order_by {
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_pop on columns
type user_role_stddev_pop_fields {
  _rev_at: Float
  sort: Float
}

# order by stddev_pop() on columns of table "user_role"
input user_role_stddev_pop_order_by {
  _rev_at: order_by
  sort: order_by
}

# aggregate stddev_samp on columns
type user_role_stddev_samp_fields {
  _rev_at: Float
  sort: Float
}

# order by stddev_samp() on columns of table "user_role"
input user_role_stddev_samp_order_by {
  _rev_at: order_by
  sort: order_by
}

# aggregate sum on columns
type user_role_sum_fields {
  _rev_at: numeric
  sort: Int
}

# order by sum() on columns of table "user_role"
input user_role_sum_order_by {
  _rev_at: order_by
  sort: order_by
}

# update columns of table "user_role"
enum user_role_update_column {
  # column name
  _rev_at

  # column name
  changed

  # column name
  comment

  # column name
  id

  # column name
  label

  # column name
  name

  # column name
  sort
}

# aggregate var_pop on columns
type user_role_var_pop_fields {
  _rev_at: Float
  sort: Float
}

# order by var_pop() on columns of table "user_role"
input user_role_var_pop_order_by {
  _rev_at: order_by
  sort: order_by
}

# aggregate var_samp on columns
type user_role_var_samp_fields {
  _rev_at: Float
  sort: Float
}

# order by var_samp() on columns of table "user_role"
input user_role_var_samp_order_by {
  _rev_at: order_by
  sort: order_by
}

# aggregate variance on columns
type user_role_variance_fields {
  _rev_at: Float
  sort: Float
}

# order by variance() on columns of table "user_role"
input user_role_variance_order_by {
  _rev_at: order_by
  sort: order_by
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

# columns and relationships of "zaehlung"
type zaehlung {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid
  prognose: Boolean

  # An array relationship
  teilzaehlung_revs(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): [teilzaehlung_rev!]!

  # An aggregated array relationship
  teilzaehlung_revs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_rev_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_rev_order_by!]

    # filter the rows returned
    where: teilzaehlung_rev_bool_exp
  ): teilzaehlung_rev_aggregate!

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!
}

# aggregated selection of "zaehlung"
type zaehlung_aggregate {
  aggregate: zaehlung_aggregate_fields
  nodes: [zaehlung!]!
}

# aggregate fields of "zaehlung"
type zaehlung_aggregate_fields {
  avg: zaehlung_avg_fields
  count(columns: [zaehlung_select_column!], distinct: Boolean): Int
  max: zaehlung_max_fields
  min: zaehlung_min_fields
  stddev: zaehlung_stddev_fields
  stddev_pop: zaehlung_stddev_pop_fields
  stddev_samp: zaehlung_stddev_samp_fields
  sum: zaehlung_sum_fields
  var_pop: zaehlung_var_pop_fields
  var_samp: zaehlung_var_samp_fields
  variance: zaehlung_variance_fields
}

# order by aggregate values of table "zaehlung"
input zaehlung_aggregate_order_by {
  avg: zaehlung_avg_order_by
  count: order_by
  max: zaehlung_max_order_by
  min: zaehlung_min_order_by
  stddev: zaehlung_stddev_order_by
  stddev_pop: zaehlung_stddev_pop_order_by
  stddev_samp: zaehlung_stddev_samp_order_by
  sum: zaehlung_sum_order_by
  var_pop: zaehlung_var_pop_order_by
  var_samp: zaehlung_var_samp_order_by
  variance: zaehlung_variance_order_by
}

# input type for inserting array relation for remote table "zaehlung"
input zaehlung_arr_rel_insert_input {
  data: [zaehlung_insert_input!]!
  on_conflict: zaehlung_on_conflict
}

# aggregate avg on columns
type zaehlung_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "zaehlung"
input zaehlung_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "zaehlung". All fields are combined with a logical 'AND'.
input zaehlung_bool_exp {
  _and: [zaehlung_bool_exp]
  _conflicts: _text_comparison_exp
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: zaehlung_bool_exp
  _or: [zaehlung_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  prognose: Boolean_comparison_exp
  teilzaehlung_revs: teilzaehlung_rev_bool_exp
  teilzaehlungs: teilzaehlung_bool_exp
}

# unique or primary key constraints on table "zaehlung"
enum zaehlung_constraint {
  # unique or primary key constraint
  zaehlung_pkey
}

# input type for incrementing integer column in table "zaehlung"
input zaehlung_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "zaehlung"
input zaehlung_insert_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  prognose: Boolean
  teilzaehlung_revs: teilzaehlung_rev_arr_rel_insert_input
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
}

# aggregate max on columns
type zaehlung_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
}

# order by max() on columns of table "zaehlung"
input zaehlung_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
}

# aggregate min on columns
type zaehlung_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
}

# order by min() on columns of table "zaehlung"
input zaehlung_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
}

# response of any mutation on the table "zaehlung"
type zaehlung_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [zaehlung!]!
}

# input type for inserting object relation for remote table "zaehlung"
input zaehlung_obj_rel_insert_input {
  data: zaehlung_insert_input!
  on_conflict: zaehlung_on_conflict
}

# on conflict condition type for table "zaehlung"
input zaehlung_on_conflict {
  constraint: zaehlung_constraint!
  update_columns: [zaehlung_update_column!]!
  where: zaehlung_bool_exp
}

# ordering options when selecting data from "zaehlung"
input zaehlung_order_by {
  _conflicts: order_by
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  prognose: order_by
  teilzaehlung_revs_aggregate: teilzaehlung_rev_aggregate_order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
}

# primary key columns input for table: "zaehlung"
input zaehlung_pk_columns_input {
  id: ID!
}

# columns and relationships of "zaehlung_rev"
type zaehlung_rev {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String!
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID!

  # An object relationship
  kultur: kultur
  kultur_id: uuid
  prognose: Boolean

  # An array relationship
  teilzaehlungs(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): [teilzaehlung!]!

  # An aggregated array relationship
  teilzaehlungs_aggregate(
    # distinct select on columns
    distinct_on: [teilzaehlung_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [teilzaehlung_order_by!]

    # filter the rows returned
    where: teilzaehlung_bool_exp
  ): teilzaehlung_aggregate!
  zaehlung_id: uuid!
}

# aggregated selection of "zaehlung_rev"
type zaehlung_rev_aggregate {
  aggregate: zaehlung_rev_aggregate_fields
  nodes: [zaehlung_rev!]!
}

# aggregate fields of "zaehlung_rev"
type zaehlung_rev_aggregate_fields {
  avg: zaehlung_rev_avg_fields
  count(columns: [zaehlung_rev_select_column!], distinct: Boolean): Int
  max: zaehlung_rev_max_fields
  min: zaehlung_rev_min_fields
  stddev: zaehlung_rev_stddev_fields
  stddev_pop: zaehlung_rev_stddev_pop_fields
  stddev_samp: zaehlung_rev_stddev_samp_fields
  sum: zaehlung_rev_sum_fields
  var_pop: zaehlung_rev_var_pop_fields
  var_samp: zaehlung_rev_var_samp_fields
  variance: zaehlung_rev_variance_fields
}

# order by aggregate values of table "zaehlung_rev"
input zaehlung_rev_aggregate_order_by {
  avg: zaehlung_rev_avg_order_by
  count: order_by
  max: zaehlung_rev_max_order_by
  min: zaehlung_rev_min_order_by
  stddev: zaehlung_rev_stddev_order_by
  stddev_pop: zaehlung_rev_stddev_pop_order_by
  stddev_samp: zaehlung_rev_stddev_samp_order_by
  sum: zaehlung_rev_sum_order_by
  var_pop: zaehlung_rev_var_pop_order_by
  var_samp: zaehlung_rev_var_samp_order_by
  variance: zaehlung_rev_variance_order_by
}

# input type for inserting array relation for remote table "zaehlung_rev"
input zaehlung_rev_arr_rel_insert_input {
  data: [zaehlung_rev_insert_input!]!
  on_conflict: zaehlung_rev_on_conflict
}

# aggregate avg on columns
type zaehlung_rev_avg_fields {
  _depth: Float
  _rev_at: Float
}

# order by avg() on columns of table "zaehlung_rev"
input zaehlung_rev_avg_order_by {
  _depth: order_by
  _rev_at: order_by
}

# Boolean expression to filter rows from the table "zaehlung_rev". All fields are combined with a logical 'AND'.
input zaehlung_rev_bool_exp {
  _and: [zaehlung_rev_bool_exp]
  _deleted: Boolean_comparison_exp
  _depth: Int_comparison_exp
  _not: zaehlung_rev_bool_exp
  _or: [zaehlung_rev_bool_exp]
  _parent_rev: String_comparison_exp
  _rev: String_comparison_exp
  _rev_at: numeric_comparison_exp
  _revisions: _text_comparison_exp
  bemerkungen: String_comparison_exp
  changed: timestamp_comparison_exp
  changed_by: String_comparison_exp
  datum: date_comparison_exp
  id: uuid_comparison_exp
  kultur: kultur_bool_exp
  kultur_id: uuid_comparison_exp
  prognose: Boolean_comparison_exp
  teilzaehlungs: teilzaehlung_bool_exp
  zaehlung_id: uuid_comparison_exp
}

# unique or primary key constraints on table "zaehlung_rev"
enum zaehlung_rev_constraint {
  # unique or primary key constraint
  zaehlung_rev_pkey
}

# input type for incrementing integer column in table "zaehlung_rev"
input zaehlung_rev_inc_input {
  _depth: Int
  _rev_at: numeric
}

# input type for inserting data into table "zaehlung_rev"
input zaehlung_rev_insert_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur: kultur_obj_rel_insert_input
  kultur_id: uuid
  prognose: Boolean
  teilzaehlungs: teilzaehlung_arr_rel_insert_input
  zaehlung_id: uuid
}

# aggregate max on columns
type zaehlung_rev_max_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  zaehlung_id: uuid
}

# order by max() on columns of table "zaehlung_rev"
input zaehlung_rev_max_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
  zaehlung_id: order_by
}

# aggregate min on columns
type zaehlung_rev_min_fields {
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  zaehlung_id: uuid
}

# order by min() on columns of table "zaehlung_rev"
input zaehlung_rev_min_order_by {
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur_id: order_by
  zaehlung_id: order_by
}

# response of any mutation on the table "zaehlung_rev"
type zaehlung_rev_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [zaehlung_rev!]!
}

# input type for inserting object relation for remote table "zaehlung_rev"
input zaehlung_rev_obj_rel_insert_input {
  data: zaehlung_rev_insert_input!
  on_conflict: zaehlung_rev_on_conflict
}

# on conflict condition type for table "zaehlung_rev"
input zaehlung_rev_on_conflict {
  constraint: zaehlung_rev_constraint!
  update_columns: [zaehlung_rev_update_column!]!
  where: zaehlung_rev_bool_exp
}

# ordering options when selecting data from "zaehlung_rev"
input zaehlung_rev_order_by {
  _deleted: order_by
  _depth: order_by
  _parent_rev: order_by
  _rev: order_by
  _rev_at: order_by
  _revisions: order_by
  bemerkungen: order_by
  changed: order_by
  changed_by: order_by
  datum: order_by
  id: order_by
  kultur: kultur_order_by
  kultur_id: order_by
  prognose: order_by
  teilzaehlungs_aggregate: teilzaehlung_aggregate_order_by
  zaehlung_id: order_by
}

# primary key columns input for table: "zaehlung_rev"
input zaehlung_rev_pk_columns_input {
  id: ID!
}

# select columns of table "zaehlung_rev"
enum zaehlung_rev_select_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  id

  # column name
  kultur_id

  # column name
  prognose

  # column name
  zaehlung_id
}

# input type for updating data in table "zaehlung_rev"
input zaehlung_rev_set_input {
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  prognose: Boolean
  zaehlung_id: uuid
}

# aggregate stddev on columns
type zaehlung_rev_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "zaehlung_rev"
input zaehlung_rev_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type zaehlung_rev_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "zaehlung_rev"
input zaehlung_rev_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type zaehlung_rev_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "zaehlung_rev"
input zaehlung_rev_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type zaehlung_rev_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "zaehlung_rev"
input zaehlung_rev_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "zaehlung_rev"
enum zaehlung_rev_update_column {
  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  id

  # column name
  kultur_id

  # column name
  prognose

  # column name
  zaehlung_id
}

# aggregate var_pop on columns
type zaehlung_rev_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "zaehlung_rev"
input zaehlung_rev_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type zaehlung_rev_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "zaehlung_rev"
input zaehlung_rev_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type zaehlung_rev_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "zaehlung_rev"
input zaehlung_rev_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}

# select columns of table "zaehlung"
enum zaehlung_select_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  id

  # column name
  kultur_id

  # column name
  prognose
}

# input type for updating data in table "zaehlung"
input zaehlung_set_input {
  _conflicts: _text
  _deleted: Boolean
  _depth: Int
  _parent_rev: String
  _rev: String
  _rev_at: numeric
  _revisions: _text
  bemerkungen: String
  changed: timestamp
  changed_by: String
  datum: date
  id: ID
  kultur_id: uuid
  prognose: Boolean
}

# aggregate stddev on columns
type zaehlung_stddev_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev() on columns of table "zaehlung"
input zaehlung_stddev_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_pop on columns
type zaehlung_stddev_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_pop() on columns of table "zaehlung"
input zaehlung_stddev_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate stddev_samp on columns
type zaehlung_stddev_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by stddev_samp() on columns of table "zaehlung"
input zaehlung_stddev_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate sum on columns
type zaehlung_sum_fields {
  _depth: Int
  _rev_at: numeric
}

# order by sum() on columns of table "zaehlung"
input zaehlung_sum_order_by {
  _depth: order_by
  _rev_at: order_by
}

# update columns of table "zaehlung"
enum zaehlung_update_column {
  # column name
  _conflicts

  # column name
  _deleted

  # column name
  _depth

  # column name
  _parent_rev

  # column name
  _rev

  # column name
  _rev_at

  # column name
  _revisions

  # column name
  bemerkungen

  # column name
  changed

  # column name
  changed_by

  # column name
  datum

  # column name
  id

  # column name
  kultur_id

  # column name
  prognose
}

# aggregate var_pop on columns
type zaehlung_var_pop_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_pop() on columns of table "zaehlung"
input zaehlung_var_pop_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate var_samp on columns
type zaehlung_var_samp_fields {
  _depth: Float
  _rev_at: Float
}

# order by var_samp() on columns of table "zaehlung"
input zaehlung_var_samp_order_by {
  _depth: order_by
  _rev_at: order_by
}

# aggregate variance on columns
type zaehlung_variance_fields {
  _depth: Float
  _rev_at: Float
}

# order by variance() on columns of table "zaehlung"
input zaehlung_variance_order_by {
  _depth: order_by
  _rev_at: order_by
}
