{"version":3,"sources":["webpack:///./src/pages/Vermehrung/ArtTree/Tree/index.js","webpack:///./node_modules/mobx-react-lite/dist/index.module.js"],"names":["__webpack_require__","r","__webpack_exports__","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","mobx_react_lite__WEBPACK_IMPORTED_MODULE_1__","observer","a","createElement","d","mobx__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_1__","Error","globalIsUsingStaticRendering","isUsingStaticRendering","EMPTY_ARRAY","useObserver","fn","baseComponentName","forceUpdate","tick","setTick","Object","useForceUpdate","reaction","rendering","useUnmount","current","dispose","track","baseComponent","options","realOptions","assign","forwardRef","displayName","name","wrappedComponent","props","ref","memoComponent","ObserverComponent","children","render","component","ObserverPropsCheck","key","componentName","location","propFullName","extraKey","hasProp","hasExtraProp","propTypes"],"mappings":"2FAAAA,EAAAC,EAAAC,GAAA,IAAAC,EAAAH,EAAA,GAAAI,EAAAJ,EAAAK,EAAAF,GAAAG,EAAAN,EAAA,KAOeO,sBAJF,WACX,OAAOH,EAAAI,EAAAC,cAAA,4DCJTT,EAAAU,EAAAR,EAAA,sBAAAK,IAAA,IAAAI,EAAAX,EAAA,GAAAY,EAAAZ,EAAA,GAGA,IAAKY,EAAA,SACL,UAAAC,MAAA,sEAEA,IAAKF,EAAA,EACL,UAAAE,MAAA,oEAkDA,IAAAC,GAAA,EAIA,SAAAC,IACA,OAAAD,EAGA,MAAAE,EAAA,GAYA,SAAAC,EAAAC,EAAAC,EAAA,YACA,GAAAJ,IACA,OAAAG,IAGA,MAAAE,EAZA,WACA,MAAAC,EAAAC,GAA4BC,OAAAX,EAAA,SAAAW,CAAQ,GAIpC,OAHmBA,OAAAX,EAAA,YAAAW,CAAW,KAC9BD,EAAAD,EAAA,IACK,IAQLG,GACAC,EAAqBF,OAAAX,EAAA,OAAAW,CAAM,IAAKZ,EAAA,cAAqBQ,KAAkB,KACvEC,OAQA,IAAAM,EAIA,OA9BA,SAAAR,GACIK,OAAAX,EAAA,UAAAW,CAAS,IAAAL,EAAAF,GAmBbW,CAAA,KACAF,EAAAG,QAAAC,YAMAJ,EAAAG,QAAAE,MAAA,KACAJ,EAAAR,MAEAQ,EAIA,SAAAnB,EAAAwB,EAAAC,GAEA,GAAAjB,IACA,OAAAgB,EAEA,MAAAE,EAAAV,OAAAW,OAAA,CAAuCC,YAAA,GAAoBH,GAC3Db,EAAAY,EAAAK,aAAAL,EAAAM,KACAC,EAAA,CAAAC,EAAAC,IACAvB,EAAA,IAAAc,EAAAQ,EAAAC,GAAArB,GAKA,IAAAsB,EAYA,OANAA,EALAR,EAAAE,WAKwBZ,OAAAX,EAAA,KAAAW,CAAKA,OAAAX,EAAA,WAAAW,CAAUe,IAGff,OAAAX,EAAA,KAAAW,CAAIe,IAE5BF,YAAAjB,EACAsB,EAGA,SAAAC,GAAAC,SAA4BA,EAAAC,WAC5B,MAAAC,EAAAF,GAAAC,EACA,yBAAAC,EACA,KAEA5B,EAAA4B,GAOA,SAAAC,EAAAP,EAAAQ,EAAAC,EAAAC,EAAAC,GACA,MAAAC,EAAA,aAAAJ,EAAA,oBACAK,EAAA,mBAAAb,EAAAQ,GACAM,EAAA,mBAAAd,EAAAY,GACA,OAAAC,GAAAC,EACA,IAAAxC,MAAA,qEAAAmC,GAEAI,GAAAC,EACA,KAEA,IAAAxC,MAAA,iBACAqC,EACA,qBACAX,EAAAQ,GACA,kBAEAC,EACA,2BAtBAN,EAAAY,UAAA,CACAX,SAAAG,EACAF,OAAAE,GAEAJ,EAAAN,YAAA","file":"component---src-pages-vermehrung-art-tree-tree-index-js-870cc20500a1b7ae7e29.js","sourcesContent":["import React from 'react'\r\nimport { observer } from 'mobx-react-lite'\r\n\r\nconst Tree = () => {\r\n  return <div>TODO Tree</div>\r\n}\r\n\r\nexport default observer(Tree)\r\n","import { spy, observable, Reaction, computed } from 'mobx';\nimport { useState, useRef, useMemo, useEffect, useCallback, forwardRef, memo } from 'react';\n\nif (!useState) {\r\n    throw new Error(\"mobx-react-lite requires React with Hooks support (alpha versions)\");\r\n}\r\nif (!spy) {\r\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\r\n}\n\nfunction useObservable(initialValue) {\r\n    return useRef(observable(initialValue)).current;\r\n}\n\nfunction useComputed(func, inputs = []) {\r\n    const computed$$1 = useMemo(() => computed(func), inputs);\r\n    return computed$$1.get();\r\n}\n\n/**\r\n * Adds an observable effect (reaction, autorun, or anything else that returns a disposer) that will be registered upon component creation and disposed upon unmounting.\r\n * Returns the generated disposer for early disposal.\r\n *\r\n * @export\r\n * @template D\r\n * @param {() => D} disposerGenerator A function that returns the disposer of the wanted effect.\r\n * @param {ReadonlyArray<any>} [inputs=[]] If you want the effect to be automatically re-created when some variable(s) are changed then pass them in this array.\r\n * @returns {D}\r\n */\r\nfunction useDisposable(disposerGenerator, inputs = []) {\r\n    const disposerRef = useRef(undefined);\r\n    useMemo(() => {\r\n        disposerRef.current = disposerGenerator();\r\n    }, inputs);\r\n    useEffect(() => () => {\r\n        if (disposerRef.current && typeof disposerRef.current === \"function\") {\r\n            disposerRef.current();\r\n        }\r\n    }, inputs);\r\n    return disposerRef.current;\r\n}\n\n/**\r\n * Adds an observable effect (reaction, autorun, or anything else that returns a disposer) that will be registered upon component creation and disposed upon unmounting.\r\n * Returns the generated disposer for early disposal.\r\n *\r\n * @deprecated Renamed to useDisposable for a more universal use\r\n * @export\r\n * @template D\r\n * @param {() => D} disposerGenerator A function that returns the disposer of the wanted effect.\r\n * @param {ReadonlyArray<any>} [inputs=[]] If you want the effect to be automatically re-created when some variable(s) are changed then pass them in this array.\r\n * @returns {D}\r\n */\r\nfunction useObservableEffect(disposerGenerator, inputs = []) {\r\n    return useDisposable(disposerGenerator, inputs);\r\n}\n\nlet globalIsUsingStaticRendering = false;\r\nfunction useStaticRendering(enable) {\r\n    globalIsUsingStaticRendering = enable;\r\n}\r\nfunction isUsingStaticRendering() {\r\n    return globalIsUsingStaticRendering;\r\n}\n\nconst EMPTY_ARRAY = [];\r\nfunction useUnmount(fn) {\r\n    useEffect(() => fn, EMPTY_ARRAY);\r\n}\n\nfunction useForceUpdate() {\r\n    const [tick, setTick] = useState(1);\r\n    const update = useCallback(() => {\r\n        setTick(tick + 1);\r\n    }, []);\r\n    return update;\r\n}\r\nfunction useObserver(fn, baseComponentName = \"observed\") {\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    // forceUpdate 2.0\r\n    const forceUpdate = useForceUpdate();\r\n    const reaction = useRef(new Reaction(`observer(${baseComponentName})`, () => {\r\n        forceUpdate();\r\n    }));\r\n    useUnmount(() => {\r\n        reaction.current.dispose();\r\n    });\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    let rendering;\r\n    reaction.current.track(() => {\r\n        rendering = fn();\r\n    });\r\n    return rendering;\r\n}\n\n// n.b. base case is not used for actual typings or exported in the typing files\r\nfunction observer(baseComponent, options) {\r\n    // The working of observer is explaind step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n    if (isUsingStaticRendering()) {\r\n        return baseComponent;\r\n    }\r\n    const realOptions = Object.assign({ forwardRef: false }, options);\r\n    const baseComponentName = baseComponent.displayName || baseComponent.name;\r\n    const wrappedComponent = (props, ref) => {\r\n        return useObserver(() => baseComponent(props, ref), baseComponentName);\r\n    };\r\n    // memo; we are not intested in deep updates\r\n    // in props; we assume that if deep objects are changed,\r\n    // this is in observables, which would have been tracked anyway\r\n    let memoComponent;\r\n    if (realOptions.forwardRef) {\r\n        // we have to use forwardRef here because:\r\n        // 1. it cannot go before memo, only after it\r\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\r\n        //    since it wouldn't be a callable function anymore\r\n        memoComponent = memo(forwardRef(wrappedComponent));\r\n    }\r\n    else {\r\n        memoComponent = memo(wrappedComponent);\r\n    }\r\n    memoComponent.displayName = baseComponentName;\r\n    return memoComponent;\r\n}\n\nfunction ObserverComponent({ children, render }) {\r\n    const component = children || render;\r\n    if (typeof component !== \"function\") {\r\n        return null;\r\n    }\r\n    return useObserver(component);\r\n}\r\nObserverComponent.propTypes = {\r\n    children: ObserverPropsCheck,\r\n    render: ObserverPropsCheck\r\n};\r\nObserverComponent.displayName = \"Observer\";\r\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\r\n    const extraKey = key === \"children\" ? \"render\" : \"children\";\r\n    const hasProp = typeof props[key] === \"function\";\r\n    const hasExtraProp = typeof props[extraKey] === \"function\";\r\n    if (hasProp && hasExtraProp) {\r\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\r\n    }\r\n    if (hasProp || hasExtraProp) {\r\n        return null;\r\n    }\r\n    return new Error(\"Invalid prop `\" +\r\n        propFullName +\r\n        \"` of type `\" +\r\n        typeof props[key] +\r\n        \"` supplied to\" +\r\n        \" `\" +\r\n        componentName +\r\n        \"`, expected `function`.\");\r\n}\n\nexport { useObservable, useComputed, useDisposable, useObservableEffect, isUsingStaticRendering, useStaticRendering, observer, useObserver, ObserverComponent as Observer };\n"],"sourceRoot":""}